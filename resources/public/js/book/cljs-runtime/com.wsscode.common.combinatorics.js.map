{"version":3,"sources":["com/wsscode/common/combinatorics.cljc"],"mappings":";;AAEA,AAAA;;;AAAA,AAAAA,AAAMM;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAME,AAEDI;AAFL,AAGE,AAAMC,AAAgB,AAACC,AAAIF;AACrBG,AACgB;AAAUC;AAAV,AACE,AAAMC,AACA;AAAKD;AAAL,AACE,AAAOE,AAAE,AAAA,AAAK,AAACC,AAAMH;AAAUA,AAAOA;;AAAtC,AACE,AAAI,AAAA,AAACI,AAAEF;AAAP;;AACa,AAAAG,AAAa,AAACE,AAAK,AAACP,AAAAA,AAAAA,AAAOE,AAAAA;AAA3B,AAAA,AAAAG;AAAA,AAAAA,AAASC;AAAT,AACE,AAACE,AAAMR,AAAOE,AAAEI;;AAChB,AAAO,AAAA,AAAKJ;AAAG,AAACM,AAAMR,AAAOE,AAAE,AAACL,AAAAA,AAAAA,AAAgBK,AAAAA;;;;;;;;;;AANzE,AAOE,AAAMF;AAAN,AACE,AAACS,AAAK,AAACC,AAAIC,AAAMX,AACf,AAAAY,AAAA,AAAA;;AAAA,AAAU,AAACb,AAAK,AAACE,AAAUD;;AAA3B,AAAA;;AAFJ;;;;AAV1B,AAaE,AAAM,AAACa,AAAOlB,AAAIC;AAAlB,AACE,AAAAgB,AAAA,AAAA;;AAAA,AAAU,AAACb,AAAKF;;AAAhB,AAAA;;AADF;;;;AAhBJ,AAAA,AAAA,AAAML;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA;AAAA,AAAA,AAAAA,AAAA,AAAAC,AAAAF;;;AAAA","names":["var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","com.wsscode.common.combinatorics/cartesian-product","seq63945","self__4718__auto__","cljs.core/seq","seqs","v-original-seqs","cljs.core/vec","step","v-seqs","increment","i","cljs.core/count","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","temp__5733__auto__","rst","cljs.core/next","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core/cons","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/first","cljs.core/LazySeq","cljs.core/every?"],"sourcesContent":["(ns com.wsscode.common.combinatorics)\n\n(defn cartesian-product\n  \"All the ways to take one item from each sequence\"\n  [& seqs]\n  (let [v-original-seqs (vec seqs)\n        step\n                        (fn step [v-seqs]\n                          (let [increment\n                                (fn [v-seqs]\n                                  (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                                    (if (= i -1) nil\n                                                 (if-let [rst (next (v-seqs i))]\n                                                   (assoc v-seqs i rst)\n                                                   (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n                            (when v-seqs\n                              (cons (map first v-seqs)\n                                (lazy-seq (step (increment v-seqs)))))))]\n    (when (every? seq seqs)\n      (lazy-seq (step v-original-seqs)))))\n"]}