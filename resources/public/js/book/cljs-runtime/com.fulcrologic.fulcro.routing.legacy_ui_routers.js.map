{"version":3,"sources":["com/fulcrologic/fulcro/routing/legacy_ui_routers.cljc"],"mappings":"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","names":["com.fulcrologic.fulcro.routing.legacy-ui-routers/bad-route","page","js/React.createElement","com.fulcrologic.fulcro.routing.legacy-ui-routers/routing-tree-key","com.fulcrologic.fulcro.routing.legacy-ui-routers/routers-table","js/Error","com.fulcrologic.fulcro.routing.legacy-ui-routers/make-route","name","routing-instructions","cljs.core/vector?","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.routing.legacy-ui-routers/routing-tree","seq85396","self__4718__auto__","cljs.core/seq","routes","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__85397","map__85398","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","tree","instructions","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.routing.legacy-ui-routers/router-instruction","router-id","target-screen-ident","com.fulcrologic.fulcro.routing.legacy-ui-routers/current-route","state-map-or-router-table","cljs.core/contains?","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","js/com","js/com.fulcrologic","js/com.fulcrologic.fulcro","js/com.fulcrologic.fulcro.routing","js/com.fulcrologic.fulcro.routing.legacy-ui-routers","js/com.fulcrologic.fulcro.routing.legacy-ui-routers.coerce-param","method-table__4613__auto__","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","prefer-table__4614__auto__","method-cache__4615__auto__","cached-hierarchy__4616__auto__","hierarchy__4617__auto__","cljs.core.get.cljs$core$IFn$_invoke$arity$3","fexpr__85403","cljs.core/MultiFn","cljs.core.symbol.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.routing.legacy-ui-routers/coerce-param","param-keyword","v","k","cljs.core/re-seq","js/parseInt","cljs.core.keyword.cljs$core$IFn$_invoke$arity$1","com.fulcrologic.fulcro.routing.legacy-ui-routers/set-ident-route-params","ident","route-params","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","element","cljs.core/Keyword","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/namespace","G__85411","G__85412","cljs.core/name","com.fulcrologic.fulcro.routing.legacy-ui-routers/set-route*","state-map","screen-ident","cljs.core/assoc-in","com.fulcrologic.fulcro.routing.legacy-ui-routers/set-route","com.fulcrologic.fulcro.mutations/->Mutation","com.fulcrologic.fulcro.mutations/mutate","fulcro-mutation-env-symbol","map__85422","p__85426","map__85427","env","temp__5735__auto__","com.fulcrologic.fulcro.algorithms.lookup/app-algorithm","default-action","router","target","state","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4","_","p__85438","vec__85443","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.routing.legacy-ui-routers/set-routing-query","app","target-kw","G__85446","dynamic?","cljs.core/boolean","query","G__85447","com.fulcrologic.fulcro.routing.legacy-ui-routers/get-dynamic-router-target","com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.application.schedule_render_BANG_.cljs$core$IFn$_invoke$arity$1","com.fulcrologic.fulcro.components/set-query*","com.fulcrologic.fulcro.components.factory.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.routing.legacy-ui-routers/DynamicRouter","p__85454","map__85455","com.fulcrologic.fulcro.routing.legacy-ui-routers/-update-routing-queries","handler","taoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10","taoensso.timbre/*config*","cljs.core/Delay","p__85459","map__85460","ongoing-state","target-router","target-screen","p__85462","map__85463","com.fulcrologic.fulcro.routing.legacy-ui-routers/update-routing-links","p__85466","map__85467","m","parameterized-screen-ident","js/com.fulcrologic.fulcro.routing.legacy-ui-routers.get-dynamic-router-target","fexpr__85470","com.fulcrologic.fulcro.routing.legacy-ui-routers/add-route-state","component","tree-state","com.fulcrologic.fulcro.components.get_initial_state.cljs$core$IFn$_invoke$arity$1","com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$1","normalized-state","com.fulcrologic.fulcro.algorithms.normalize.tree__GT_db.cljs$core$IFn$_invoke$arity$4","com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$1","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.algorithms.do_not_use.deep_merge.cljs$core$IFn$_invoke$arity$variadic","com.fulcrologic.fulcro.routing.legacy-ui-routers/install-route*","com.fulcrologic.fulcro.routing.legacy-ui-routers/install-route-impl","com.fulcrologic.fulcro.routing.legacy-ui-routers/install-route","map__85471","p__85473","map__85474","com.fulcrologic.fulcro.routing.legacy-ui-routers/dynamic-route-key","options__72617__auto__","p__85481","map__85482","com.fulcrologic.fulcro.components/wrapped-render","com.fulcrologic.fulcro.components/props","js/com.fulcrologic.fulcro.routing.legacy-ui-routers.DynamicRouter","props__72618__auto__","this__72619__auto__","temp__5733__auto__","init-state__72620__auto__","obj85489","G__85490","G__85491","goog.object/get","obj85493","com.fulcrologic.fulcro.components/configure-component!","this","props","id","map__85484","current-route","target-key","c","factory","com.fulcrologic.fulcro.routing.legacy-ui-routers/ui-dynamic-router","ui-factory","com.fulcrologic.fulcro.routing.legacy-ui-routers/get-dynamic-router-query","p__85505","map__85506","com.fulcrologic.fulcro.routing.legacy-ui-routers/-process-pending-route!","cljs.core/deref","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2","s","G__85520","com.fulcrologic.fulcro.routing.legacy-ui-routers/-route-target-missing?","screen","cljs.core/first","com.fulcrologic.fulcro.routing.legacy-ui-routers/-is-dynamic-router?","p__85527","map__85530","com.fulcrologic.fulcro.routing.legacy-ui-routers/-get-missing-routes","params","p__85539","map__85540","com.fulcrologic.fulcro.components/ident->any","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","G__85546","com.fulcrologic.fulcro.routing.legacy-ui-routers/-load-dynamic-route","state-atom","pending-route-handler","route-to-load","finish-fn","com.fulcrologic.fulcro.routing.legacy_ui_routers._load_dynamic_route.cljs$core$IFn$_invoke$arity$6","finish","attempt","delay","js/setTimeout","current-pending-route","and__4120__auto__","deferred-result","shadow.loader/load","next-delay","x__4222__auto__","y__4223__auto__","x__4219__auto__","y__4220__auto__","p__85547","map__85548","com.fulcrologic.fulcro.routing.legacy-ui-routers/-load-routes","loaded","pending-route","to-load","cljs.core/count","cljs.core/inc","seq__85550","chunk__85551","count__85552","i__85553","cljs.core/chunked-seq?","c__4550__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/next","r","com.fulcrologic.fulcro.routing.legacy_ui_routers._load_dynamic_route.cljs$core$IFn$_invoke$arity$4","p__85555","map__85556","com.fulcrologic.fulcro.routing.legacy-ui-routers/route-to-impl!","bidi-match","missing-routes","cljs.core/assoc","p1__85554#","com.fulcrologic.fulcro.routing.legacy-ui-routers/route-to*","com.fulcrologic.fulcro.routing.legacy-ui-routers/route-to","map__85561","e85563","t"],"sourcesContent":["(ns com.fulcrologic.fulcro.routing.legacy-ui-routers\n  \"Routers from Fulcro 2. These are a bit harder to use than the new dynamic router, and should probably not be used\n   in new applications; however, they will be supported for the forseeable future.\"\n  #?(:cljs (:require-macros com.fulcrologic.fulcro.routing.legacy-ui-routers))\n  (:require\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.fulcro.mutations :as m :refer [defmutation]]\n    [com.fulcrologic.fulcro.application :as app]\n    [com.fulcrologic.fulcro.components :as comp :refer [defsc]]\n    [com.fulcrologic.fulcro.algorithms.merge :as merge]\n    [com.fulcrologic.fulcro.algorithms.normalize :as fnorm]\n    [com.fulcrologic.fulcro.algorithms.do-not-use :as util]\n    #?@(:clj  [[cljs.analyzer :as ana]]\n        :cljs [[cljsjs.react]\n               [cljs.loader :as loader]])\n    [taoensso.timbre :as log]))\n\n#?(:clj\n   (s/def ::mutation-args\n     (s/cat\n       :sym symbol?\n       :doc (s/? string?)\n       :arglist vector?\n       :body (s/+ (constantly true)))))\n\n(defn bad-route [page]\n  #?(:cljs (js/React.createElement \"div\" nil (str \"Cannot route: Unknown Screen \" page))\n     :clj  (str \"Bad route \" page)))\n\n#?(:clj\n   (defn- emit-union-element [sym ident-arg kws-and-screens]\n     (try\n       (let [query         (reduce (fn [q {:keys [kw sym]}] (assoc q kw `(comp/get-query ~sym))) {} kws-and-screens)\n             first-screen  (-> kws-and-screens first :sym)\n             screen-render (fn [cls] `((comp/factory ~cls {:keyfn (fn [_] ~(name cls))}) (comp/props ~'this)))\n             render-stmt   (reduce (fn [cases {:keys [kw sym]}]\n                                     (-> cases\n                                       (conj kw (screen-render sym)))) [] kws-and-screens)]\n         `(comp/defsc ~sym [~'this ~'props]\n            {:initial-state (fn [~'params] (comp/get-initial-state ~first-screen ~'params))\n             :ident         ~ident-arg\n             :query         (fn [~'this] ~query)}\n            (let [page# (first (comp/get-ident ~'this))]\n              (case page#\n                ~@render-stmt\n                (bad-route page#)))))\n       (catch Exception e `(def ~sym (log/error \"BROKEN ROUTER!\"))))))\n\n#?(:clj\n   (defn- emit-router [router-id sym union-sym]\n     `(comp/defsc ~sym [~'this ~'props ~'computed]\n        {:initial-state (fn [~'params] {::id ~router-id ::current-route (comp/get-initial-state ~union-sym ~'params)})\n         :ident         (fn [~'this ~'props] [:fulcro.client.routing.routers/by-id ~router-id])\n         :query         [::id {::current-route (comp/get-query ~union-sym)}]}\n        (let [props#               (::current-route (comp/props ~'this))\n              props-with-computed# (comp/computed props# ~'computed)]\n          ((comp/factory ~union-sym) props-with-computed#)))))\n\n#?(:clj\n   (s/def ::router-args (s/cat\n                          :sym symbol?\n                          :router-id keyword?\n                          :ident-fn (s/or :method list? :template (s/coll-of keyword? :min-count 2 :max-count 2 :kind vector?))\n                          :kws-and-screens (s/+ (s/cat :kw keyword? :sym symbol?)))))\n\n(def routing-tree-key ::routing-tree)\n(def routers-table :fulcro.client.routing.routers/by-id)    ; NOTE: needed in macro, but hand-coded\n\n(defn make-route\n  \"Make a route name that executes the provided routing instructions to change which screen in on the UI. routing-instructions\n  must be a vector. Returns an item that can be passed to `routing-tree` to generate your overall application's routing\n  plan.\n\n  `(make-route :route/a [(router-instruction ...) ...])`\n\n  \"\n  [name routing-instructions]\n  {:pre [(vector? routing-instructions)]}\n  {:name name :instructions routing-instructions})\n\n(defn routing-tree\n  \"Generate initial state for your application's routing tree. The return value of this should be merged into your overall\n  app state in your Root UI component\n\n  ```\n  (defsc Root [this props]\n    {:initial-state (fn [params]  (merge {:child-key (comp/get-initial-state Child)}\n                                    (routing-tree\n                                      (make-route :route/a [(router-instruction ...)])\n                                      ...)))\n    ...\n  ```\n  \"\n  [& routes]\n  {routing-tree-key (reduce (fn [tree {:keys [name instructions]}] (assoc tree name instructions)) {} routes)})\n\n(defn router-instruction\n  \"Return the definition of a change-route instruction.\"\n  [router-id target-screen-ident]\n  {:target-router router-id\n   :target-screen target-screen-ident})\n\n(defn current-route\n  \"Get the current route (an ident) from the router with the given id. You can pass the entire app database, the routers table,\n  or the props of a component that has queried for the router table as the first argument to this function.\n  Thus, it can be used easily from within a mutation or in a component to find (and display) the current route:\n\n  ```\n  (defmutation do-something-with-routes [params]\n    (action [{:keys [state]}]\n      (let [current (r/current-route state :top-router)]\n      ...)))\n\n  (defsc NavBar [this props]\n    {:query (fn [] [[r/routers-table '_]])\n     :initial-state (fn [params] {})}\n    (let [current (r/current-route props :top-router)]\n      ...))\n  ```\n  \"\n  [state-map-or-router-table router-id]\n  (if (contains? state-map-or-router-table routers-table)\n    (get-in state-map-or-router-table [routers-table router-id ::current-route])\n    (get-in state-map-or-router-table [router-id ::current-route])))\n\n(defmulti coerce-param (fn [param-keyword v] param-keyword))\n(defmethod coerce-param :default [k v]\n  (cond\n    (and (string? v) (seq (re-seq #\"^[0-9][0-9]*$\" v))) #?(:clj  (Integer/parseInt v)\n                                                           :cljs (js/parseInt v))\n    (and (string? v) (seq (re-seq #\"^[a-zA-Z]\" v))) (keyword v)\n    :else v))\n\n(defn set-ident-route-params\n  \"Replace any keywords of the form :params/X with the value of (get route-params :X) in the given ident. By default the value\n  of the parameter (which comes in as a string) will be converted to an int if it is all digits, and will be\n  converted to a keyword if it is all letters. If you want to customize the coercion, just:\n\n  ```\n  (defmethod r/coerce-param :param/NAME [k v] (transform-it v))\n  ```\n  \"\n  [ident route-params]\n  (mapv (fn [element]\n          (if (and (keyword? element) (= \"param\" (namespace element)))\n            (coerce-param element (get route-params (keyword (name element)) element))\n            element))\n    ident))\n\n(defn set-route*\n  \"Set the given screen-ident as the current route on the router with the given ID. Returns a new application\n  state map.\"\n  [state-map router-id screen-ident]\n  (assoc-in state-map [routers-table router-id ::current-route] screen-ident))\n\n(defmutation set-route\n  \"Mutation: Explicitly set the route of a given router to the target screen ident.\"\n  [{:keys [router target]}]\n  (action [{:keys [state]}]\n    (swap! state set-route* router target))\n  (refresh [_] [::current-route]))\n\n(declare DynamicRouter get-dynamic-router-target)\n\n(defn- set-routing-query\n  \"Change the given router's query iff it is a dynamic router. Returns the updated state.\"\n  [state app router-id [target-kw _]]\n  (let [router   (-> state :fulcro.client.routing.routers/by-id router-id)\n        dynamic? (-> router ::dynamic boolean)\n        query    (when dynamic?\n                   (some-> target-kw\n                     get-dynamic-router-target\n                     (comp/get-query state)))]\n    (if query\n      (do\n        (when app (app/schedule-render! app))\n        (comp/set-query* state (comp/factory DynamicRouter {:qualifier router-id})\n          {:query [::id ::dynamic {::current-route query}]}))\n      state)))\n\n(defn -update-routing-queries\n  \"PRIVATE.\n\n  Given the reconciler, state, and a routing tree route: finds and sets all of the dynamic queries needed to\n  accomplish that route. Returns the updated state. reconciler can be nil, in which case UI refresh may not\n  happen, but that is useful for SSR.\"\n  [state app {:keys [handler route-params]}]\n  (let [routing-instructions (get-in state [routing-tree-key handler])]\n    (if-not (or (nil? routing-instructions) (vector? routing-instructions))\n      (do\n        (log/error \"Routing tree does not contain a vector of routing-instructions for handler \" handler)\n        state)\n      (reduce (fn [ongoing-state {:keys [target-router target-screen]}]\n                (set-routing-query ongoing-state app target-router target-screen))\n        state routing-instructions))))\n\n(defn update-routing-links\n  \"Given the app state map, returns a new map that has the routing graph links updated for the given route/params\n  as a bidi match.\n\n  ***This function should only be used if you only use static UI routing.***\n\n  If you use DynamicRouter then you must use `route-to-impl!` instead.\"\n  [state-map {:keys [handler route-params]}]\n  (let [routing-instructions (get-in state-map [routing-tree-key handler])]\n    (if-not (or (nil? routing-instructions) (vector? routing-instructions))\n      (log/error \"Routing tree does not contain a vector of routing-instructions for handler \" handler)\n      (reduce (fn [m {:keys [target-router target-screen]}]\n                (let [parameterized-screen-ident (set-ident-route-params target-screen route-params)]\n                  (set-route* m target-router parameterized-screen-ident))) state-map routing-instructions))))\n\n(defmulti get-dynamic-router-target\n  \"Get the component that renders the given screen type. The parameter is simply the keyword of the module/component.\n  Note that all have to match: the module name in the compiler that contains the code for the component,\n  the first element of the ident returned by the component, and the keyword passed to this multimethod to retrieve\n  the component.\"\n  (fn [k] k))\n\n(defmethod get-dynamic-router-target :default [k] nil)\n\n(defn add-route-state [state-map target-kw component]\n  (let [tree-state       {:tmp/new-route (comp/get-initial-state component)}\n        query            [{:tmp/new-route (comp/get-query component)}]\n        normalized-state (-> (fnorm/tree->db query tree-state true (merge/pre-merge-transform state-map))\n                           (dissoc :tmp/new-route))]\n    (util/deep-merge state-map normalized-state)))\n\n(defn install-route*\n  \"Implementation of mutation. Useful for SSR setup.\"\n  [state-map target-kw component]\n  (add-route-state state-map target-kw component))\n\n(defn- install-route-impl [state target-kw component]\n  (defmethod get-dynamic-router-target target-kw [k] component)\n  (swap! state add-route-state target-kw component))\n\n(defmutation install-route\n  \"Fulcro mutation: Install support for a dynamic route. `target-kw` is the keyword that represents the table name of\n  the target screen (first elemenet of the ident of the component), which must also match internal data in the\n  state of that component at fulcro.client.routing/dynamic-route-key. `component` is the *class* of the UI component that will be\n  shown by the router. It *must* implement InitialAppState to provide at least the value of `target-kw` at the\n  predefined fulcro.client.routing/dynamic-route-key key.\n\n  An example would be that you've defined a component like this:\n\n  (ns app.component\n    (:require fulcro.client.routing))\n\n  (def target-kw :my-component)\n\n  (defsc Component [this props]\n    {:initial-state (fn [p] {fulcro.client.routing/dynamic-route-key target-kw})\n     :ident (fn [this props] [target-kw :singleton])}\n    ...)\n\n  and during startup you install this route as:\n\n  (transact! this `[(install-route {:target-kw :my-component :component Component})])\n  \"\n  [{:keys [target-kw component]}]\n  (action [{:keys [state]}]\n    (install-route-impl state target-kw component)))\n\n(def dynamic-route-key ::dynamic-route)\n\n(defsc DynamicRouter [this props]\n  {:initial-state (fn [{:keys [id]}] {::id id ::dynamic true ::current-route {}})\n   :ident         (fn [] [routers-table (::id props)])\n   :query         (fn [] [::id ::dynamic ::current-route])}\n  (let [{:keys [::id ::current-route]} (comp/props this)\n        target-key (get current-route dynamic-route-key)\n        c          (get-dynamic-router-target target-key)\n        factory    (when c (comp/factory c {:keyfn dynamic-route-key :qualifier id}))]\n    (when factory\n      (factory current-route))))\n\n(defn ui-dynamic-router [props]\n  (let [ui-factory (comp/factory DynamicRouter {:qualifier (get props ::id) :keyfn ::id})]\n    (ui-factory props)))\n\n(defn get-dynamic-router-query\n  \"Get the query for the router with the given router-id.\"\n  [router-id]\n  (comp/get-query (comp/factory DynamicRouter {:qualifier router-id})))\n\n(defn -process-pending-route!\n  \"Finish doing the routing after a module completes loading\"\n  [{:keys [state app] :as env}]\n  (let [target (::pending-route @state)]\n    (swap! state\n      (fn [s]\n        (cond-> (dissoc s ::pending-route)\n          :always (-update-routing-queries app target)\n          (contains? target :handler) (update-routing-links target))))))\n\n(defn -route-target-missing?\n  \"Returns true iff the given ident has no component loaded into the dynamic routing multimethod.\"\n  [ident]\n  (let [screen (first ident)\n        c      (get-dynamic-router-target screen)]\n    (nil? c)))\n\n(defn -is-dynamic-router?\n  \"Returns true if the given component (instance) is a DynamicRouter.\"\n  [component]\n  (instance? DynamicRouter component))\n\n(defn -get-missing-routes\n  \"Returns a sequence of routes that need to be loaded in order for routing to succeed.\"\n  [app state-map {:keys [handler route-params] :as params}]\n  #?(:clj  []\n     :cljs (let [routing-instructions (get-in state-map [routing-tree-key handler])]\n             (if-not (or (nil? routing-instructions) (vector? routing-instructions))\n               (do\n                 (log/error \"Routing tree does not contain a vector of routing-instructions for handler \" handler)\n                 [])\n               (reduce\n                 (fn [routes {:keys [target-router target-screen]}]\n                   (let [router (comp/ident->any app [routers-table target-router])]\n                     (if (and (-is-dynamic-router? router) (-route-target-missing? target-screen))\n                       (conj routes (first target-screen))\n                       routes)))\n                 []\n                 routing-instructions)))))\n\n(defn -load-dynamic-route\n  \"Triggers the actual load of a route, and retries if the networking is down. If the pending route (in state) has changed\n  between retries, then no further retries will be attempted. Exponential backoff with a 10 second max is used as long\n  as retries are being done.\"\n  ([state-atom pending-route-handler route-to-load finish-fn]\n   (-load-dynamic-route state-atom pending-route-handler route-to-load finish-fn 0 0))\n  ([state-atom pending-route-handler route-to-load finish attempt delay]\n   #?(:cljs (js/setTimeout\n              (fn []\n                (let [current-pending-route (get @state-atom ::pending-route)]\n                  (when (and pending-route-handler (= current-pending-route pending-route-handler))\n                    ; if the load succeeds, finish will be called to finish the route instruction\n                    (let [deferred-result (loader/load route-to-load)\n                          ;; see if the route is no longer needed (pending has changed)\n                          next-delay      (min 10000 (* 2 (max 1000 delay)))]\n                      ; if the load fails, retry\n                      (.addCallback deferred-result finish)\n                      (.addErrback deferred-result\n                        (fn [_]\n                          (log/error (str \"Route load failed for \" route-to-load \". Attempting retry.\"))\n                          ; TODO: We're tracking attempts..but I don't see a reason to stop trying if the route is still pending...\n                          (-load-dynamic-route state-atom pending-route-handler route-to-load finish (inc attempt) next-delay)))))))\n              delay))))\n\n(defn -load-routes [{:keys [state] :as env} routes]\n  #?(:clj (log/info \"Dynamic loading of routes is not done on the server itself.\")\n     :cljs\n          (let [loaded        (atom 0)\n                pending-route (get @state ::pending-route)\n                to-load       (count routes)\n                finish        (fn [k]\n                                (fn []\n                                  (swap! loaded inc)\n                                  (when (= @loaded to-load)\n                                    (swap! state add-route-state k (get-dynamic-router-target k))\n                                    (-process-pending-route! env))))]\n            (doseq [r routes]\n              (-load-dynamic-route state pending-route r (finish r))))))\n\n(defn route-to-impl!\n  \"Mutation implementation, for use as a composition into other mutations. This function can be used\n  from within mutations. If a DynamicRouter is used in your routes, then this function may trigger\n  code loading. Once the loading is complete (if any is needed), it will trigger the actual UI routing.\n\n  If routes are being loaded, then the root property in your app state :fulcro.client.routing/pending-route\n  will be your `bidi-match`. You can use a link query to pull this into your UI to show some kind of indicator.\n\n  NOTE: this function updates application state and *must not* be used from within a swap on that state.\"\n  [{:keys [state app] :as env} bidi-match]\n  (if-let [missing-routes (seq (-get-missing-routes app @state bidi-match))]\n    (if (= bidi-match (get @state ::pending-route))\n      ; TODO: This could be the user clicking again, or a legitimate failure...Not much more I can do yet.\n      (log/error \"Attempt to trigger a route that was pending, but that wasn't done loading (or failed to load).\")\n      (do\n        (swap! state assoc ::pending-route bidi-match)\n        (-load-routes env missing-routes)))\n    (do\n      (swap! state #(-> %\n                      (-update-routing-queries app bidi-match)\n                      (dissoc ::pending-route)\n                      (update-routing-links bidi-match))))))\n\n(defn route-to*\n  \"Implementation of routing tree data manipulations on app state. Returns an updated app state.\n\n  WARNING: This function will not trigger dynamic module loading, as it is\n  only responsible for returning a state-map that has been set (as far as is possible) to the given route. You typically\n  do *not* want to use this on a client, but exists a separate function for server-side rendering to be easily able\n  to route, since no dynamic code loading will be needed.\"\n  [state-map bidi-match]\n  (-> state-map\n    (-update-routing-queries nil bidi-match)\n    (dissoc ::pending-route)\n    (update-routing-links bidi-match)))\n\n(m/defmutation route-to\n  \"Mutation (use in transact! only):\n\n  Change the application's overall UI route to the given route by handler. Handler must be a single keyword that\n  indicates an entry in your routing tree (which must be in the initial app state of your UI root). route-params\n  is a map of key-value pairs that will be substituted in the target screen idents of the routing tree.\n\n  If any of the routers are dynamic, then this mutation will check to see if the target routes are loaded. If any\n  are not present, then module load(s) will be triggered for them, and the route will be pending until the code arrives.\n\n  If a new route-to is run before pending routes are installed, then the pending route will be cancelled, but the code\n  loading will continue.\n\n  You may use a link query to get [:fulcro.client.routing/pending-route '_] in your application. If it is not nil\n  then a route is pending, and you can show UI indicators of this.\n\n  Server-side rendering should require all dynamic portions of the UI and use `route-to*`.\"\n  [{:keys [handler route-params] :as params}]\n  (action [env]\n    (try\n      (route-to-impl! env params)\n      (catch #?(:clj Throwable :cljs :default) t\n        (log/error \"Routing failed!\" t)))))\n\n#?(:clj\n   (defn compile-error [env form message ex]\n     (throw (ana/error (merge env (some-> form meta)) message ex))))\n\n#?(:clj\n   (defn- defsc-router-union-element* [env sym arglist {:keys [ident router-targets default-route] :as options} bad-route-render]\n     (when-not default-route (compile-error env options \"`:default-route Class` is required in options.\" nil))\n     (let [this-target      (first arglist)\n           props-target     (second arglist)\n           screen-render    (fn [cls] `((comp/factory ~cls) ~'props))\n           query            (reduce (fn [q [kw sym]] (assoc q kw `(comp/get-query ~sym))) {} router-targets)\n           query-fn         (apply list `(~'fn [] ~query))\n           initial-state-fn (apply list `(~'fn [~'params] (comp/get-initial-state ~default-route ~'params)))\n           render-cases     (reduce\n                              (fn [cases [kw sym]]\n                                (-> cases\n                                  (conj kw (screen-render sym))))\n                              []\n                              router-targets)]\n       `(comp/defsc ~sym [~'this ~props-target]\n          {:initial-state ~initial-state-fn\n           :query         ~query-fn\n           :ident         ~ident}\n          (let [~'props (comp/props ~'this)\n                page# (first (comp/get-ident ~'this ~'props))]\n            (case page#\n              ~@render-cases\n              (let [~this-target ~'this]\n                ~@bad-route-render)))))))\n\n#?(:clj (s/def ::router-targets (s/map-of keyword? (s/or :sym symbol? :dflt list?))))\n#?(:clj (s/def ::ident list?))\n#?(:clj (s/def ::router-id any?))\n#?(:clj (s/def ::default-route symbol?))\n#?(:clj (s/def ::defsc-router-options (s/keys :req-un [::router-targets ::ident ::router-id ::default-route])))\n\n#?(:clj\n   (defn defsc-router-router-element* [env router-sym union-sym arglist options]\n     (when-not (contains? options :router-id)\n       (compile-error env options \":router-id is required in optoins.\" nil))\n     (let [{:keys [router-id]} options\n           this-sym          (first arglist)\n           union-factory-sym (symbol (str \"ui-\" (name router-sym) \"-Union\"))\n           initial-state     (list `fn '[params] {::id router-id ::current-route `(comp/get-initial-state ~union-sym ~'params)})\n           ident             (list `fn '[] [:fulcro.client.routing.routers/by-id router-id])\n           query-fn          (list `fn '[] [::id {::current-route `(comp/get-query ~union-sym)}])\n           options           (merge\n                               (dissoc options :router-targets :router-id)\n                               `{:initial-state ~initial-state\n                                 :ident         ~ident\n                                 :query         ~query-fn})]\n       (when-not (symbol? this-sym)\n         (compile-error env arglist \"'this' argument MUST be a symbol.\" nil))\n       `(comp/defsc ~router-sym ~arglist\n          ~options\n          (let [computed#            (comp/get-computed ~this-sym)\n                props#               (::current-route (comp/props ~this-sym))\n                props-with-computed# (comp/computed props# computed#)]\n            (~union-factory-sym props-with-computed#))))))\n\n#?(:clj\n   (defn defsc-router* [env router-sym arglist options body]\n     (when-not (and (vector? arglist) (<= 2 (count arglist)))\n       (compile-error env options \"defsc-router argument list must have entries for this and props.\" nil))\n     (when-not (map? options)\n       (compile-error env options \"defsc-router requires a literal map of options.\" nil))\n     (when-not (s/valid? ::defsc-router-options options)\n       (compile-error env options (str \"defsc-router options are invalid:\\n\" (s/explain-str ::defsc-router-options options)) nil))\n     (let [union-sym         (symbol (str (name router-sym) \"-Union\"))\n           union-factory-sym (symbol (str \"ui-\" (name router-sym) \"-Union\"))\n           union-component   (defsc-router-union-element* env union-sym arglist options body)\n           union-factory     `(def ~union-factory-sym (comp/factory ~union-sym))\n           router-component  (defsc-router-router-element* env router-sym union-sym arglist options)]\n       `(do\n          ~union-component\n          ~union-factory\n          ~router-component))))\n\n#?(:clj\n   (defmacro\n     ^{:doc\n       \"Define a router component.\n\n       This is just like `defsc`, BUT generates a pair of components that optimize query performance and allow for efficient\n       UI changes.  The options are identical to `defsc`, except:\n\n       Required Options:\n\n       - `:router-id` - An ID for the router\n       - `:ident` - An ident that works across all of the routing targets. This kind of router generates a union query,\n                    so this ident function must work on ALL router targets, and MUST vary the FIRST elements of the ident\n                    to identiy which screen to show.\n       - `:default-route` - The Class of the router target that is the default (initial) route.\n       - `:router-targets` - A map of ident tables to router targets.  This map MUST correspond to the TABLE name that\n       the router target lives in, and the Class of the router target component.\n\n       You may NOT define a `:query` or `:initial-state` for a router.\n\n       All other `defsc` options are supported.\n\n        ```\n        (defsc-router TopRouter [this props]\n          {\n           ;; REQUIRED for router:\n           :router-id :top-router\n           :ident (fn [this props] [(:table props) (:id props)]\n           :router-targets  {:A A :B B :C C}\n           :default-route A\n\n           :css [] ; garden css rules\n           :css-include [] ; list of components that have CSS to compose towards root.\n\n           ; React Lifecycle Methods (this in scope)\n           :initLocalState            (fn [this] ...) ; CAN BE used to call things as you might in a constructor. Return value is initial state.\n           :shouldComponentUpdate     (fn [this next-props next-state] ...)\n\n           :componentDidUpdate        (fn [this prev-props prev-state snapshot] ...) ; snapshot is optional, and is 16+. Is context for 15\n           :componentDidMount         (fn [this ] ...)\n           :componentWillUnmount      (fn [this ] ...)\n\n           ;; DEPRECATED IN REACT 16 (to be removed in 17):\n           :componentWillReceiveProps        (fn [this next-props] ...)\n           :componentWillUpdate              (fn [this next-props next-state] ...)\n           :componentWillMount               (fn [this ] ...)\n\n           ;; Replacements for deprecated methods in React 16.3+\n           :UNSAFE_componentWillReceiveProps (fn [this next-props] ...)\n           :UNSAFE_componentWillUpdate       (fn [this next-props next-state] ...)\n           :UNSAFE_componentWillMount        (fn [this ] ...)\n\n           ;; ADDED for React 16:\n           :componentDidCatch         (fn [this error info] ...)\n           :getSnapshotBeforeUpdate   (fn [prevProps prevState] ...)\n           :getDerivedStateFromProps  (fn [props state] ...)\n        ```\n        \"}\n     defsc-router [sym arglist options & body]\n     (defsc-router* &env sym arglist options body)))\n\n"]}