{"version":3,"sources":["com/fulcrologic/fulcro/routing/dynamic_routing.cljc"],"mappings":"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","names":["com.fulcrologic.fulcro.routing.dynamic-routing/route-segment","class","com.fulcrologic.fulcro.components.component_options.cljs$core$IFn$_invoke$arity$variadic","com.fulcrologic.fulcro.routing.dynamic-routing/get-route-cancelled","com.fulcrologic.fulcro.routing.dynamic-routing/route-cancelled","route-params","temp__5735__auto__","f","com.fulcrologic.fulcro.routing.dynamic-routing/get-will-enter","temp__5733__auto__","will-enter","ident","com.fulcrologic.fulcro.components.get_ident.cljs$core$IFn$_invoke$arity$2","_","com.fulcrologic.fulcro.routing.dynamic-routing/route-immediate","com.fulcrologic.fulcro.routing.dynamic-routing/will-enter","app","params","com.fulcrologic.fulcro.routing.dynamic-routing/route-target?","component","cljs.core/boolean","com.fulcrologic.fulcro.routing.dynamic-routing/get-will-leave","this","or__4131__auto__","cljs.core/constantly","com.fulcrologic.fulcro.routing.dynamic-routing/will-leave","c","props","com.fulcrologic.fulcro.routing.dynamic-routing/route-lifecycle?","com.fulcrologic.fulcro.routing.dynamic-routing/get-targets","router","cljs.core/set","cljs.core/with-meta","com.fulcrologic.fulcro.routing.dynamic-routing/route-deferred","completion-fn","com.fulcrologic.fulcro.routing.dynamic-routing/immediate?","G__88500","cljs.core/meta","p__88504","map__88505","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.routing.dynamic-routing/apply-route*","state-map","target","router-class","router-id","cljs.core/second","target-class","taoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10","taoensso.timbre/*config*","cljs.core/Delay","cljs.core/assoc-in","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","cljs.core.update_in.cljs$core$IFn$_invoke$arity$4","cljs.core/dissoc","com.fulcrologic.fulcro.components/set-query*","com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.routing.dynamic-routing/router-for-pending-target","routers","G__88510","cljs.core/vals","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","r","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","G__88512","cljs.core/reduced","com.fulcrologic.fulcro.routing.dynamic-routing/target-ready","com.fulcrologic.fulcro.mutations/->Mutation","com.fulcrologic.fulcro.mutations/mutate","fulcro-mutation-env-symbol","map__88513","p__88517","map__88518","env","com.fulcrologic.fulcro.algorithms.lookup/app-algorithm","default-action","com.fulcrologic.fulcro.application/current-state","com.fulcrologic.fulcro.ui_state_machines.trigger_BANG_.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.routing.dynamic-routing/target-ready!","component-or-app","com.fulcrologic.fulcro.components.transact_BANG_.cljs$core$IFn$_invoke$arity$2","G__88532","com.fulcrologic.fulcro.routing.dynamic-routing/router?","com.fulcrologic.fulcro.routing.dynamic-routing/matching-prefix","route-segment","actual-path","matching-segment","p__88534","vec__88535","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","result","expected","actual","cljs.core/Keyword","cljs.core/seq","cljs.core.map.cljs$core$IFn$_invoke$arity$3","a","b","cljs.core/count","com.fulcrologic.fulcro.routing.dynamic-routing/current-route-class","com.fulcrologic.fulcro.components/component->state-map","G__88542","edn-query-language.core/query->ast","p1__88541#","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/first","js/goog.DEBUG","com.fulcrologic.fulcro.components/class->registry-key","com.fulcrologic.fulcro.components/registry-key->class","com.fulcrologic.fulcro.routing.dynamic-routing/route-target","path","and__4120__auto__","targets","matches","prefix","G__88547","cljs.core.sort_by.cljs$core$IFn$_invoke$arity$2","cljs.core/reverse","max-length","G__88548","match","p1__88545#","com.fulcrologic.fulcro.routing.dynamic-routing/accepts-route?","p__88551","map__88552","com.fulcrologic.fulcro.routing.dynamic-routing/ast-node-for-route","children","ast-node","p1__88549#","cljs.core/some","p1__88550#","p__88557","map__88559","com.fulcrologic.fulcro.routing.dynamic-routing/ast-node-for-live-router","com.fulcrologic.fulcro.components/class->any","live-router?","p1__88555#","p1__88556#","com.fulcrologic.fulcro.routing.dynamic-routing/apply-route","map__88563","p__88565","map__88566","state","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3","p__88568","map__88569","com.fulcrologic.fulcro.routing.dynamic-routing/mark-route-pending*","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.routing.dynamic-routing/ready-handler","com.fulcrologic.fulcro.ui-state-machines/store","com.fulcrologic.fulcro.ui_state_machines.retrieve.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.ui_state_machines.apply_action.cljs$core$IFn$_invoke$arity$variadic","target-ready*","com.fulcrologic.fulcro.routing.dynamic-routing/fail-handler","p__88571","map__88572","com.fulcrologic.fulcro.routing.dynamic-routing/route-handler","event-data","map__88574","cljs.core.get.cljs$core$IFn$_invoke$arity$3","error-timeout","deferred-timeout","path-segment","immediate?","com.fulcrologic.fulcro.ui-state-machines/activate","com.fulcrologic.fulcro.ui_state_machines.set_timeout.cljs$core$IFn$_invoke$arity$6","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.ui-state-machines/register-state-machine!","com.fulcrologic.fulcro.routing.dynamic-routing/RouterStateMachine","com.fulcrologic.fulcro.routing.dynamic-routing/proposed-new-path","this-or-app","relative-class-or-instance","new-route","cljs.core/deref","com.fulcrologic.fulcro.components/any->app","root-query","ast","root","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","G__88577","map__88578","map__88592","map__88594","matching-prefix","target-ast","G__88596","prefix-length","remaining-path","cljs.core/vec","cljs.core.drop.cljs$core$IFn$_invoke$arity$2","segment","p__88597","vec__88598","p","k","v","target-ident","edn-query-language.core/ident?","com.fulcrologic.fulcro.components/component-name","cljs.core/contains?","G__88602","cljs.core/vector?","cljs.core/conj","cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$6","cljs.core/assoc","com.fulcrologic.fulcro.routing.dynamic-routing/signal-router-leaving","app-or-comp","new-path","to-signal","to-cancel","G__88606","map__88607","map__88609","node","new-path-remaining","map__88611","new-target","router-ident","active-target","next-router","p1__88603#","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","mounted-target-class","p__88613","map__88614","acc","dispatch-key","G__88616","mounted-targets","com.fulcrologic.fulcro.components/class->all","cljs.core/into","cljs.core/rest","components","seq__88618","chunk__88619","count__88620","i__88621","cljs.core/chunked-seq?","c__4550__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/next","p1__88604#","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.components/props","seq__88622","chunk__88623","count__88624","i__88625","t","map__88632","map__88638","G__88633","G__88639","var_args","G__88642","com.fulcrologic.fulcro.routing.dynamic-routing/change-route-relative","js/Error","com.fulcrologic.fulcro.routing.dynamic_routing.change_route_relative.cljs$core$IFn$_invoke$arity$4","timeouts","cljs.core/not","G__88644","map__88645","map__88670","map__88672","G__88674","p__88675","vec__88676","completing-action","G__88687","cljs.core/identity","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4","com.fulcrologic.fulcro.ui-state-machines/get-active-state","com.fulcrologic.fulcro.ui_state_machines.begin_BANG_.cljs$core$IFn$_invoke$arity$5","com.fulcrologic.fulcro.ui-state-machines/with-actor-class","com.fulcrologic.fulcro.ui_state_machines.trigger_BANG_.cljs$core$IFn$_invoke$arity$4","G__88689","com.fulcrologic.fulcro.routing.dynamic-routing/change-route","com.fulcrologic.fulcro.routing.dynamic_routing.change_route.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.application/root-class","com.fulcrologic.fulcro.routing.dynamic-routing/current-route","G__88695","map__88696","map__88699","sm-env","com.fulcrologic.fulcro.ui_state_machines.state_machine_env.cljs$core$IFn$_invoke$arity$5","p1__88691#","com.fulcrologic.fulcro.routing.dynamic-routing/validate-route-targets","router-instance","seq__88702","chunk__88704","count__88705","i__88706","valid?","cljs.core/empty?","p1__88701#","cljs.core/every?","com.fulcrologic.fulcro.routing.dynamic-routing/all-reachable-routers","component-class","map__88712","get-routers","nodes","p__88714","map__88715","cljs.core.into.cljs$core$IFn$_invoke$arity$2","get-routers*","com.fulcrologic.fulcro.routing.dynamic-routing/initialize!","tx","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","G__88717","com.fulcrologic.fulcro.ui-state-machines/begin"],"sourcesContent":["(ns com.fulcrologic.fulcro.routing.dynamic-routing\n  #?(:cljs (:require-macros [com.fulcrologic.fulcro.routing.dynamic-routing]))\n  (:require\n    [ghostwheel.core :refer [>fdef => ?]]\n    [com.fulcrologic.fulcro.ui-state-machines :as uism :refer [defstatemachine]]\n    [com.fulcrologic.fulcro.components :as comp]\n    [com.fulcrologic.fulcro.application :as app]\n    [com.fulcrologic.fulcro.mutations :refer [defmutation]]\n    [edn-query-language.core :as eql]\n    [taoensso.timbre :as log]\n    [clojure.spec.alpha :as s]\n    #?(:clj [cljs.analyzer :as ana])))\n\n(declare route-immediate)\n\n(defn route-segment [class]\n  \"Returns a vector that describes the sub-path that a given route target represents. String elements represent\n  explicit path elements, and keywords represent variable values (which are always pulled as strings).\"\n  (comp/component-options class :route-segment))\n\n(defn get-route-cancelled [class]\n  \"Returns the function that should be called if this target was in a deferred state and a different routing choice was made. Is given the same route parameters that were sent to `will-enter`.\"\n  (comp/component-options class :route-cancelled))\n\n(defn route-cancelled\n  \"Universal CLJC version of will-enter.  Don't use the protocol method in CLJ.\"\n  [class route-params]\n  (when-let [f (get-route-cancelled class)]\n    (f route-params)))\n\n(defn get-will-enter [class]\n  \"Returns the function that is called before a route target is activated (if the route segment of interest has changed and the\n  target of the result is this target).  MUST return (r/route-immediate ident) or (r/route-deferred ident) to indicate\n  what ident should be used in app state to connect the router's join.  If deferred, the router must cause a call to\n  the r/target-ready mutation (or use the target-ready* mutation helper) with a {:target ident} parameter to indicate\n  that the route target is loaded and ready for display.\n\n  `params` will be a map from any keywords found in `route-segment` to the string value of that path element.\n\n  WARNING: This method MUST be side-effect free.\"\n  (if-let [will-enter (comp/component-options class :will-enter)]\n    will-enter\n    (let [ident (comp/get-ident class {})]\n      (fn [_ _] (route-immediate ident)))))\n\n(defn will-enter\n  \"Universal CLJC version of will-enter.  Don't use the protocol method in CLJ.\"\n  [class app params]\n  (when-let [will-enter (get-will-enter class)]\n    (will-enter app params)))\n\n(defn route-target? [component] (boolean (comp/component-options component :route-segment)))\n\n;; NON-static protocol for interacting as a route target\n(defn get-will-leave [this] \"Returns the function of a route target to be called with\n  the current component and props. If it returns `true` then the routing operation will continue.  If it returns `false`\n  then whatever new route was requested will be completely abandoned.  It is the responsibility of this method to give\n  UI feedback as to why the route change was aborted.\"\n  (or (comp/component-options this :will-leave) (constantly true)))\n\n(defn will-leave [c props]\n  (when-let [f (get-will-leave c)]\n    (f c props)))\n\n(defn route-lifecycle? [component] (boolean (comp/component-options component :will-leave)))\n\n(defn get-targets [router] \"Returns a set of classes to which this router routes.\"\n  (set (comp/component-options router :router-targets)))\n\n(defn route-immediate [ident] (with-meta ident {:immediate true}))\n(defn route-deferred [ident completion-fn] (with-meta ident {:immediate false\n                                                             :fn        completion-fn}))\n(defn immediate? [ident] (some-> ident meta :immediate))\n\n(defn- apply-route* [state-map {:keys [router target]}]\n  (let [router-class (-> router meta :component)\n        router-id    (second router)\n        target-class (-> target meta :component)]\n    (log/debug \"Applying route ident\" target \"to router\" router-id)\n    (when (nil? router-class)\n      (log/error \"apply-route* was called without a proper :router argument.\"))\n    (when (nil? target-class)\n      (log/error \"apply-route* for router \" router-class \"was given a target that did not have a component. \"\n        \"Did you remember to call route-deferred or route-immediate?\"))\n    (-> state-map\n      (assoc-in (conj router ::current-route) target)\n      (update-in router dissoc ::pending-route)\n      (comp/set-query* router-class {:query [::id [::uism/asm-id router-id] {::current-route (comp/get-query target-class state-map)}]}))))\n\n(defn router-for-pending-target [state-map target]\n  (let [routers   (some-> state-map ::id vals)\n        router-id (reduce (fn [_ r]\n                            (when (= target (some-> r ::pending-route :target))\n                              (reduced (::id r))))\n                    nil\n                    routers)]\n    router-id))\n\n(defmutation target-ready\n  \"Mutation: Indicate that a target is ready.\"\n  [{:keys [target]}]\n  (action [{:keys [app]}]\n    (let [state-map (app/current-state app)\n          router-id (router-for-pending-target state-map target)]\n      (if router-id\n        (do\n          (log/debug \"Router\" router-id \"notified that pending route is ready.\")\n          (uism/trigger! app router-id :ready!))\n        (log/error \"dr/target-ready! was called but there was no router waiting for the target listed: \" target\n          \"This could mean you sent one ident, and indicated ready on another.\"))))\n  (refresh [_] [::current-route]))\n\n(defn target-ready!\n  \"Indicate a target is ready.  Safe to use from within mutations.\n\n  target - The ident that was originally listed as a deferred target.\"\n  [component-or-app target]\n  (comp/transact! component-or-app [(target-ready {:target target})]))\n\n(defn router? [component] (boolean (comp/component-options component :router-targets)))\n\n(defn matching-prefix\n  \"Returns the elements of actual-path that match the route-segment definition.\"\n  [route-segment actual-path]\n  (let [matching-segment (reduce\n                           (fn [result [expected actual]]\n                             (cond\n                               (and (string? expected) (= expected actual))\n                               (conj result actual)\n\n                               (and (keyword? expected) (seq (str actual)))\n                               (conj result (str actual))\n\n                               :otherwise result))\n                           []\n                           (map (fn [a b] [a b]) route-segment actual-path))]\n    (when (= (count matching-segment) (count route-segment))\n      matching-segment)))\n\n(defn current-route-class\n  \"Get the class of the component that is currently being routed to.\"\n  [this]\n  (let [state-map (comp/component->state-map this)\n        class     (some->> (comp/get-query this state-map) eql/query->ast :children\n                    (filter #(= ::current-route (:key %))) first :component)\n        ;; Hot code reload support to avoid getting the cached class from old metadata\n        class     (if #?(:cljs goog.DEBUG :clj false)\n                    (-> class comp/class->registry-key comp/registry-key->class)\n                    class)]\n\n    class))\n\n(defn route-target\n  \"Given a router class and a path segment, returns the class of the router-class that is the target of the given URI path,\n  which is a vector of (string) URI components.\n\n  Returns nil if there is no target that accepts the path, or a map containing:\n\n  {:target class\n   :matching-prefix prefix}\n\n  where `class` is the component class that accepts the path (the target, NOT the router), and `matching-prefix` is the\n  portion of the path that is accepted by that class.\n\n  NOTE: If more than one target matches, then the target with the longest match will be returned. A warning will be\n  printed if more than one match of equal length is found.\n  \"\n  [router-class path]\n  (when (and router-class (router? router-class))\n    (let [targets    (get-targets router-class)\n          matches    (->> (reduce (fn [result target-class]\n                                    (let [prefix (and target-class (route-target? target-class)\n                                                   (some-> target-class (route-segment) (matching-prefix path)))]\n                                      (if (and prefix (seq prefix))\n                                        (conj result {:length          (count prefix)\n                                                      :matching-prefix prefix\n                                                      :target          target-class})\n                                        result))) [] targets)\n                       (sort-by :length)\n                       reverse)\n          max-length (some-> matches first :length)\n          match      (filter #(= max-length (:length %)) matches)]\n      (when (second match)\n        (log/warn \"More than one route target matches\" path))\n      (first match))))\n\n(defn accepts-route?\n  \"Returns true if the given component is a router that manages a route target that will accept the given path.\"\n  [component path]\n  (boolean (route-target component path)))\n\n(defn ast-node-for-route\n  \"Returns the AST node for a query that represents the router that has a target that can accept the given path. This is a breadth-first\n  search.\n\n  ast - A query AST node\n  path - A vector of the current URI segments.\n\n  Returns an AST node or nil if none is found.\"\n  [{:keys [component children] :as ast-node} path]\n  (or\n    (and (accepts-route? component path) ast-node)\n    (some #(and (accepts-route? (:component %) path) %) children)\n    (some #(ast-node-for-route % path) children)))\n\n(defn ast-node-for-live-router\n  \"Returns the AST node for a query that represents the closest \\\"live\\\" (on-screen) router\n\n  ast - A query AST node\n\n  Returns an AST node or nil if none is found.\"\n  [app {:keys [component children] :as ast-node}]\n  (letfn [(live-router? [c] (and (router? c) (boolean (comp/class->any app c))))]\n    (or\n      (and (live-router? component) ast-node)\n      (some #(and (live-router? (:component %)) %) children)\n      (some #(ast-node-for-live-router app %) children))))\n\n\n(defmutation apply-route\n  \"Mutation: Indicate that a given route is ready and should show the result.\n\n  router - The ident of the router, with metadata :component that is the class of the router.\n  target - The ident of the target route, with metadata :component that is the class of the target.\"\n  [{:keys [router target] :as params}]\n  (action [{:keys [state]}]\n    (swap! state apply-route* params)))\n\n(defn mark-route-pending* [state-map {:keys [router target] :as params}]\n  (assoc-in state-map (conj router ::pending-route) params))\n\n(letfn [(target-ready*\n          [state-map target]\n          (let [router-id (router-for-pending-target state-map target)]\n            (if router-id\n              (apply-route* state-map (get-in state-map [::id router-id ::pending-route]))\n              state-map)))]\n  (defn ready-handler [env]\n    (-> env\n      (uism/store :path-segment (uism/retrieve env :pending-path-segment))\n      (uism/store :pending-path-segment [])\n      (uism/apply-action target-ready* (uism/retrieve env :target)))))\n\n(defn fail-handler [env] env)\n\n(defn route-handler [{::uism/keys [event-data] :as env}]\n  (let [{:keys [router target error-timeout deferred-timeout path-segment] :or {error-timeout 5000 deferred-timeout 100}} event-data\n        immediate? (immediate? target)]\n    (-> (if immediate?\n          (-> env\n            (uism/store :path-segment path-segment)\n            (uism/apply-action apply-route* event-data)\n            (uism/activate :routed))\n          (-> env\n            (uism/store :pending-path-segment path-segment)\n            (uism/apply-action mark-route-pending* event-data)\n            (uism/set-timeout :error-timer :timeout! {} error-timeout #{:ready! :route!})\n            (uism/set-timeout :delay-timer :waiting! {} deferred-timeout #{:ready! :route!})\n            (uism/activate :deferred)))\n      (uism/store :target target))))\n\n(defstatemachine RouterStateMachine\n  {::uism/actors\n   #{:router}\n\n   ::uism/aliases\n   {:current-route [:router ::current-route]\n    :state         [:router ::current-state]}\n\n   ::uism/states\n   {:initial  {::uism/handler route-handler}\n\n    :deferred {::uism/events\n               {:waiting! {::uism/target-state :pending}\n                :route!   {::uism/handler route-handler}\n                :ready!   {::uism/target-state :routed\n                           ::uism/handler      ready-handler}\n                :timeout! {::uism/target-state :failed\n                           ::uism/handler      fail-handler}}}\n\n    :pending  {::uism/events\n               {:waiting! {::uism/target-state :pending}\n                :route!   {::uism/handler route-handler}\n                :ready!   {::uism/target-state :routed\n                           ::uism/handler      ready-handler}\n                :timeout! {::uism/target-state :failed\n                           ::uism/handler      fail-handler}}}\n\n    ;; failed may potentially resolve (just very late), so it must accept ready! events\n    :failed   {::uism/events\n               {:route! {::uism/handler route-handler}\n                :ready! {::uism/target-state :routed\n                         ::uism/handler      ready-handler}}}\n\n    :routed   {::uism/handler route-handler}}})\n\n;; TODO: This algorithm is repeated in more than one place in slightly different forms...refactor it.\n(defn proposed-new-path [this-or-app relative-class-or-instance new-route]\n  (let [app        (comp/any->app this-or-app)\n        state-map  (app/current-state app)\n        router     relative-class-or-instance\n        root-query (comp/get-query router state-map)\n        ast        (eql/query->ast root-query)\n        root       (ast-node-for-route ast new-route)\n        result     (atom [])]\n    (loop [{:keys [component]} root path new-route]\n      (when (and component (router? component))\n        (let [{:keys [target matching-prefix]} (route-target component path)\n              target-ast     (some-> target (comp/get-query state-map) eql/query->ast)\n              prefix-length  (count matching-prefix)\n              remaining-path (vec (drop prefix-length path))\n              segment        (route-segment target)\n              params         (reduce\n                               (fn [p [k v]] (if (keyword? k) (assoc p k v) p))\n                               {}\n                               (map (fn [a b] [a b]) segment matching-prefix))\n              target-ident   (will-enter target app params)]\n          (when (or (not (eql/ident? target-ident)) (nil? (second target-ident)))\n            (log/error \"will-enter for router target\" (comp/component-name target) \"did not return a valid ident. Instead it returned: \" target-ident))\n          (when (and (eql/ident? target-ident)\n                  (not (contains? (some-> target-ident meta) :immediate)))\n            (log/error \"will-enter for router target\" (comp/component-name target) \"did not wrap the ident in route-immediate or route-deferred.\"))\n          (when (vector? target-ident)\n            (swap! result conj (vary-meta target-ident assoc :component target :params params)))\n          (when (seq remaining-path)\n            (recur (ast-node-for-route target-ast remaining-path) remaining-path)))))\n    @result))\n\n(defn signal-router-leaving\n  \"Tell active routers that they are about to leave the screen. Returns false if any of them deny the route change.\"\n  [app-or-comp relative-class-or-instance new-route]\n  (let [new-path   (proposed-new-path app-or-comp relative-class-or-instance new-route)\n        app        (comp/any->app app-or-comp)\n        state-map  (app/current-state app)\n        router     relative-class-or-instance\n        root-query (comp/get-query router state-map)\n        ast        (eql/query->ast root-query)\n        root       (ast-node-for-live-router app ast)\n        to-signal  (atom [])\n        to-cancel  (atom [])\n        _          (loop [{:keys [component children] :as node} root new-path-remaining new-path]\n                     (when (and component (router? component))\n                       (let [new-target    (first new-path-remaining)\n                             router-ident  (comp/get-ident component {})\n                             active-target (get-in state-map (conj router-ident ::current-route))\n                             {:keys [target]} (get-in state-map (conj router-ident ::pending-route))\n                             next-router   (some #(ast-node-for-live-router app %) children)]\n                         (when (eql/ident? target)\n                           (swap! to-cancel conj target))\n                         (when (and (not= new-target active-target) (vector? active-target))\n                           (let [mounted-target-class (reduce (fn [acc {:keys [dispatch-key component]}]\n                                                                (when (= ::current-route dispatch-key)\n                                                                  (reduced component)))\n                                                        nil\n                                                        (some-> component (comp/get-query state-map)\n                                                          eql/query->ast :children))\n                                 mounted-targets      (comp/class->all app mounted-target-class)]\n                             (when (and #?(:cljs goog.DEBUG :clj true) (> (count mounted-targets) 1))\n                               (log/error \"More than one route target on screen of type\" mounted-target-class))\n                             (when (seq mounted-targets)\n                               (swap! to-signal into mounted-targets))))\n                         (when next-router\n                           (recur next-router (rest new-path-remaining))))))\n        components (reverse @to-signal)\n        result     (atom true)]\n    (doseq [c components]\n      (swap! result #(and % (will-leave c (comp/props c)))))\n    (when @result\n      (doseq [t @to-cancel]\n        (let [{:keys [component params]} (some-> t meta)]\n          (route-cancelled component params))))\n    @result))\n\n(defn change-route-relative\n  \"Change the route, starting at the given Fulcro class or instance (scanning for the first router from there).  `new-route` is a vector\n  of string components to pass through to the nearest child router as the new path. The first argument is any live component\n  or the app.  The `timeouts` are as in `change-route`.\n  It is safe to call this from within a mutation.\"\n  ([this-or-app relative-class-or-instance new-route]\n   (change-route-relative this-or-app relative-class-or-instance new-route {}))\n  ([app-or-comp relative-class-or-instance new-route timeouts]\n   (when (and #?(:clj true :cljs goog.DEBUG) (not (seq (proposed-new-path app-or-comp relative-class-or-instance new-route))))\n     (log/error \"Could not find route targets for new-route\" new-route))\n   (if (signal-router-leaving app-or-comp relative-class-or-instance new-route)\n     (let [app        (comp/any->app app-or-comp)\n           state-map  (app/current-state app)\n           router     relative-class-or-instance\n           root-query (comp/get-query router state-map)\n           ast        (eql/query->ast root-query)\n           root       (ast-node-for-route ast new-route)]\n       (loop [{:keys [component]} root path new-route]\n         (when (and component (router? component))\n           (let [{:keys [target matching-prefix]} (route-target component path)\n                 target-ast        (some-> target (comp/get-query state-map) eql/query->ast)\n                 prefix-length     (count matching-prefix)\n                 remaining-path    (vec (drop prefix-length path))\n                 segment           (route-segment target)\n                 params            (reduce\n                                     (fn [p [k v]] (if (keyword? k) (assoc p k v) p))\n                                     {}\n                                     (map (fn [a b] [a b]) segment matching-prefix))\n                 router-ident      (comp/get-ident component {})\n                 router-id         (-> router-ident second)\n                 target-ident      (will-enter target app params)\n                 completing-action (or (some-> target-ident meta :fn) identity)\n                 event-data        (merge\n                                     {:error-timeout 5000 :deferred-timeout 100}\n                                     timeouts\n                                     {:path-segment matching-prefix\n                                      :router       (vary-meta router-ident assoc :component component)\n                                      :target       (vary-meta target-ident assoc :component target :params params)})]\n             (if-not (uism/get-active-state app router-id)\n               (uism/begin! app-or-comp RouterStateMachine router-id\n                 {:router (uism/with-actor-class router-ident component)}\n                 event-data)\n               (uism/trigger! app router-id :route! event-data))\n             (completing-action)\n             (when (seq remaining-path)\n               (recur (ast-node-for-route target-ast remaining-path) remaining-path))))))\n     (log/debug \"Route request cancelled by on-screen target.\"))))\n\n(defn change-route\n  \"Trigger a route change.\n\n  this - The component (or app) that is causing the route change.\n  new-route - A vector of URI components to pass to the router.\n  timeouts - A map of timeouts that affect UI during deferred routes: {:error-timeout ms :deferred-timeout ms}\n\n  The error timeout is how long to wait  (default 5000ms) before showing the error-ui of a route (which must be defined on the\n  router that is having problems).  The deferred-timeout (default 100ms) is how long to wait before showing the loading-ui of\n  a deferred router (to prevent flicker).\n  \"\n  ([this new-route]\n   (change-route this new-route {}))\n  ([this new-route timeouts]\n   (let [app  (comp/any->app this)\n         root (app/root-class app)]\n     (change-route-relative app root new-route timeouts))))\n\n(defn current-route\n  \"Returns the current active route, starting from the relative Fulcro class or instance.\n\n  Any component using this as a basis for rendering will need to add the following to their query to\n  ensure the props of that component change on route changes:\n\n  ```\n  [::uism/asm-id fq-router-kw]\n  ```\n\n  where `fq-router-kw` is a keyword that has the exact namespace and name of the router you're interested in. If you want\n  to just over-render you can use a quoted `_` instead.\n  \"\n  [this-or-app relative-class-or-instance]\n  (let [app        (comp/any->app this-or-app)\n        state-map  (app/current-state app)\n        router     relative-class-or-instance\n        root-query (comp/get-query router state-map)\n        ast        (eql/query->ast root-query)\n        root       (ast-node-for-live-router app ast)\n        result     (atom [])]\n    (loop [{:keys [component] :as node} root]\n      (when (and component (router? component))\n        (let [router-ident (comp/get-ident component {})\n              router-id    (-> router-ident second)\n              sm-env       (uism/state-machine-env state-map nil router-id :none {})\n              path-segment (uism/retrieve sm-env :path-segment)\n              next-router  (some #(ast-node-for-live-router app %) (:children node))]\n          (when (seq path-segment)\n            (swap! result into path-segment))\n          (when next-router\n            (recur next-router)))))\n    @result))\n\n#?(:clj\n   (defn compile-error [env form message]\n     (throw (ana/error (merge env (some-> form meta)) message {}))))\n\n#?(:clj (s/def ::router-targets (s/coll-of symbol? :type vector?)))\n#?(:clj (s/def ::initial-ui list?))\n#?(:clj (s/def ::loading-ui list?))\n#?(:clj (s/def ::failed-ui list?))\n#?(:clj (s/def ::defrouter-options (s/keys :req-un [::router-targets] :opt-un [::initial-ui ::loading-ui ::failed-ui])))\n\n(defn validate-route-targets\n  \"Run a runtime validation on route targets to verify that they at least declare a route-segment that is a vector.\"\n  [router-instance]\n  (doseq [t (get-targets router-instance)\n          :let [segment (route-segment t)\n                valid?  (and\n                          (vector? segment)\n                          (not (empty? segment))\n                          (every? #(or (keyword? %) (string? %)) segment))]]\n    (when-not valid?\n      (log/error \"Route target \"\n        (comp/component-name t)\n        \"of router\"\n        (comp/component-name router-instance)\n        \"does not declare a valid :route-segment. Route segments must be non-empty vector that contain only strings\"\n        \"and keywords\"))))\n\n#?(:clj\n   (defn defrouter* [env router-ns router-sym arglist options body]\n     (when-not (and (vector? arglist) (= 2 (count arglist)))\n       (compile-error env options \"defrouter argument list must have an entry for this and props.\"))\n     (when-not (map? options)\n       (compile-error env options \"defrouter requires a literal map of options.\"))\n     (when-not (s/valid? ::defrouter-options options)\n       (compile-error env options (str \"defrouter options are invalid: \" (s/explain-str ::defrouter-options options))))\n     (let [{:keys [router-targets]} options\n           _                      (when (empty? router-targets)\n                                    (compile-error env options \"defrouter requires at least one router-target\"))\n           id                     (keyword router-ns (name router-sym))\n           query                  (into [::id\n                                         [::uism/asm-id id]\n                                         {::current-route `(comp/get-query ~(first router-targets))}]\n                                    (map-indexed\n                                      (fn [idx s]\n                                        (when (nil? s)\n                                          (compile-error env options \"defrouter target contains nil!\"))\n                                        {(keyword (str \"alt\" idx)) `(comp/get-query ~s)})\n                                      (rest router-targets)))\n           initial-state-map      (into {::id            id\n                                         ::current-route `(comp/get-initial-state ~(first router-targets) ~'params)}\n                                    (map-indexed\n                                      (fn [idx s] [(keyword (str \"alt\" idx)) `(comp/get-initial-state ~s {})])\n                                      (rest router-targets)))\n           ident-method           (apply list `(fn [] [::id ~id]))\n           get-targets-method     (apply list `(fn [~'c] ~(set router-targets)))\n           initial-state-lambda   (apply list `(fn [~'params] ~initial-state-map))\n           states-to-render-route (if (seq body)\n                                    #{:routed :deferred}\n                                    `(constantly true))\n           render-cases           (apply list `(let [~'class (current-route-class ~'this)]\n                                                 (if (~states-to-render-route ~'current-state)\n                                                   (when ~'class\n                                                     (let [~'factory (comp/factory ~'class)]\n                                                       (~'factory (comp/computed ~'current-route (comp/get-computed ~'this)))))\n                                                   (let [~(first arglist) ~'this\n                                                         ~(second arglist) {:pending-path-segment ~'pending-path-segment\n                                                                            :route-props          ~'current-route\n                                                                            :route-factory        (when ~'class (comp/factory ~'class))\n                                                                            :current-state        ~'current-state}]\n                                                     ~@body))))\n           options                (merge\n                                    `{:componentDidMount (fn [this#] (validate-route-targets this#))}\n                                    options\n                                    `{:query         ~query\n                                      :ident         ~ident-method\n                                      :initial-state ~initial-state-lambda})]\n       `(comp/defsc ~router-sym [~'this {::keys [~'id ~'current-route] :as ~'props}]\n          ~options\n          (let [~'current-state (uism/get-active-state ~'this ~id)\n                ~'state-map (comp/component->state-map ~'this)\n                ~'sm-env (uism/state-machine-env ~'state-map nil ~id :fake {})\n                ~'pending-path-segment (uism/retrieve ~'sm-env :pending-path-segment)]\n            ~render-cases)))))\n\n#?(:clj\n   (defmacro defrouter\n     \"Define a router.\n\n     The arglist is `[this props]`, which are just like defsc. The props will contains :current-state and :pending-path-segment.\n\n     The options are:\n\n     `:router-targets` - (REQUIRED) A *vector* of ui components that are router targets. The first one is considered the \\\"default\\\".\n     Other defsc options - (LIMITED) You may not specify query/initial-state/protocols/ident, but you can define things like react\n     lifecycle methods. See defsc.\n\n     The optional body, if defined, will *only* be used if the router is in one of the following states:\n\n     - `:initial` - No route is set.\n     - `:pending` - A deferred route is taking longer than expected (configurable timeout, default 100ms)\n     - `:failed` - A deferred route took longer than can reasonably be expected (configurable timeout, default 5s)\n\n     otherwise the actual active route target will be rendered.\n     \"\n     [router-sym arglist options & body]\n     (defrouter* &env (str (ns-name *ns*)) router-sym arglist options body)))\n\n#?(:clj\n   (s/fdef defrouter\n     :args (s/cat :sym symbol? :arglist vector? :options map? :body (s/* any?))))\n\n#_(defn ssr-initial-state\n    \"(ALPHA) A helper to get initial state database for SSR.\n\n    Returns:\n\n    ```\n    {:db normalized-db\n     :props props-to-render}\n    ```\n\n    IMPORTANT NOTES:\n\n    - `will-enter` for the routes will *not* get a app (since there\n    isn't one).  Be sure your routers will tolerate a nil reconciler.\n    - This has not been well-tested.  It is known to render correct HTML in simple cases, but the initial state\n    may not actually be correct for the starting app with respect to the routers.\n    \"\n    [app-root-class root-router-class route-path]\n    (let [initial-tree (comp/get-initial-state app-root-class {})\n          initial-db   (ssr/build-initial-state initial-tree app-root-class)\n          router-ident (comp/get-ident root-router-class {})\n          instance-id  (second router-ident)\n          {:keys [target matching-prefix]} (route-target root-router-class route-path)\n          target-ident (will-enter target nil nil)          ; Target in this example needs neither\n          params       {::uism/asm-id                instance-id\n                        ::uism/state-machine-id      (::state-machine-id RouterStateMachine)\n                        ::uism/event-data            (merge\n                                                       {:path-segment matching-prefix\n                                                        :router       (vary-meta router-ident assoc\n                                                                        :component root-router-class)\n                                                        :target       (vary-meta target-ident assoc\n                                                                        :component target)})\n                        ::uism/actor->component-name {:router (uism/any->actor-component-registry-key root-router-class)}\n                        ::uism/actor->ident          {:router router-ident}}\n          initial-db   (assoc-in initial-db [::uism/asm-id instance-id] (uism/new-asm params))]\n      {:db    initial-db\n       :props (fdn/db->tree (comp/get-query app-root-class initial-db)\n                initial-db initial-db)}))\n\n(defn all-reachable-routers\n  \"Returns a sequence of all of the routers reachable in the query of the app.\"\n  [state-map component-class]\n  (let [root-query  (comp/get-query component-class state-map)\n        {:keys [children]} (eql/query->ast root-query)\n        get-routers (fn get-routers* [nodes]\n                      (reduce\n                        (fn [acc {:keys [component children]}]\n                          (into (if (router? component)\n                                  (conj acc component)\n                                  acc)\n                            (get-routers* children)))\n                        []\n                        nodes))]\n    (get-routers children)))\n\n\n(defn initialize!\n  \"Initialize the routing system.  This ensures that all routers have state machines in app state.\"\n  [app]\n  (let [state-map (app/current-state app)\n        root      (app/root-class app)\n        routers   (all-reachable-routers state-map root)\n        tx        (mapv (fn [r]\n                          (let [router-ident (comp/get-ident r {})\n                                router-id    (second router-ident)]\n                            (uism/begin {::uism/asm-id           router-id\n                                         ::uism/state-machine-id (::uism/state-machine-id RouterStateMachine)\n                                         ::uism/event-data       {:path-segment []\n                                                                  :router       (vary-meta router-ident assoc :component r)}\n                                         ::uism/actor->ident     {:router (uism/with-actor-class router-ident r)}}))) routers)]\n    (comp/transact! app tx)))\n\n"]}