{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/data_targeting.cljc"],"mappings":"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","names":["cljs.spec.alpha/def-impl","cljs.core/vector?","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl.cljs$core$IFn$_invoke$arity$4","cljs.spec.alpha/cat-impl","cljs.spec.alpha/rep-impl","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.algorithms.data-targeting/multiple-targets","seq73092","self__4718__auto__","cljs.core/seq","targets","cljs.core/with-meta","cljs.core/vec","com.fulcrologic.fulcro.algorithms.data-targeting/prepend-to","target","com.fulcrologic.fulcro.algorithms.data-targeting/append-to","com.fulcrologic.fulcro.algorithms.data-targeting/replace-at","com.fulcrologic.fulcro.algorithms.data-targeting/replacement-target?","t","cljs.core/any?","cljs.core/boolean?","cljs.core/meta","cljs.core/boolean","com.fulcrologic.fulcro.algorithms.data-targeting/prepend-target?","com.fulcrologic.fulcro.algorithms.data-targeting/append-target?","com.fulcrologic.fulcro.algorithms.data-targeting/multiple-targets?","com.fulcrologic.fulcro.algorithms.data-targeting/special-target?","clojure.set.intersection.cljs$core$IFn$_invoke$arity$2","cljs.core/keys","cljs.core/set","cljs.spec.alpha/or-spec-impl","com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","p__73147","vec__73148","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","p1__73141#","G__73151","cljs.core/Keyword","p1__73142#","taoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10","taoensso.timbre/*config*","cljs.core/Delay","seq73144","G__73145","cljs.core/first","cljs.core/next","G__73146","self__4717__auto__","state","ident","named-parameters","cljs.core/map?","actions","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","command","data-path","already-has-ident-at-path?","cljs.core/some","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","cljs.core.update_in.cljs$core$IFn$_invoke$arity$3","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core.update_in.cljs$core$IFn$_invoke$arity$4","cljs.core.fnil.cljs$core$IFn$_invoke$arity$2","cljs.core/conj","path-to-vector","cljs.core/butlast","to-many?","index","cljs.core/last","vector","cljs.core/contains?","cljs.core/assoc-in","G__73161","com.fulcrologic.fulcro.algorithms.data-targeting/process-target","js/Error","G__73162","G__73163","and__4120__auto__","G__73164","state-map","source-path","cljs.core/keyword?","edn-query-language.core/ident?","com.fulcrologic.fulcro.algorithms.data_targeting.process_target.cljs$core$IFn$_invoke$arity$4","remove-source?","item-to-place","cljs.core.get.cljs$core$IFn$_invoke$arity$2","many-idents?","cljs.core/every?","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","s","target-has-many?","v","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.algorithms.data_targeting.integrate_ident_STAR_.cljs$core$IFn$_invoke$arity$variadic"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.data-targeting\n  \"The implementation of processing load/mutation result graph targeting.\"\n  (:require\n    [clojure.spec.alpha :as s]\n    [clojure.set :as set]\n    [ghostwheel.core :as gw :refer [>defn =>]]\n    [taoensso.timbre :as log]\n    [edn-query-language.core :as eql]))\n\n(s/def ::target vector?)\n\n(>defn multiple-targets\n  \"Specifies a target that should place edges in the graph at multiple locations.\n\n  `targets` - Any number of targets.  A target can be a simple path (as a vector), or other\n  special targets like `append-to` and `prepend-to`.\"\n  [& targets]\n  [(s/* ::target) => ::target]\n  (with-meta (vec targets) {::multiple-targets true}))\n\n(>defn prepend-to\n  \"Specifies a to-many target that will preprend an edge to some to-many edge. NOTE: this kind of target will not\n  create duplicates in the target list.\n\n  `target` - A vector (path) in the normalized database of the to-many list of idents.\n  \"\n  [target]\n  [::target => ::target]\n  (with-meta target {::prepend-target true}))\n\n(>defn append-to\n  \"Specifies a to-many target that will append an edge to some to-many edge. NOTE: this kind of target will not\n  create duplicates in the target list.\n\n  `target` - A vector (path) in the normalized database of the to-many list of idents.\"\n  [target]\n  [::target => ::target]\n  (with-meta target {::append-target true}))\n\n(>defn replace-at\n  \"Specifies a target that will replace an edge at some normalized location.\n\n  `target` - A vector (path) in the normalized database. This path can include numbers to target some element\n  of an existing to-many list of idents.\"\n  [target]\n  [::target => ::target]\n  (with-meta target {::replace-target true}))\n\n(>defn replacement-target? [t] [any? => boolean?] (-> t meta ::replace-target boolean))\n(>defn prepend-target? [t] [any? => boolean?] (-> t meta ::prepend-target boolean))\n(>defn append-target? [t] [any? => boolean?] (-> t meta ::append-target boolean))\n(>defn multiple-targets? [t] [any? => boolean?] (-> t meta ::multiple-targets boolean))\n\n(>defn special-target?\n  \"Is the given target special? This means it is not just a plain vector path, but is instead something like\n  an append.\"\n  [target]\n  [any? => boolean?]\n  (boolean (seq (set/intersection (-> target meta keys set) #{::replace-target ::append-target ::prepend-target ::multiple-targets}))))\n\n(>defn integrate-ident*\n  \"Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not place\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element then that element must already exist in the vector.\n\n  NOTE: `ident` does not have to be an ident if you want to place denormalized data.  It can really be anything.\n\n  Returns the updated state map.\"\n  [state ident & named-parameters]\n  [map? any? (s/* (s/or :path ::target :command #{:append :prepend :replace})) => map?]\n  (let [actions (partition 2 named-parameters)]\n    (reduce (fn [state [command data-path]]\n              (let [already-has-ident-at-path? (fn [data-path] (some #(= % ident) (get-in state data-path)))]\n                (case command\n                  :prepend (if (already-has-ident-at-path? data-path)\n                             state\n                             (update-in state data-path #(into [ident] %)))\n                  :append (if (already-has-ident-at-path? data-path)\n                            state\n                            (update-in state data-path (fnil conj []) ident))\n                  :replace (let [path-to-vector (butlast data-path)\n                                 to-many?       (and (seq path-to-vector) (vector? (get-in state path-to-vector)))\n                                 index          (last data-path)\n                                 vector         (get-in state path-to-vector)]\n                             (when-not (vector? data-path) (log/error \"Replacement path must be a vector. You passed: \" data-path))\n                             (when to-many?\n                               (cond\n                                 (not (vector? vector)) (log/error \"Path for replacement must be a vector\")\n                                 (not (number? index)) (log/error \"Path for replacement must end in a vector index\")\n                                 (not (contains? vector index)) (log/error \"Target vector for replacement does not have an item at index \" index)))\n                             (assoc-in state data-path ident))\n                  state)))\n      state actions)))\n\n(>defn process-target\n  \"Process a load target (which can be a multiple-target).\n\n  `state-map` - the state-map\n  `source-path` - A keyword, ident, or app-state path.  If the source path is an ident, then that is what is placed\n     in app state.  If it is a keyword or longer path then the thing at that location in app state is pulled from app state\n     and copied to the target location(s).\n  `target` - The target(s)\n  `remove-source?` - When true the source will be removed from app state once it has been written to the new location.\n\n  Returns an updated state-map with the given changes.\"\n  ([state-map source-path target]\n   [map? (s/or :key keyword? :ident eql/ident? :path vector?) ::target => map?]\n   (process-target state-map source-path target true))\n  ([state-map source-path target remove-source?]\n   [map? (s/or :key keyword? :ident eql/ident? :path vector?) ::target boolean? => map?]\n   (let [item-to-place (cond (eql/ident? source-path) source-path\n                             (keyword? source-path) (get state-map source-path)\n                             :else (get-in state-map source-path))\n         many-idents?  (and (vector? item-to-place)\n                         (every? eql/ident? item-to-place))]\n     (cond\n       (and (eql/ident? source-path)\n         (not (special-target? target))) (-> state-map\n                                           (assoc-in target item-to-place))\n       (not (special-target? target)) (cond->\n                                        (assoc-in state-map target item-to-place)\n                                        remove-source? (dissoc source-path))\n       (multiple-targets? target) (cond-> (reduce (fn [s t] (process-target s source-path t false)) state-map target)\n                                    (and (not (eql/ident? source-path)) remove-source?) (dissoc source-path))\n       (and many-idents? (special-target? target)) (let [state            (if remove-source?\n                                                                            (dissoc state-map source-path)\n                                                                            state-map)\n                                                         target-has-many? (vector? (get-in state target))]\n                                                     (if target-has-many?\n                                                       (cond\n                                                         (prepend-target? target) (update-in state target (fn [v] (vec (concat item-to-place v))))\n                                                         (append-target? target) (update-in state target (fn [v] (vec (concat v item-to-place))))\n                                                         :else state)\n                                                       (assoc-in state target item-to-place)))\n       (special-target? target) (cond-> state-map\n                                  remove-source? (dissoc source-path)\n                                  (prepend-target? target) (integrate-ident* item-to-place :prepend target)\n                                  (append-target? target) (integrate-ident* item-to-place :append target)\n                                  (replacement-target? target) (integrate-ident* item-to-place :replace target))\n       :else state-map))))\n"]}