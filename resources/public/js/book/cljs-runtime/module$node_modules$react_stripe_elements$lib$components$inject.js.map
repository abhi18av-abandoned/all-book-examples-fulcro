{
"version":3,
"file":"module$node_modules$react_stripe_elements$lib$components$inject.js",
"lineCount":17,
"mappings":"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",
"sources":["node_modules/react-stripe-elements/lib/components/inject.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_stripe_elements$lib$components$inject\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Elements = require('./Elements');\n\nvar _Provider = require('./Provider');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// react-redux does a bunch of stuff with pure components / checking if it needs to re-render.\n// not sure if we need to do the same.\nvar inject = function inject(WrappedComponent) {\n  var _class, _temp;\n\n  var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _componentOptions$wit = componentOptions.withRef,\n      withRef = _componentOptions$wit === undefined ? false : _componentOptions$wit;\n\n\n  return _temp = _class = function (_React$Component) {\n    _inherits(_class, _React$Component);\n\n    function _class(props, context) {\n      _classCallCheck(this, _class);\n\n      if (!context || !context.getRegisteredElements) {\n        throw new Error('It looks like you are trying to inject Stripe context outside of an Elements context.\\nPlease be sure the component that calls createSource or createToken is within an <Elements> component.');\n      }\n\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n      _this.parseElementOrData = function (elementOrOptions) {\n        return elementOrOptions && (typeof elementOrOptions === 'undefined' ? 'undefined' : _typeof(elementOrOptions)) === 'object' && elementOrOptions._frame && _typeof(elementOrOptions._frame) === 'object' && elementOrOptions._frame.id && typeof elementOrOptions._frame.id === 'string' && typeof elementOrOptions._componentName === 'string' ? { type: 'element', element: elementOrOptions } : { type: 'data', data: elementOrOptions };\n      };\n\n      _this.findElement = function (filterBy, specifiedType) {\n        var allElements = _this.context.getRegisteredElements();\n        var filteredElements = allElements.filter(function (e) {\n          return e[filterBy];\n        });\n        var matchingElements = specifiedType === 'auto' ? filteredElements : filteredElements.filter(function (e) {\n          return e[filterBy] === specifiedType;\n        });\n\n        if (matchingElements.length === 1) {\n          return matchingElements[0].element;\n        } else if (matchingElements.length > 1) {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        } else {\n          return null;\n        }\n      };\n\n      _this.requireElement = function (filterBy, specifiedType) {\n        var element = _this.findElement(filterBy, specifiedType);\n        if (element) {\n          return element;\n        } else {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        }\n      };\n\n      _this.wrappedCreateToken = function (stripe) {\n        return function () {\n          var tokenTypeOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (tokenTypeOrOptions && (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) === 'object') {\n            // First argument is options; infer the Element and tokenize\n            var opts = tokenTypeOrOptions;\n\n            var tokenType = opts.type,\n                rest = _objectWithoutProperties(opts, ['type']);\n\n            var specifiedType = typeof tokenType === 'string' ? tokenType : 'auto';\n            // Since only options were passed in, a corresponding Element must exist\n            // for the tokenization to succeed -- thus we call requireElement.\n            var element = _this.requireElement('impliedTokenType', specifiedType);\n            return stripe.createToken(element, rest);\n          } else if (typeof tokenTypeOrOptions === 'string') {\n            // First argument is token type; tokenize with token type and options\n            var _tokenType = tokenTypeOrOptions;\n            return stripe.createToken(_tokenType, options);\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createToken. Expected an object, got ' + (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreateSource = function (stripe) {\n        return function () {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            if (typeof options.type !== 'string') {\n              throw new Error('Invalid Source type passed to createSource. Expected string, got ' + _typeof(options.type) + '.');\n            }\n\n            var element = _this.findElement('impliedSourceType', options.type);\n            if (element) {\n              // If an Element exists for the source type, use that to create the\n              // corresponding source.\n              //\n              // NOTE: this prevents users from independently creating sources of\n              // type `foo` if an Element that can create `foo` sources exists in\n              // the current <Elements /> context.\n              return stripe.createSource(element, options);\n            } else {\n              // If no Element exists for the source type, directly create a source.\n              return stripe.createSource(options);\n            }\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createSource. Expected an object, got ' + (typeof options === 'undefined' ? 'undefined' : _typeof(options)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreatePaymentMethod = function (stripe) {\n        return function (paymentMethodType, elementOrData, maybeData) {\n          if (!paymentMethodType || typeof paymentMethodType !== 'string') {\n            throw new Error('Invalid PaymentMethod type passed to createPaymentMethod. Expected a string, got ' + (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) + '.');\n          }\n\n          if (!['card'].includes(paymentMethodType)) {\n            throw new Error('Invalid PaymentMethod type passed to createPaymentMethod. ' + paymentMethodType + ' is not yet supported.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; use passed in Element\n          if (elementOrDataResult.type === 'element') {\n            var _element = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe.createPaymentMethod(paymentMethodType, _element, maybeData);\n            } else {\n              return stripe.createPaymentMethod(paymentMethodType, _element);\n            }\n          }\n\n          // Second argument is data or undefined; infer the Element\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', paymentMethodType);\n\n          if (element) {\n            return data ? stripe.createPaymentMethod(paymentMethodType, element, data) : stripe.createPaymentMethod(paymentMethodType, element);\n          }\n\n          if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType, data);\n          } else if (!data) {\n            throw new Error('Could not find an Element that can be used to create a PaymentMethod of type: ' + paymentMethodType + '.');\n          } else {\n            // If a bad value was passed in for data, throw an error.\n            throw new Error('Invalid data passed to createPaymentMethod. Expected an object, got ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedHandleCardX = function (stripe, method) {\n        return function (clientSecret, elementOrData, maybeData) {\n          if (!clientSecret || typeof clientSecret !== 'string') {\n            // If a bad value was passed in for clientSecret, throw an error.\n            throw new Error('Invalid PaymentIntent client secret passed to handleCardPayment. Expected string, got ' + (typeof clientSecret === 'undefined' ? 'undefined' : _typeof(clientSecret)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; handle with element\n          if (elementOrDataResult.type === 'element') {\n            var _element2 = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe[method](clientSecret, _element2, maybeData);\n            } else {\n              return stripe[method](clientSecret, _element2);\n            }\n          }\n\n          // Second argument is data or undefined; see if we can find a mounted Element\n          // that can create card PaymentMethods\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', 'card');\n\n          if (element) {\n            // If an Element exists that can create card PaymentMethods use it. Otherwise\n            // assume that we must be calling with data only.\n            //\n            // NOTE: this prevents users from using handleCard* with an existing\n            // Source or PaymentMethod if an Element that can create card PaymentMethods\n            // exists in the current <Elements /> context.\n            if (data) {\n              return stripe[method](clientSecret, element, data);\n            } else {\n              return stripe[method](clientSecret, element);\n            }\n          } else if (data) {\n            // if no element exists call handleCard* directly (with data)\n            return stripe[method](clientSecret, data);\n          } else {\n            // if no element exists call handleCard* directly (with only the clientSecret)\n            return stripe[method](clientSecret);\n          }\n        };\n      };\n\n      if (_this.context.tag === 'sync') {\n        _this.state = {\n          stripe: _this.stripeProps(_this.context.stripe)\n        };\n      } else {\n        _this.state = {\n          stripe: null\n        };\n      }\n      return _this;\n    }\n\n    _class.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.context.tag === 'async') {\n        this.context.addStripeLoadListener(function (stripe) {\n          _this2.setState({\n            stripe: _this2.stripeProps(stripe)\n          });\n        });\n      } else {\n        // when 'sync', it's already set in the constructor.\n      }\n    };\n\n    _class.prototype.getWrappedInstance = function getWrappedInstance() {\n      if (!withRef) {\n        throw new Error('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');\n      }\n      return this.wrappedInstance;\n    };\n\n    _class.prototype.stripeProps = function stripeProps(stripe) {\n      return _extends({}, stripe, {\n        // These are the only functions that take elements.\n        createToken: this.wrappedCreateToken(stripe),\n        createSource: this.wrappedCreateSource(stripe),\n        createPaymentMethod: this.wrappedCreatePaymentMethod(stripe),\n        handleCardPayment: this.wrappedHandleCardX(stripe, 'handleCardPayment'),\n        handleCardSetup: this.wrappedHandleCardX(stripe, 'handleCardSetup')\n      });\n    };\n\n    // Finds an Element by the specified type, if one exists.\n    // Throws if multiple Elements match.\n\n\n    // Require that exactly one Element is found for the specified type.\n    // Throws if no Element is found.\n\n\n    // Wraps createToken in order to infer the Element that is being tokenized.\n\n\n    // Wraps createSource in order to infer the Element that is being used for\n    // source creation.\n\n\n    // Wraps createPaymentMethod in order to infer the Element that is being\n    // used for PaymentMethod creation.\n\n\n    _class.prototype.render = function render() {\n      var _this3 = this;\n\n      return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {\n        stripe: this.state.stripe,\n        ref: withRef ? function (c) {\n          _this3.wrappedInstance = c;\n        } : null\n      }));\n    };\n\n    return _class;\n  }(_react2.default.Component), _class.contextTypes = _extends({}, _Provider.providerContextTypes, _Elements.injectContextTypes), _class.displayName = 'InjectStripe(' + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ')', _temp;\n};\n\nexports.default = inject;\n};"],
"names":["shadow$provide","global","require","module","exports","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_extends","assign","target","i","arguments","length","source","key","hasOwnProperty","_typeof","Symbol","iterator","obj","_react2","_react","__esModule","default","_Elements","_Provider","inject","WrappedComponent","_class","_temp","_componentOptions$wit","withRef","componentOptions","undefined","_React$Component","props","context","instance","getRegisteredElements","Error","_this","parseElementOrData","_this.parseElementOrData","elementOrOptions","_frame","id","_componentName","type","element","data","findElement","_this.findElement","filterBy","specifiedType","filteredElements","allElements","filter","e","matchingElements","requireElement","_this.requireElement","wrappedCreateToken","_this.wrappedCreateToken","stripe","tokenTypeOrOptions","options","tokenType","keys","indexOf","createToken","wrappedCreateSource","_this.wrappedCreateSource","createSource","wrappedCreatePaymentMethod","_this.wrappedCreatePaymentMethod","paymentMethodType","elementOrData","maybeData","includes","elementOrDataResult","_element","createPaymentMethod","wrappedHandleCardX","_this.wrappedHandleCardX","method","clientSecret","_element2","state","tag","stripeProps","componentDidMount","_class.prototype.componentDidMount","_this2","addStripeLoadListener","setState","getWrappedInstance","_class.prototype.getWrappedInstance","wrappedInstance","_class.prototype.stripeProps","handleCardPayment","handleCardSetup","render","_class.prototype.render","_this3","createElement","ref","c","Component","contextTypes","providerContextTypes","injectContextTypes","displayName","name"]
}
