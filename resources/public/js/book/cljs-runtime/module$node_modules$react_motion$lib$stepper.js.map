{
"version":3,
"file":"module$node_modules$react_motion$lib$stepper.js",
"lineCount":1,
"mappings":"AAAAA,cAAA,6CAAA,CAAiE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAQzGA,OAAAC,WAAA,CAAqB,CAAA,CACrBD,QAAA,CAAQ,SAAR,CAAA,CAIAE,QAAgB,CAACC,cAAD,CAAiBC,CAAjB,CAAoBC,CAApB,CAAuBC,KAAvB,CAA8BC,CAA9B,CAAiCC,CAAjC,CAAoCC,SAApC,CAA+C,CAelDJ,CAAPK,GAVU,CAACH,CAUXG,EAVgBN,CAUhBM,CAVoBJ,KAUpBI,EAPU,CAACF,CAOXE,CAPeL,CAOfK,EAAeP,cACfQ,eAAAA,CAAOP,CAAPO,CAAWD,CAAXC,CAAkBR,cAEtB,IAAIS,IAAAC,IAAA,CAASH,CAAT,CAAJ,CAAqBD,SAArB,EAAkCG,IAAAC,IAAA,CAASF,cAAT,CAAgBL,KAAhB,CAAlC,CAA2DG,SAA3D,CAGE,MAFAK,YAAA,CAAY,CAAZ,CAEOA,CAFUR,KAEVQ,CADPA,WAAA,CAAY,CAAZ,CACOA,CADU,CACVA,CAAAA,WAGTA,YAAA,CAAY,CAAZ,CAAA,CAAiBH,cACjBG,YAAA,CAAY,CAAZ,CAAA,CAAiBJ,CACjB,OAAOI,YA1BsD,CAF/D,KAAIA,YAAc,CAAC,CAAD,CAAI,CAAJ,CA+BlBf,OAAAC,QAAA,CAAiBA,OAAA,CAAQ,SAAR,CA1CwF;",
"sources":["node_modules/react-motion/lib/stepper.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_motion$lib$stepper\"] = function(global,require,module,exports) {\n\n\n// stepper is used a lot. Saves allocation to return the same array wrapper.\n// This is fine and danger-free against mutations because the callsite\n// immediately destructures it and gets the numbers inside without passing the\n\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = stepper;\n\nvar reusedTuple = [0, 0];\n\nfunction stepper(secondPerFrame, x, v, destX, k, b, precision) {\n  // Spring stiffness, in kg / s^2\n\n  // for animations, destX is really spring length (spring at rest). initial\n  // position is considered as the stretched/compressed position of a spring\n  var Fspring = -k * (x - destX);\n\n  // Damping, in kg / s\n  var Fdamper = -b * v;\n\n  // usually we put mass here, but for animation purposes, specifying mass is a\n  // bit redundant. you could simply adjust k and b accordingly\n  // let a = (Fspring + Fdamper) / mass;\n  var a = Fspring + Fdamper;\n\n  var newV = v + a * secondPerFrame;\n  var newX = x + newV * secondPerFrame;\n\n  if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {\n    reusedTuple[0] = destX;\n    reusedTuple[1] = 0;\n    return reusedTuple;\n  }\n\n  reusedTuple[0] = newX;\n  reusedTuple[1] = newV;\n  return reusedTuple;\n}\n\nmodule.exports = exports[\"default\"];\n// array reference around.\n};"],
"names":["shadow$provide","global","require","module","exports","__esModule","stepper","secondPerFrame","x","v","destX","k","b","precision","newV","newX","Math","abs","reusedTuple"]
}
