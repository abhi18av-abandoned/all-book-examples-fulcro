{
"version":3,
"file":"module$node_modules$victory_core$lib$victory_animation$util.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/victory-core/lib/victory-animation/util.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$victory_core$lib$victory_animation$util\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.victoryInterpolator = exports.interpolateString = exports.interpolateObject = exports.interpolateFunction = exports.interpolateImmediate = exports.isInterpolatable = void 0;\n\nvar _orderBy2 = _interopRequireDefault(require(\"lodash/orderBy\"));\n\nvar _isPlainObject2 = _interopRequireDefault(require(\"lodash/isPlainObject\"));\n\nvar _d3Interpolate = require(\"d3-interpolate\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar isInterpolatable = function (obj) {\n  // d3 turns null into 0 and undefined into NaN, which we don't want.\n  if (obj !== null) {\n    switch (typeof obj) {\n      case \"undefined\":\n        return false;\n\n      case \"number\":\n        // The standard `isNaN` is fine in this case since we already know the\n        // type is number.\n        return !isNaN(obj) && obj !== Number.POSITIVE_INFINITY && obj !== Number.NEGATIVE_INFINITY;\n\n      case \"string\":\n        // d3 might not *actually* be able to interpolate the string, but it\n        // won't cause any issues to let it try.\n        return true;\n\n      case \"boolean\":\n        // d3 turns Booleans into integers, which we don't want. Sure, we could\n        // interpolate from 0 -> 1, but we'd be sending a non-Boolean to\n        // something expecting a Boolean.\n        return false;\n\n      case \"object\":\n        // Don't try to interpolate class instances (except Date or Array).\n        return obj instanceof Date || Array.isArray(obj) || (0, _isPlainObject2.default)(obj);\n\n      case \"function\":\n        // Careful! There may be extra properties on function objects that the\n        // component expects to access - for instance, it may be a `d3.scale()`\n        // function, which has its own methods attached. We don't know if the\n        // component is only going to call the function (in which case it's\n        // safely interpolatable) or if it's going to access special properties\n        // (in which case our function generated from `interpolateFunction` will\n        // most likely cause an error. We could check for enumerable properties\n        // on the function object here to see if it's a \"plain\" function, but\n        // let's just require that components prevent such function props from\n        // being animated in the first place.\n        return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Interpolate immediately to the end value at the given step `when`.\n * Some nicer default behavior might be to jump at the halfway point or return\n * `a` if `t` is 0 (instead of always returning `b`). But d3's default\n * interpolator does not do these things:\n *\n *   d3.interpolate('aaa', 'bbb')(0) === 'bbb'\n *\n * ...and things might get wonky if we don't replicate that behavior.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @param {Number} when - Step value (0 to 1) at which to jump to `b`.\n * @returns {Function} An interpolation function.\n */\n\n\nexports.isInterpolatable = isInterpolatable;\n\nvar interpolateImmediate = function (a, b) {\n  var when = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return function (t) {\n    return t < when ? a : b;\n  };\n};\n/**\n * Interpolate to or from a function. The interpolated value will be a function\n * that calls `a` (if it's a function) and `b` (if it's a function) and calls\n * `d3.interpolate` on the resulting values. Note that our function won't\n * necessarily be called (that's up to the component this eventually gets\n * passed to) - but if it does get called, it will return an appropriately\n * interpolated value.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\n\nexports.interpolateImmediate = interpolateImmediate;\n\nvar interpolateFunction = function (a, b) {\n  return function (t) {\n    if (t >= 1) {\n      return b;\n    }\n\n    return function () {\n      /* eslint-disable no-invalid-this */\n      var aval = typeof a === \"function\" ? a.apply(this, arguments) : a;\n      var bval = typeof b === \"function\" ? b.apply(this, arguments) : b;\n      return (0, _d3Interpolate.interpolate)(aval, bval)(t);\n    };\n  };\n};\n/**\n * Interpolate to or from an object. This method is a modification of the object interpolator in\n * d3-interpolate https://github.com/d3/d3-interpolate/blob/master/src/object.js. This interpolator\n * differs in that it uses our custom interpolators when interpolating the value of each property in\n * an object. This allows the correct interpolation of nested objects, including styles\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\n\nexports.interpolateFunction = interpolateFunction;\n\nvar interpolateObject = function (a, b) {\n  var interpolateTypes = function (x, y) {\n    if (x === y || !isInterpolatable(x) || !isInterpolatable(y)) {\n      return interpolateImmediate(x, y);\n    }\n\n    if (typeof x === \"function\" || typeof y === \"function\") {\n      return interpolateFunction(x, y);\n    }\n\n    if (typeof x === \"object\" && (0, _isPlainObject2.default)(x) || typeof y === \"object\" && (0, _isPlainObject2.default)(y)) {\n      return interpolateObject(x, y);\n    }\n\n    return (0, _d3Interpolate.interpolate)(x, y);\n  }; // When the value is an array, attempt to sort by \"key\" so that animating nodes may be identified\n  // based on \"key\" instead of index\n\n\n  var keyData = function (val) {\n    return Array.isArray(val) ? (0, _orderBy2.default)(val, \"key\") : val;\n  };\n\n  var i = {};\n  var c = {};\n  var k;\n\n  if (a === null || typeof a !== \"object\") {\n    a = {};\n  }\n\n  if (b === null || typeof b !== \"object\") {\n    b = {};\n  }\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateTypes(keyData(a[k]), keyData(b[k]));\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function (t) {\n    for (k in i) {\n      c[k] = i[k](t);\n    }\n\n    return c;\n  };\n};\n\nexports.interpolateObject = interpolateObject;\n\nvar interpolateString = function (a, b) {\n  var format = function (val) {\n    return typeof val === \"string\" ? val.replace(/,/g, \"\") : val;\n  };\n\n  return (0, _d3Interpolate.interpolate)(format(a), format(b));\n};\n/**\n * By default, the list of interpolators used by `d3.interpolate` has a few\n * downsides:\n *\n * - `null` values get turned into 0.\n * - `undefined`, `function`, and some other value types get turned into NaN.\n * - Boolean types get turned into numbers, which probably will be meaningless\n *   to whatever is consuming them.\n * - It tries to interpolate between identical start and end values, doing\n *   unnecessary calculations that sometimes result in floating point rounding\n *   errors.\n *\n * If only the default interpolators are used, `VictoryAnimation` will happily\n * pass down NaN (and other bad) values as props to the wrapped component.\n * The component will then either use the incorrect values or complain that it\n * was passed props of the incorrect type. This custom interpolator is added\n * using the `d3.interpolators` API, and prevents such cases from happening\n * for most values.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function|undefined} An interpolation function, if necessary.\n */\n\n\nexports.interpolateString = interpolateString;\n\nvar victoryInterpolator = function (a, b) {\n  // If the values are strictly equal, or either value is not interpolatable,\n  // just use either the start value `a` or end value `b` at every step, as\n  // there is no reasonable in-between value.\n  if (a === b || !isInterpolatable(a) || !isInterpolatable(b)) {\n    return interpolateImmediate(a, b);\n  }\n\n  if (typeof a === \"function\" || typeof b === \"function\") {\n    return interpolateFunction(a, b);\n  }\n\n  if ((0, _isPlainObject2.default)(a) || (0, _isPlainObject2.default)(b)) {\n    return interpolateObject(a, b);\n  }\n\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return interpolateString(a, b);\n  }\n\n  return (0, _d3Interpolate.interpolate)(a, b);\n};\n\nexports.victoryInterpolator = victoryInterpolator;\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","victoryInterpolator","interpolateString","interpolateObject","interpolateFunction","interpolateImmediate","isInterpolatable","_orderBy2","_isPlainObject2","_d3Interpolate","isNaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","Date","Array","isArray","a","b","when","arguments","length","undefined","t","aval","apply","bval","interpolate","interpolateTypes","x","y","keyData","val","i","c","k","format","replace"]
}
