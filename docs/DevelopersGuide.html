<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Tony Kay">
<link rel="icon" type="image/x-icon" href="assets/favicon.ico">
<title>Fulcro Developers Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Fulcro Developers Guide</h1>
<div class="details">
<span id="author" class="author">Tony Kay</span><br>
<span id="revnumber">version 36,</span>
<span id="revdate">July 12, 2019</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_about_this_book">1. About This Book</a>
<ul class="sectlevel2">
<li><a href="#_common_prefixes_and_namespaces">1.1. Common Prefixes and Namespaces</a></li>
</ul>
</li>
<li><a href="#_fulcro_from_10000_feet">2. Fulcro From 10,000 Feet</a>
<ul class="sectlevel2">
<li><a href="#_but_does_it_have_x">2.1. But Does it Have X?</a></li>
<li><a href="#_server_schema_vs_ui_graph">2.2. Server Schema vs. UI Graph</a></li>
<li><a href="#_queries_eql">2.3. Queries (EQL)</a></li>
<li><a href="#_fulcro_client_database">2.4. Fulcro Client Database</a></li>
<li><a href="#_the_glue_ui_components">2.5. The Glue: UI Components</a></li>
<li><a href="#_the_operational_model">2.6. The Operational Model</a></li>
<li><a href="#_additional_items_of_interest">2.7. Additional Items of Interest</a></li>
</ul>
</li>
<li><a href="#_getting_started">3. Getting Started</a>
<ul class="sectlevel2">
<li><a href="#_install_fulcro_inspect">3.1. Install Fulcro Inspect</a></li>
<li><a href="#_configure_chrome_development_settings">3.2. Configure Chrome Development Settings</a></li>
<li><a href="#_install_supporting_tools">3.3. Install Supporting Tools</a></li>
<li><a href="#_create_your_project">3.4. Create Your Project</a></li>
<li><a href="#_basic_ui_components">3.5. Basic UI Components</a></li>
<li><a href="#_feeding_the_data_tree">3.6. Feeding the Data Tree</a></li>
<li><a href="#_passing_callbacks_and_other_parent_computed_data">3.7. Passing Callbacks and Other Parent-computed Data</a></li>
<li><a href="#_updating_the_data_tree">3.8. Updating the Data Tree</a></li>
<li><a href="#_the_secret_sauce_normalizing_the_database">3.9. The Secret Sauce – Normalizing the Database</a></li>
<li><a href="#_review_so_far">3.10. Review So Far</a></li>
<li><a href="#_using_better_tools">3.11. Using Better Tools</a></li>
<li><a href="#GoingRemote">3.12. Going Remote!</a></li>
<li><a href="#_parsing_queries">3.13. Parsing Queries</a></li>
<li><a href="#_wrapping_up">3.14. Wrapping Up</a></li>
</ul>
</li>
<li><a href="#_components_and_rendering">4. Components and Rendering</a>
<ul class="sectlevel2">
<li><a href="#_html5_element_factories">4.1. HTML5 Element Factories</a></li>
<li><a href="#_the_defsc_macro">4.2. The <code>defsc</code> Macro</a></li>
<li><a href="#_the_component_registry">4.3. The Component Registry</a></li>
<li><a href="#_factories">4.4. Factories</a></li>
<li><a href="#_render_and_props">4.5. Render and Props</a></li>
<li><a href="#_controlled_inputs">4.6. Controlled Inputs</a></li>
<li><a href="#defscForOptimization">4.7. Using <code>defsc</code> for Rendering Optimization</a></li>
<li><a href="#ReactLifecycle">4.8. React Lifecycle Examples</a></li>
<li><a href="#_using_javascript_react_components">4.9. Using Javascript React Components</a></li>
<li><a href="#ColocatedCSS">4.10. Colocated CSS</a></li>
<li><a href="#_component_middleware">4.11. Component Middleware</a></li>
<li><a href="#_component_options">4.12. Component Options</a></li>
<li><a href="#_react_higher_order_components">4.13. React Higher-Order Components</a></li>
</ul>
</li>
<li><a href="#_eqlthe_query_and_mutation_language">5. EQL&#8201;&#8212;&#8201;The Query and Mutation Language</a>
<ul class="sectlevel2">
<li><a href="#_properties">5.1. Properties</a></li>
<li><a href="#_joins">5.2. Joins</a></li>
<li><a href="#Unions">5.3. Unions</a></li>
<li><a href="#Mutations">5.4. Mutations</a></li>
<li><a href="#_parameters">5.5. Parameters</a></li>
<li><a href="#_queries_on_idents">5.6. Queries on Idents</a></li>
<li><a href="#_link_queries">5.7. Link Queries</a></li>
<li><a href="#_a_warning_about_ident_and_link_queries">5.8. A Warning About Ident and Link Queries</a></li>
<li><a href="#_recursive_queries">5.9. Recursive Queries</a></li>
<li><a href="#_the_ast">5.10. The AST</a></li>
</ul>
</li>
<li><a href="#_initial_application_state">6. Initial Application State</a>
<ul class="sectlevel2">
<li><a href="#_adding_initial_state_to_components">6.1. Adding Initial State to Components</a></li>
<li><a href="#_initial_state_and_state_progressions">6.2. Initial State and State Progressions</a></li>
</ul>
</li>
<li><a href="#Normalization">7. Normalization</a>
<ul class="sectlevel2">
<li><a href="#_internals">7.1. Internals</a></li>
<li><a href="#_normalization_initial_state_server_interactions_and_mutations">7.2. Normalization: Initial State, Server Interactions, and Mutations</a></li>
</ul>
</li>
<li><a href="#FullStack">8. Full Stack Operation</a>
<ul class="sectlevel2">
<li><a href="#_general_theory_of_operation">8.1. General Theory of Operation</a></li>
<li><a href="#_react_lifecycle_and_load">8.2. React Lifecycle and Load</a></li>
</ul>
</li>
<li><a href="#MutationsChapter">9. Mutations</a>
<ul class="sectlevel2">
<li><a href="#_stages_of_mutation">9.1. Stages of Mutation</a></li>
<li><a href="#_using_defmutation">9.2. Using <code>defmutation</code></a></li>
<li><a href="#_remote_mutations">9.3. Remote Mutations</a></li>
<li><a href="#ReturnValues">9.4. Server Mutation Return Values</a></li>
<li><a href="#_additional_mutation_topics">9.5. Additional Mutation Topics</a></li>
<li><a href="#_advanced_mutation_topics">9.6. Advanced Mutation Topics</a></li>
</ul>
</li>
<li><a href="#_loads">10. Loads</a>
<ul class="sectlevel2">
<li><a href="#_load_demo_database">10.1. Load Demo Database</a></li>
<li><a href="#DataFetch">10.2. The Data Fetch API: <code>load!</code></a></li>
<li><a href="#_tracking_specific_loads">10.3. Tracking Specific Loads</a></li>
<li><a href="#_initializing_loaded_items">10.4. Initializing Loaded Items</a></li>
<li><a href="#PreMerge">10.5. Pre-Merge</a></li>
<li><a href="#IncrementalLoading">10.6. Incremental Loading</a></li>
<li><a href="#_load_errors">10.7. Load Errors</a></li>
</ul>
</li>
<li><a href="#UserExperience">11. Network Latency, Error Handling, and User Experience</a>
<ul class="sectlevel2">
<li><a href="#_global_network_activity">11.1. Global Network Activity</a></li>
<li><a href="#_pessimistic_operation">11.2. Pessimistic Operation</a></li>
<li><a href="#FullStackErrorHandling">11.3. Full-Stack Error Handling</a></li>
<li><a href="#_aborting_a_request">11.4. Aborting a Request</a></li>
<li><a href="#_progress_updates">11.5. Progress Updates</a></li>
</ul>
</li>
<li><a href="#BuildingAServer">12. Building a Server</a>
<ul class="sectlevel2">
<li><a href="#_use_pathom_to_process_the_eql">12.1. Use Pathom to Process the EQL</a></li>
<li><a href="#_server_configuration">12.2. Server Configuration</a></li>
</ul>
</li>
<li><a href="#_ui_state_machines">13. UI State Machines</a>
<ul class="sectlevel2">
<li><a href="#_aliases">13.1. Aliases</a></li>
<li><a href="#DerivedSM">13.2. Derived State Machines </a></li>
<li><a href="#_plugins">13.3. Plugins</a></li>
<li><a href="#_states">13.4. States</a></li>
<li><a href="#_writing_handlers_and_data_manipulation">13.5. Writing Handlers and Data Manipulation</a></li>
<li><a href="#_using_state_machines_from_the_ui">13.6. Using State Machines from the UI</a></li>
<li><a href="#_mutations_and_state_machines">13.7. Mutations and State Machines</a></li>
<li><a href="#_loads_and_state_machines">13.8. Loads and State Machines</a></li>
<li><a href="#_timer_events">13.9. Timer Events</a></li>
<li><a href="#_sending_events_from_one_state_machine_to_another">13.10. Sending Events from one State Machine to Another</a></li>
<li><a href="#_aborting_loads_and_mutations">13.11. Aborting Loads and Mutations</a></li>
<li><a href="#_full_example">13.12. Full Example</a></li>
<li><a href="#_parting_thoughts">13.13. Parting Thoughts</a></li>
</ul>
</li>
<li><a href="#_dynamic_router">14. Dynamic Router</a>
<ul class="sectlevel2">
<li><a href="#_routers">14.1. Routers</a></li>
<li><a href="#_routing_targets">14.2. Routing Targets</a></li>
<li><a href="#_initial_route">14.3. Initial Route</a></li>
<li><a href="#_route_segments_and_changing_routes">14.4. Route Segments and Changing Routes</a></li>
<li><a href="#_aborting_a_route_change">14.5. Aborting a Route Change</a></li>
<li><a href="#_deferred_routing">14.6. Deferred Routing</a></li>
<li><a href="#_live_router_example">14.7. Live Router Example</a></li>
</ul>
</li>
<li><a href="#_fulcro_and_graphql">15. Fulcro and GraphQL</a></li>
<li><a href="#DynamicQueries">16. Dynamic Queries</a>
<ul class="sectlevel2">
<li><a href="#_query_ids">16.1. Query IDs</a></li>
<li><a href="#_setting_a_query">16.2. Setting a Query</a></li>
<li><a href="#BasicRouter">16.3. A Basic Router</a></li>
<li><a href="#_routing_tree_support">16.4. Routing Tree Support</a></li>
<li><a href="#_using_the_routing_tree">16.5. Using the Routing Tree</a></li>
<li><a href="#_examining_routes_in_ui_and_mutations">16.6. Examining Routes in UI and Mutations</a></li>
<li><a href="#_a_complete_ui_routing_example">16.7. A Complete UI Routing Example</a></li>
<li><a href="#_combining_routing_with_data_management">16.8. Combining Routing with Data Management</a></li>
<li><a href="#_mutations_with_routing">16.9. Mutations with Routing</a></li>
<li><a href="#_html5_routing">16.10. HTML5 Routing</a></li>
</ul>
</li>
<li><a href="#_forms_overview">17. Forms Overview</a></li>
<li><a href="#FormState">18. Form State Support</a>
<ul class="sectlevel2">
<li><a href="#_defining_the_form_component">18.1. Defining the Form Component</a></li>
<li><a href="#_form_configuration">18.2. Form Configuration</a></li>
<li><a href="#_validation">18.3. Validation</a></li>
<li><a href="#_submitting_data">18.4. Submitting Data</a></li>
<li><a href="#_form_state_demos">18.5. Form State Demos</a></li>
<li><a href="#_full_stack_form_demo">18.6. Full Stack Form Demo</a></li>
</ul>
</li>
<li><a href="#_server_side_rendering">19. Server-side Rendering</a>
<ul class="sectlevel2">
<li><a href="#_recommendations">19.1. Recommendations</a></li>
<li><a href="#_overall_structure">19.2. Overall Structure</a></li>
<li><a href="#_a_complete_working_example">19.3. A Complete Working Example</a></li>
<li><a href="#_rendering_via_node_js">19.4. Rendering via Node.js</a></li>
</ul>
</li>
<li><a href="#Networking">20. Client Networking with Fulcro HTTP Remote</a>
<ul class="sectlevel2">
<li><a href="#_creating_a_remote">20.1. Creating a Remote</a></li>
<li><a href="#_request_middleware">20.2. Request Middleware</a></li>
<li><a href="#_client_response_middleware">20.3. Client Response Middleware</a></li>
<li><a href="#_writing_your_own_remote_implementation">20.4. Writing Your Own Remote Implementation</a></li>
<li><a href="#_interfacing_with_alternate_network_protocols">20.5. Interfacing with Alternate Network Protocols</a></li>
</ul>
</li>
<li><a href="#Security">21. Security</a>
<ul class="sectlevel2">
<li><a href="#_low_level_network_security">21.1. Low-Level Network Security</a></li>
</ul>
</li>
<li><a href="#_dev_cards_and_workspaces">22. Dev Cards  and Workspaces</a>
<ul class="sectlevel2">
<li><a href="#_the_project_setup">22.1. The Project Setup</a></li>
<li><a href="#_developing_component_ui">22.2. Developing Component UI</a></li>
<li><a href="#_developing_active_screens">22.3. Developing Active Screens</a></li>
<li><a href="#IFrames">22.4. Using External CSS via IFrames</a></li>
</ul>
</li>
<li><a href="#_support_viewer">23. Support Viewer</a>
<ul class="sectlevel2">
<li><a href="#_sending_a_support_request">23.1. Sending a Support Request</a></li>
<li><a href="#_storing_the_support_request">23.2. Storing the Support Request</a></li>
<li><a href="#_using_the_support_viewer">23.3. Using the Support Viewer</a></li>
<li><a href="#_compressible_transactions">23.4. Compressible Transactions</a></li>
<li><a href="#_demo">23.5. Demo</a></li>
</ul>
</li>
<li><a href="#_code_splitting_modules">24. Code Splitting (modules)</a>
<ul class="sectlevel2">
<li><a href="#_dynamic_routing_and_code_splitting">24.1. Dynamic Routing and Code Splitting</a></li>
<li><a href="#_code_splitting_and_server_side_rendering">24.2. Code Splitting and Server-Side Rendering</a></li>
</ul>
</li>
<li><a href="#Performance">25. Performance</a>
<ul class="sectlevel2">
<li><a href="#_development_compile_times">25.1. Development Compile Times</a></li>
<li><a href="#_callbacks_causing_over_rendering">25.2. Callbacks causing Over-rendering</a></li>
<li><a href="#_poor_query_performance">25.3. Poor Query Performance</a></li>
<li><a href="#_poor_react_performance">25.4. Poor React Performance</a></li>
</ul>
</li>
<li><a href="#_testing">26. Testing</a>
<ul class="sectlevel2">
<li><a href="#_specifications">26.1. Specifications</a></li>
<li><a href="#_behaviors_components_and_assertions">26.2. Behaviors, Components, and Assertions</a></li>
<li><a href="#_exceptions">26.3. Exceptions</a></li>
<li><a href="#_functional_assertions">26.4. Functional Assertions</a></li>
<li><a href="#_mocking_and_spies">26.5. Mocking and Spies</a></li>
</ul>
</li>
<li><a href="#_logging">27. Logging</a>
<ul class="sectlevel2">
<li><a href="#_logging_helpers">27.1. Logging Helpers</a></li>
</ul>
</li>
<li><a href="#_demos">28. Demos</a>
<ul class="sectlevel2">
<li><a href="#_autocomplete">28.1. Autocomplete</a></li>
<li><a href="#_cascading_dropdowns">28.2. Cascading Dropdowns</a></li>
<li><a href="#_loading_due_to_a_ui_event">28.3. Loading due to a UI Event</a></li>
<li><a href="#_paginating_large_lists">28.4. Paginating Large Lists</a></li>
<li><a href="#_ui_query_security">28.5. UI Query Security</a></li>
<li><a href="#_fulcro_with_sql">28.6. Fulcro with SQL</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<style>
@media screen {
  button.inspector {
    float: right;
    right: 0px;
    font-size: 10pt;
    margin-bottom: 6px;
    padding: 6px;
    border-radius: 14px;
  }
}
@media print {
  button.inspector {display: none;}
}
.example {
  clear: both;
  margin-left: auto;
  margin-right: auto;
  position: relative;
  min-height: 400px;
  background-color: lightgray;
  border: 3px groove white;
  border-radius: 5px;
  padding: 5px;
}
.narrow.example { width: 50%; }
.wide.example { width: 80%; }
.short.example { min-height: 200px; }
.tall.example { min-height: 800px; }
</style>

<!-- div for server controls -->
<div id="server-controls"> </div>
</div>
</div>
<div class="sect1">
<h2 id="_about_this_book"><a class="anchor" href="#_about_this_book"></a><a class="link" href="#_about_this_book">1. About This Book</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a stand-alone developer&#8217;s guide for version 3 of Fulcro. It is intended to be be used by beginners and experienced
developers and covers most of the library in detail. Fulcro has a
pretty extensive set of resources on the web tailored to fit your learning style.</p>
</div>
<div class="paragraph">
<p>TODO: Update these links:
There is this book, the docstrings/clojure docs, and even a series of
<a href="https://youtu.be/pLFOVhWsxMM?list=PLVi9lDx-4C_Rwb8LUwW4AdjAu-39PHgEE">YouTube videos</a>,</p>
</div>
<div class="paragraph">
<p>A lot of time and energy went into creating these libraries and materials and providing them free of
charge. If you find them useful please consider
<a href="http://patreon.com/fulcro">contributing to the project</a>.</p>
</div>
<div class="paragraph">
<p>Of course fixes to this guide are also appreciated.</p>
</div>
<div class="paragraph">
<p>This book includes quite a bit of live code. Live code demos with their source
look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="diff"><span class="line delete"><span class="delete">-</span>  (:require [com.fulcrologic.fulcro.mutations :as m :refer [defmutation]]))</span>
<span class="line insert"><span class="insert">+</span>  (:require [com.fulcrologic.fulcro.mutations :as m :refer [defmutation]]</span>
<span class="line insert"><span class="insert">+</span>            [app.mutations :as api]))</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 1. <a id="SampleExample"></a><a href="#SampleExample">Sample Example</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('example-1')">Focus Inspector</button>
<div class="short narrow example" id="example-1"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.example-1</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

(defmutation bump-number [ignored]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state update <span class="symbol">:ui/number</span> <span class="keyword">inc</span>)))

(defsc Root [this {<span class="symbol">:ui/keys</span> [number]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:ui/number</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:ui/number</span> <span class="integer">0</span>}}
  (dom/div
    (dom/h4 <span class="string"><span class="delimiter">&quot;</span><span class="content">This is an example.</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(bump-number {})])}
      <span class="string"><span class="delimiter">&quot;</span><span class="content">You've clicked this button </span><span class="delimiter">&quot;</span></span> number <span class="string"><span class="delimiter">&quot;</span><span class="content"> times.</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Each example includes a "Focus Inspector" button that will cause the Fulcro Inspect
development tools to focus on that example. See <a href="#_install_fulcro_inspect">Install Fulcro Inspect</a> for details on how
to set that up and use it.</p>
</div>
<div class="paragraph">
<p>All of the full stack examples use a mock server embedded in the browser to
simulate any network interaction, but the source that you&#8217;ll read for the application is
identical to what you&#8217;d write for a real server.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
If you&#8217;re viewing this directly from the GitHub repository then you
won&#8217;t see the live code! Use <a href="http://book.fulcrologic.com" class="bare">http://book.fulcrologic.com</a> instead (TODO: publish the new version there, and move
the old one somewhere else).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The mock server has a built-in latency to
simulate a moderately slow network so you can observe behaviors over time. You can
control the length of this latency in milliseconds using the "Server Controls" in the upper-right
corner of this document (if you&#8217;re reading the HTML version with live examples).</p>
</div>
<div class="sect2">
<h3 id="_common_prefixes_and_namespaces"><a class="anchor" href="#_common_prefixes_and_namespaces"></a><a class="link" href="#_common_prefixes_and_namespaces">1.1. Common Prefixes and Namespaces</a></h3>
<div class="paragraph">
<p>Many of the code examples assume you&#8217;ve required the proper namespaces in your
code. This book adopts the following general set of requires and aliases:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">your-ns</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
            [com.fulcrologic.fulcro.application <span class="symbol">:as</span> app]
            [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
            [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
            [com.fulcrologic.fulcro.algorithms.lookup <span class="symbol">:as</span> ah]
            [com.fulcrologic.fulcro.algorithms.misc <span class="symbol">:as</span> util]
            [com.fulcrologic.fulcro.algorithms.merge <span class="symbol">:as</span> <span class="keyword">merge</span>]
            [com.fulcrologic.fulcro.algorithms.data-targeting <span class="symbol">:as</span> targeting]
            [com.fulcrologic.fulcro.algorithms.denormalize <span class="symbol">:as</span> fdn]
            [com.fulcrologic.fulcro.algorithms.normalize <span class="symbol">:as</span> fnorm]
            [com.fulcrologic.fulcro.algorithms.tempid <span class="symbol">:as</span> tempid]
            [com.fulcrologic.fulcro.algorithms.form-state <span class="symbol">:as</span> fs]
            [com.fulcrologic.fulcro.networking.http-remote <span class="symbol">:refer</span> [fulcro-http-remote]]
            [com.fulcrologic.fulcro.ui-state-machines <span class="symbol">:as</span> uism]
            [com.fulcrologic.fulcro.routing.dynamic-router <span class="symbol">:as</span> dr]
            [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r]
            [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>others will be identified as they are used.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fulcro_from_10000_feet"><a class="anchor" href="#_fulcro_from_10000_feet"></a><a class="link" href="#_fulcro_from_10000_feet">2. Fulcro From 10,000 Feet</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>You may be reading this guide hoping for a "quick feel" for why Fulcro might be a good fit for a project.  The
<a href="#_getting_started">Getting Started</a> chapter walks you through the evolution of the model in a way that is intended to
lead to the best understanding, but it is a lot of minutiae to absorb just to get the "big picture" and there
is some chance you&#8217;ll misunderstand where that is going and stop before you get to the good stuff.  This book is
also a rather large work intended to serve as a complete reference guide, so reading it cover to cover may not be
all that desirable for your purposes.</p>
</div>
<div class="paragraph">
<p>If you really want to learn to <strong>use</strong> Fulcro, feel free to skip this chapter and read <a href="#_getting_started">Getting Started</a>; however,
if you&#8217;d rather learn the central ideas and approach of Fulcro this is a good place to start.</p>
</div>
<div class="paragraph">
<p>At its core Fulcro and its companion library <a href="https://wilkerlucio.github.io/pathom"><code>pathom</code></a> are a full-stack
application programming system centered around graph-based UI and data management.</p>
</div>
<div class="paragraph">
<p>The core ideas are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Graphs and Graph Queries are a great way to generalize data models.</p>
</li>
<li>
<p>UI trees are directed graphs that can easily be "fed" from graph queries.</p>
</li>
<li>
<p>User-driven operations are modeled at transactions whose values are simply data (that look like calls).</p>
</li>
<li>
<p>Arbitrary graphs of data from the server need to be normalized (as in database normalization):</p>
<div class="ulist">
<ul>
<li>
<p>UI trees often repeat parts of the graph.</p>
</li>
<li>
<p><strong>Local Manipulation</strong> of data obtained from a graph needs to be de-duped.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Composition is <strong>King</strong>. Seamless composition is a key component of software sustainability.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_but_does_it_have_x"><a class="anchor" href="#_but_does_it_have_x"></a><a class="link" href="#_but_does_it_have_x">2.1. But Does it Have X?</a></h3>
<div class="paragraph">
<p>People have a number of initial "comparative" questions when looking at Fulcro when they&#8217;ve used other libraries.
If you are familiar with other CLJS or JS UI libraries then you may have one of these questions. The most
common ones are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Can I use "hiccup" notation for the DOM?</dt>
<dd>
<p>Yes, you can use <a href="https://github.com/r0man/sablono">Sablono</a>. It should work fine, but it is cljs-only. If you
want <em>support</em>, isomorphic server-side rendering of components, etc.: then use what Fulcro provides.</p>
</dd>
<dt class="hdlist1"><a href="#TheFreakingHiccupQuestionAgain">Why don&#8217;t you use Hiccup by default?</a></dt>
<dd>
<p><a id="TheFreakingHiccupQuestionAgain"></a>
The honest answer is "because". As in: because that&#8217;s the way it was written in Om Next, the predecessor of Fulcro.
I assume David Nolen had his reasons for preferring functions/macros over hiccup and I respected his choice (even though
I did not personally know why it was). Why is Fulcro still using functions? Well, several reasons: Certainly the fact that I already have the code
and there are apps based on it is sufficient, it is no more verbose (if you leverage <code>:refer</code> in <code>:require</code>), it tests
to be as fast as raw React when used optimally, and works with the same API on the client and server for supporting isomorphic rendering
(Hiccup is CLJ only, you have to use Sablono for cljs with React).  Finally, I will note that this question ranks near the
top of my list of "Questions that Don&#8217;t Matter".  If you came to Fulcro looking for DOM notation: move along.</p>
</dd>
<dt class="hdlist1">Where are the "reducers"?</dt>
<dd>
<p>Re-frame and Redux are very popular choices for front-end work, and for good reason.
Fulcro is basically a graph-centric full-stack CQRS-style library.  Mutations are the "commands" that
are queued (like events in a reducer system), but Fulco adds a some very important things:
graph data support, auto-normalization of central database, and a centralized transaction
processing system.</p>
<div class="paragraph">
<p>Fulcro 3&#8217;s <a href="#_ui_state_machines">UI State Machines</a> are usable in exactly the same way as reducer/event systems, but have some
distinct differences (dare I say improvements?): They support an actor model where instances of
UI components are assigned at runtime to play "roles" in the logical flow; they are true state machines
(not just switch/case statements); they use of Fulcro&#8217;s database auto-normalization,
graph query abilities, and abstract mutation system; and their current "state" is stored and normalized
into the same central application database where Fulcro&#8217;s Chrome extension makes them easy to debug.</p>
</div>
</dd>
<dt class="hdlist1">Can I Subscribe to XYZ?</dt>
<dd>
<p>Subscriptions are not a central concern of Fulcro itself, but Fulcro&#8217;s architecture mixed with
the websocket remote make building something that has a "Meteor JS" experience pretty easy to do.
Almost all of the real difficulty in making a subscription system has to do with server-side
management.  You could use a "custom" websocket remote to adapt to any existing GraphQL infrastructure
that supplies such automatic updates.</p>
</dd>
<dt class="hdlist1">What about Server-Side Rendering?</dt>
<dd>
<p>Fulcro is written in CLJC. The intention is to be able to set up and "run" an application in a headless
JS OR Java VM environment and either actively control a DOM or just render "frames" as strings.
The server-side implementation of the DOM methods let you render Fulcro
UI in a Java VM without needing to resort to a js engine at all.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_server_schema_vs_ui_graph"><a class="anchor" href="#_server_schema_vs_ui_graph"></a><a class="link" href="#_server_schema_vs_ui_graph">2.2. Server Schema vs. UI Graph</a></h3>
<div class="paragraph">
<p>Fulcro makes no assumptions nor does it have <strong>any</strong> requirements about back-end databases.  You don&#8217;t even have
to have a back-end:  You can easily simulate one with the browser (like this book does), wrap browser local storage,
or simply not use one at all.</p>
</div>
<div class="paragraph">
<p>If you are using a server database, then normalization and schema on the server is done according to whatever you&#8217;ve designed.
Pathom makes it easy to "reshape" any particular schema or storage technology into a graph that fits your external API and UI needs.</p>
</div>
<div class="paragraph">
<p>This is an important point: it does not <strong>matter</strong> how your back-end database structures the data, as long as <strong>you</strong> know how to
get the data you need when given a "context" that makes sense.</p>
</div>
</div>
<div class="sect2">
<h3 id="_queries_eql"><a class="anchor" href="#_queries_eql"></a><a class="link" href="#_queries_eql">2.3. Queries (EQL)</a></h3>
<div class="paragraph">
<p>Fulcro uses <a href="http://edn-query-language.org">EQL</a> (EDN Query Language), a graph query language similar to
Datomic&#8217;s <a href="https://docs.datomic.com/on-prem/pull.html">pull query notation</a>.</p>
</div>
<div class="paragraph">
<p>A query is a vector (with nesting) that lists the things you want:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">:person/name</span> {<span class="symbol">:person/address</span> [<span class="symbol">:address/street</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above query (when run against a person) asks for that person&#8217;s name, and then indicates a "join" by
using a map whose <strong>key</strong> is the join <em>property</em> on person, and whose <strong>value</strong> is a <em>subquery</em> of things to pull from there.</p>
</div>
<div class="paragraph">
<p>Such a query returns a map that mirrors the query structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>
 <span class="symbol">:person/address</span> {<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">111 Main St.</span><span class="delimiter">&quot;</span></span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and could potentially return to-many results (if the address field were to-many in the database of the server):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>
 <span class="symbol">:person/address</span> [{<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">111 Main St.</span><span class="delimiter">&quot;</span></span>} {<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">345 Center Ave.</span><span class="delimiter">&quot;</span></span>}]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For those coming from SQL this roughly equates to a LEFT JOIN from person to address (where the behind-the-scenes join key
might be converted from <code>:person/address</code> to something like <code>address.person_id</code>). You could implement this with
something crude like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="class">SELECT</span> person.id, person.name, address.id, address.street <span class="keyword">FROM</span> person, address <span class="keyword">WHERE</span> address.id = person.address_id</code></pre>
</div>
</div>
<div class="paragraph">
<p>and walk the table result with a <code>reduce</code> to convert the rows into the graph, but
fortunately, the Pathom library does most of that "lifting" for you and also includes features that can
be used to tune for optimal performance (e.g. fixing n+1 query problems, branch caching, parallel operation, etc.).</p>
</div>
</div>
<div class="sect2">
<h3 id="_fulcro_client_database"><a class="anchor" href="#_fulcro_client_database"></a><a class="link" href="#_fulcro_client_database">2.4. Fulcro Client Database</a></h3>
<div class="paragraph">
<p>Fulcro uses a single, central, normalized graph database.  Any time data is created or read into a Fulcro application it can be
auto-normalized into this database, and
queries from the UI components can easily be fulfilled from it.</p>
</div>
<div class="paragraph">
<p>The format of this database is <strong>trivial</strong> (and very fast as a result):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nodes of the graph have some distinct ID (for their type, at least)</p>
</li>
<li>
<p>Nodes are stored in "tables".</p>
</li>
<li>
<p>Edges are represented as vectors: <code>[TABLE ID]</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We use the term <em>*ident*</em> to mean "A tuple of table and ID that uniquely identify a graph node in the database."</p>
</div>
<div class="paragraph">
<p>The graph of data like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/address</span> {<span class="symbol">:address/id</span> <span class="integer">42</span> <span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">111 Main St.</span><span class="delimiter">&quot;</span></span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be turned into this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="clojure"><span class="comment">;; TABLE     ID   ENTITY                                           POINTER TO ADDRESS TABLE</span>
{ <span class="symbol">:PERSON</span>  { <span class="integer">1</span>    {<span class="symbol">:person/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/address</span> [<span class="symbol">:ADDRESS</span> <span class="integer">42</span>]}}
  <span class="symbol">:ADDRESS</span> { <span class="integer">42</span>   {<span class="symbol">:address/id</span> <span class="integer">42</span> <span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">111 Main St.</span><span class="delimiter">&quot;</span></span>}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This format supports any arbitrary graph, to-many (a vector of idents) and to-one (single ident) relations, any possible
property value type (though you should generally make sure they&#8217;re serializable for network transfer), and is simple to manipulate
(i.e. an <code>assoc-in</code> with a path length of 2 or 3 gets you to anything).</p>
</div>
<div class="paragraph">
<p>This leads to the following useful results:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Everything is de-duped for you. No need to worry that composing in some "alternate view" of pre-existing data will
cause two out of sync copies to exist.</p>
</li>
<li>
<p>Caching is a centralized concern. Your normalized client database is the only possible place for the data, and
each node of the graph has exactly <strong>one place</strong> to live (even if a query has two views of of the same thing on different branches
of some complex graph query result, which is common when composing related components onto a UI).</p>
</li>
<li>
<p>Subgraph reasoning is trivial: You can (re)load <strong>any portion</strong> of the graph at <strong>any time</strong>.</p>
<div class="ulist">
<ul>
<li>
<p>A UI query, server load, or transfer of some portion of the graph can be started from any node.</p>
</li>
<li>
<p>Manipulation of some node affects all paths through that node.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Meteor-style subscription models need not be an internal part of the library.  If you have a database that can tell
you when data changes then you can either re-run your graph query to pull those changes or merge in new graph of data
that arrives from some arbitrary websocket push.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You may be asking "by what magic can Fulcro do this?". The answer is simple: by co-locating the node/edge
descriptions with the components of your UI!</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_glue_ui_components"><a class="anchor" href="#_the_glue_ui_components"></a><a class="link" href="#_the_glue_ui_components">2.5. The Glue: UI Components</a></h3>
<div class="paragraph">
<p>We also are writing SPAs where what we care about is the UI we end up with.  Pathom can shape our server graph to
match whatever we need on the client, and this frees us to design our UI as we see fit.</p>
</div>
<div class="paragraph">
<p>Components can therefore represent the desired UI <strong>nodes</strong> of a graph, and the EQL joins can represent
the edges. Auto-normalization just requires one more detail: a way to manufacture the correct <em>ident</em> for
a given node in order to make the <strong>edge</strong>.</p>
</div>
<div class="paragraph">
<p>This is functional programming, so of course the answer is a function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">person-ident</span> [props] [<span class="symbol">:person/id</span> (<span class="symbol">:person/id</span> props)])</code></pre>
</div>
</div>
<div class="paragraph">
<p>The convention for our table names (for ease of use with Pathom) is to use the name of the <em>ID field of the entity</em>
(e.g. <code>:person/id</code>) as the table name for those types of entities.</p>
</div>
<div class="paragraph">
<p>Thus, the "ident" of this person:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(person-ident {<span class="symbol">:person/id</span> <span class="integer">22</span> <span class="keyword">..</span><span class="keyword">.</span>})
<span class="comment">; =&gt; [:person/id 22]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, this function needs to be associated with the <code>Person</code> component for Fulcro to know how to use it. That
looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this props]
 {<span class="symbol">:query</span> [<span class="symbol">:person/id</span> <span class="symbol">:person/name</span>]  <span class="comment">; </span><b class="conum">(1)</b>
  <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] [<span class="symbol">:person/id</span> (<span class="symbol">:person/id</span> props)])} <span class="comment">; </span><b class="conum">(2)</b>
 (dom/div                 <span class="comment">; </span><b class="conum">(3)</b>
   (<span class="symbol">:person/name</span> props)))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The co-located query: What should we ask the server for when we&#8217;re asking for person data?</p>
</li>
<li>
<p>The ident: Given the props for some particular person, what is the 2-tuple that describes the table and ID for it?</p>
</li>
<li>
<p>What does this component look like when rendered?</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_putting_things_in_the_database"><a class="anchor" href="#_putting_things_in_the_database"></a><a class="link" href="#_putting_things_in_the_database">2.5.1. Putting Things in the Database</a></h4>
<div class="paragraph">
<p>Of course, the most interesting aspect of the operation now is "how do I get data into the system?".</p>
</div>
<div class="paragraph">
<p>Well, the query and normalization constructs are on the component, so you simply use the component with various
APIs.</p>
</div>
<div class="paragraph">
<p>For example, to put some arbitrary graph of data you generated by hand into the database you could
use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(merge/merge-component! app Person {<span class="symbol">:person/id</span> <span class="integer">11</span> <span class="keyword">..</span><span class="keyword">.</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>which inserts this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/id</span> {<span class="integer">11</span> {<span class="symbol">:person/id</span> <span class="integer">11</span> <span class="keyword">..</span><span class="keyword">.</span>}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To put that same data into the database and add an "edge" somewhere else in the graph you could do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(merge/merge-component! app Person {<span class="symbol">:person/id</span> <span class="integer">11</span> <span class="keyword">..</span><span class="keyword">.</span>} <span class="symbol">:append</span> [<span class="symbol">:list/id</span> <span class="symbol">:friends</span> <span class="symbol">:list/people</span>])</code></pre>
</div>
</div>
<div class="paragraph">
<p>which would add this to the graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;;                  append implies to-many. i.e. a vector of idents</span>
{<span class="symbol">:list/id</span> {<span class="symbol">:friends</span> {<span class="symbol">:list/people</span> [<span class="keyword">..</span><span class="keyword">.</span> [<span class="symbol">:person/id</span> <span class="integer">11</span>]] <span class="symbol">:list/id</span> <span class="symbol">:friends</span> <span class="keyword">..</span><span class="keyword">.</span>}}
 <span class="symbol">:person/id</span> {<span class="integer">11</span> {<span class="symbol">:person/id</span> <span class="integer">11</span> <span class="keyword">..</span><span class="keyword">.</span>}}}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_loading"><a class="anchor" href="#_loading"></a><a class="link" href="#_loading">Loading</a></h5>
<div class="paragraph">
<p>Loading is just as trivial and uses the same mechanisms. Loading a particular person from the server might look
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load app [<span class="symbol">:person/id</span> <span class="integer">22</span>] Person)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_nested_things"><a class="anchor" href="#_nested_things"></a><a class="link" href="#_nested_things">Nested Things</a></h5>
<div class="paragraph">
<p>Of course components are typically nested, and all of this composes with elegance. Say your person had some
addresses that you modelled on a sub-component. If you compose those together everything else just falls into place:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Address [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:address/id</span> <span class="symbol">:address/street</span>]
   <span class="symbol">:ident</span> <span class="symbol">:address/id</span>} <span class="comment">; shorthand notation for the most common case: the table name and id key are the same keyword</span>
  <span class="keyword">..</span><span class="keyword">.</span>)

(defsc Person [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:person/id</span> <span class="symbol">:person/name</span> {<span class="symbol">:person/address</span> (comp/get-query Address)}]
   <span class="symbol">:ident</span> <span class="symbol">:person/id</span>}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The using load or merge against such a component</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(merge-component! app Person {<span class="symbol">:person/id</span> <span class="integer">1</span> <span class="symbol">:person/address</span> {<span class="symbol">:address/id</span> <span class="integer">42</span> <span class="keyword">..</span><span class="keyword">.</span>}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>will merge and normalize the entire (sub)graph.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_operational_model"><a class="anchor" href="#_the_operational_model"></a><a class="link" href="#_the_operational_model">2.6. The Operational Model</a></h3>
<div class="paragraph">
<p>During operation you will need to make things happen.</p>
</div>
<div class="sect3">
<h4 id="_mutations"><a class="anchor" href="#_mutations"></a><a class="link" href="#_mutations">2.6.1. Mutations</a></h4>
<div class="paragraph">
<p>Mutations are a first-class higher-order citizen of Fulcro, and encode all of the possible interactions that your UI might
need to have with the local graph database and any remote servers. Mutations are similar to specific "handler cases" of
reducers in Redux, but are more akin to the "request" of a CQRS system in that they are serialized into a
network-compatible form so that a single operation can be abstractly communicated to both the local logic and
remote server(s) without having to deal with the low-level details.</p>
</div>
<div class="paragraph">
<p>The UI-layer need know nothing about these details because it simply submits transactions that look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this [(add-person {<span class="symbol">:name</span> <span class="keyword">name</span>})])</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>add-person</code> in this case is not a function, but instead a <strong>mutation</strong>.  If you call <code>add-person</code> as a function,
it simply returns the expression as namespace-resolved CLJ(S) data (a list containing a fully-qualified symbol and
the (evaluated) parameters):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">user=&gt; (<span class="keyword">def</span> <span class="function">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Tony</span><span class="delimiter">&quot;</span></span>)
user=&gt; (add-person {<span class="symbol">:name</span> <span class="keyword">name</span>})
<span class="comment">;;=&gt; (ns.of.mutation/add-person {:name &quot;Tony&quot;})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an important point. You can also write these with Clojure quoting (which makes it even
more obvious that you&#8217;re not calling something in the UI):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this `[(add-person ~{<span class="symbol">:name</span> <span class="keyword">name</span>})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>The core point is that the UI submits an abstract bit of data to Fulcro&#8217;s transaction system. The UI doesn&#8217;t usually
directly manipulate anything to do with the database, networking, or any other async APIs.</p>
</div>
<div class="paragraph">
<p>Mutations are written as separate code units using <code>defmutation</code>, which has a notation somewhere between <code>defn</code> and
<code>defrecord</code> with a protocol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation add-person [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (<span class="keyword">rest</span> [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (ok-action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (error-action [env] <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>where each "section" represents how that particular mutation interacts with the world around it.  The <code>action</code> section
describes what happens <strong>locally</strong> and <strong>optimistically</strong> to the client database before any networking. This is the main place
where you manipulate the graph database (via <code>swap!</code>/<code>merge</code>/etc. on it).</p>
</div>
<div class="paragraph">
<p>The <code>remote</code> sections (which is any section not ending in <code>-action</code>) describe how that mutation should interact
with some particular server (you name them, and <code>remote</code> is the default name). Remotes are defined at a top-level of
the application so that networking code is not mixed into the mutations at all. Remotes usually just return <code>true</code>
to indicate that the mutation should be forwarded on to the server it represents (unchanged), but they can also
make decisions based on state and even "rewrite" the transaction that will flow over the network.</p>
</div>
<div class="paragraph">
<p>Other <code>*-action</code> sections have to do with handling network results as they occur.</p>
</div>
<div class="paragraph">
<p>Thus a simple UI call can turn into a combination of optimistic actions, remote interactions, etc.</p>
</div>
<div class="paragraph">
<p>Mutations are allowed to submit new transactions themselves, so sections like <code>ok-action</code> can check results of
remote interactions and then decide what to do, if anything, next.</p>
</div>
<div class="paragraph">
<p>Mutations, as in GraphQL, can return graph results. Fulcro, of course, can auto-merge those into the client database.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ui_refresh"><a class="anchor" href="#_ui_refresh"></a><a class="link" href="#_ui_refresh">2.6.2. UI Refresh</a></h4>
<div class="paragraph">
<p>Fulcro manages UI updates by targeting refreshes according to what actually changes (the rendering optimizations are
even pluggable in Fulcro 3), and it turns out the the normalized database makes this all very fast to calculate.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a quick overview of how (one method) of these optimizations work:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each component has a <code>shouldComponentUpdate</code> that checks to see if the props have actually changed.  If a component
is asked to "double render" or render without changed props, then it will short-circuit (e.g. it is a PureComponent). Checking
this fact in CLJS is <strong>very very</strong> fast, since we use immutable data structures where reference comparisons are enough to
ensure two things are identical.</p>
</li>
<li>
<p>Fulcro keeps indexes of <strong>mounted</strong> components by their <strong>idents</strong>.  Thus, at any given time it knows exactly which
on-screen components "represent" something like <code>[:person/id 1]</code>.  It keeps these up to date via hooks on React&#8217;s lifecycle.</p>
</li>
<li>
<p>At certain points in processing (e.g. after any optimistic action in a mutation or the arrival of a network result)
a refresh is scheduled via <code>js/requestAnimationFrame</code>.</p>
</li>
<li>
<p>AFTER every render, Fulcro records a snapshot of what the state database looked like. This is cheap because
of immutable data and structural sharing (e.g. ns time-scale&#8230;&#8203;copy a single 64-bit reference).</p>
</li>
<li>
<p>The ident-optimized render does the following:</p>
</li>
<li>
<p>It reads all of the "mounted component" idents from its internal indexes.  This is the list of "data that matters" to
things on the screen.</p>
</li>
<li>
<p>If finds the "component to refresh" by checking to see if the table entries at these idents are
<strong>identical</strong> (reference compare) to the last rendered version.  It can then translate a "change table entry" into
a set of components using the indexes.  Typically only 1-2 components will be found. This stage typically takes
under a millisecond.</p>
</li>
<li>
<p>For all components that need a refresh: It runs those component&#8217;s queries to get new props and "tunnels" those
new props to the components (via a hidden property in component-local state (e.g. React <code>setState</code>)).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, a form with 50 fields on-screen will do roughly 50 64-bit compares (to find stale data), run 1-2 queries against
the state database targeted at the affected components, and call React <code>setState</code> a couple of times.</p>
</div>
<div class="paragraph">
<p>The alternate renderer (keyframe) just does a root refresh every time and relies on <code>shouldComponentUpdate</code>.  It is
actually quite fast as well, since the query engine in Fulcro is pretty highly tuned to be fast, and CLJS
implementations of <code>shouldComponentUpdate</code> are equally impressive.</p>
</div>
<div class="paragraph">
<p>Fulcro 2 and earlier leveraged "follow-on reads". A concept invented by Om Next where you named the data that changed
during a mutation (e.g. :person/name).  It would then leverage indexes to find which components queried that property,
then look up which on-screen elements had that component type.  It&#8217;s still a potential "alternate" optimization strategy, but
it suffered from a few problems:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It was a manual process, so it was easy to forget to "tell it" what changed.</p>
</li>
<li>
<p>It was harder to understand (fully automatic is hard to beat), especially to new users.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All of the required indexes still exist, so it would not be hard to "replicate" this style of refresh optimization. Another
possible future expansion would be to re-purpose "follow-on reads" as "refresh only this" (tell the underlying scanner not
to scan anything else).  This could be useful when doing rapid UI interactions where you want to eliminate as much
processing as possible in-between frames.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_additional_items_of_interest"><a class="anchor" href="#_additional_items_of_interest"></a><a class="link" href="#_additional_items_of_interest">2.7. Additional Items of Interest</a></h3>
<div class="paragraph">
<p>The prior sections describe the core points of Fulcro&#8217;s architecture.  Data flows in and out via graph queries
and mutations that can easily manipulate a local normalized graph database in a unified way.  Remote interactions
are managed by mutation declarations and all side-effecting and asynchrony is isolated from the UI layer by a
CQRS-style transactional semantic. Fulcro leverages the idents, immutable data structures, co-located queries,
and other tricks to optimize refresh.</p>
</div>
<div class="paragraph">
<p>Here are some additional interesting things that fall out of this model "for free":</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initial application state can also be co-located as a superb optimization for "getting things going".</p>
</li>
<li>
<p>The queries can be used to "traverse" the declarative UI graph. Some places where this has been used to good effect:</p>
<div class="ulist">
<ul>
<li>
<p>Error checking: The <code>defsc</code> macro leverages to co-located query to check things like you props destructuring and
initial state to warn you when you&#8217;ve got a typo or have forgotten something.</p>
</li>
<li>
<p>Nested forms can "discover" children using the query and leverage that to calculate diffs for server interactions.</p>
</li>
<li>
<p>UI screen routers can discover nested routers allowing UI sub-module composition for things like
HTML 5 routing without explicit declaration.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Debugging is a relatively simple matter of looking at a component&#8217;s current state, which is always in a well-defined location
(and easily visible in Fulcro Inspect, a Chrome extension).</p>
</li>
<li>
<p>History traversal is trivial. All application state is just a single immutable map. Saving snapshots over time is all it takes
to be able to "view" the app as it existed at some prior point in time.</p>
</li>
<li>
<p>Snapshotting an application state for re-use during development.  Fulcro Inspect can take a picture of app state and
save it in browser local storage for later restoration. This allows you to "jump to" some application state that you
use a lot during development (e.g. jump to screen 2, with a partially filled form read for submit).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, a more recent addition to the library has proven to be extremely useful: <a href="#_ui_state_machines">UI State Machines</a>.</p>
</div>
<div class="paragraph">
<p>Most UIs end up with a mess of logic spread out in ways that are hard to reason about. Look no further than any "login" module of
an application.  Are you logged in? Are we checking the server to see if our session is valid?  Should I show a "wait" indicator?</p>
</div>
<div class="paragraph">
<p>We&#8217;ve known for years that state machines are a great way to manage this kind of complexity, but they are traditionally
a bit of work to integrate into any give "UI library".</p>
</div>
<div class="paragraph">
<p>Fulcro&#8217;s central normalized database and mutation model made an internal version of state machines a very good match. Not
only is it easy to define them, the model makes them reusable: that is to say you can indicate which UI components
serve roles within the machine, leading to things like CRUD state machines can manage the interactions (edit, list, save, reset,
cancel, etc.) for most of the entities in a form system.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started"><a class="anchor" href="#_getting_started"></a><a class="link" href="#_getting_started">3. Getting Started</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter takes you through a step-by-step guide of how to go from nothing to a full-stack basic application.
Concepts are introduced as we go, and given a very cursory definition in the interest of concision. Once you&#8217;ve got
the general idea you can use other materials to refine your understanding.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
This document assumes you&#8217;re working with Fulcro 3.x and above.  Please see older versions of the Developer&#8217;s
Guide if you&#8217;re working with an older version. (TODO: Link to old version)
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_install_fulcro_inspect"><a class="anchor" href="#_install_fulcro_inspect"></a><a class="link" href="#_install_fulcro_inspect">3.1. Install Fulcro Inspect</a></h3>
<div class="paragraph">
<p>You should use Chrome for development because we have a developer tool called Fulcro Inspect that is available
from the Chrome store for free.  There are also devtools that are installed via preloads which will autoformat
EDN that is sent via <code>console.log</code>.  When properly configured, these tools will let you view the internal state of your
Fulcro application, the local and remote transaction history, save "snapshots" of state so you can quickly retry a
UI flow by hitting a "reset" button, "scroll" over state history and watch the UI change, run queries (with autocomplete
if you&#8217;re using Pathom) against your EQL server, and even (via binaryage devtools) source-level debug your Fulcro application in CLJS with
stack frame analysis and proper clojure names for things!  These tools will save you countless hours of frustration.</p>
</div>
<div class="paragraph">
<p>Fulcro Inspect is a free extension for Chrome, and Binaryage devtools is a library that can be injected via a preload
(which shadow-cljs does for you if it is in your dependencies).</p>
</div>
<div class="paragraph">
<p>ALl of the examples in the book have a "Focus Inspector" button. If you open Chrome devtools, choose the Fulcro Inspect
tab, and then press that button you will focus the inspector on that example so you can see its database. The first
example in this book looks like this when you do that:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Using Inspect on the Book</div>
<div class="content">
<div class="imageblock">
<div class="content">
<img src="assets/img/inspect-open.png" alt="inspect open">
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configure_chrome_development_settings"><a class="anchor" href="#_configure_chrome_development_settings"></a><a class="link" href="#_configure_chrome_development_settings">3.2. Configure Chrome Development Settings</a></h3>
<div class="paragraph">
<p>You should open the Chrome developer tools (e.g. console and such).  Edit the
<a href="https://developers.google.com/web/tools/chrome-devtools/customize">developer tool settings</a> and change:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Under "Console": "Enable Custom Formatters"</p>
</li>
<li>
<p>Under "Network": "Disable Cache (while devtools is open)"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and always keep devtools open when you&#8217;re working on your apps.  This ensures you&#8217;ll not be confused by caching issues
and will be able to see clojure data structures as Clojure, and not low-level js objects.</p>
</div>
</div>
<div class="sect2">
<h3 id="_install_supporting_tools"><a class="anchor" href="#_install_supporting_tools"></a><a class="link" href="#_install_supporting_tools">3.3. Install Supporting Tools</a></h3>
<div class="paragraph">
<p>You&#8217;ll normally want to build a real application based on the Fulcro template (TODO, in progress). It contains a lot
of boilerplate on things like server configuration, CSRF, testing, better error message formatting, and so on.
This can save you quite a bit of setup and development time.</p>
</div>
<div class="paragraph">
<p>For this chapter we&#8217;re going to start from literally nothing.  These instructions should work with any UNIX-like (e.g.
OSX or Linux) system.  I do not use Windows, so your mileage may vary if you&#8217;re on that platform.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Install a <a href="https://clojure.org/guides/getting_started">Java SE Development Kit (JDK)</a>.
You&#8217;ll have an easier time if you use an older version: 8.  OpenJDK or the official one is fine.</p>
</li>
<li>
<p>Install <a href="https://clojure.org/guides/getting_started">Clojure CLI Tools</a></p>
</li>
<li>
<p>Install <a href="https://nodejs.org/en/">Node and npm</a>: The shadow-cljs compiler uses node for all js dependencies.</p>
</li>
<li>
<p>Optional, but recommended: Install IntelliJ CE and the Cursive plugin. There are free versions of both for
non-commercial use. Any programming editor will do, but if you&#8217;re doing anything large I recommend this
(or Emacs/Spacemacs if (and only if) you already use it).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following commands should work from your command line (the <code>$</code> is the command prompt):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ clj
Clojure 1.10.0
user=&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(hit CTRL-D or CTRL-C to exit)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ java -version
java version &quot;1.8.0_162&quot;
Java(TM) SE Runtime Environment (build 1.8.0_162-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</code></pre>
</div>
</div>
<div class="paragraph">
<p>your version may be different, but it should be 1.8.x.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ npm list
/your/directory
└── (empty)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any of these fail, diagnose your installation of those tools before continuing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_create_your_project"><a class="anchor" href="#_create_your_project"></a><a class="link" href="#_create_your_project">3.4. Create Your Project</a></h3>
<div class="paragraph">
<p>Create a directory and set up a basic node project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ mkdir app
$ cd app
$ mkdir -p src/main src/dev resources/public
$ npm init
... answer the questions or just take defaults ...
$ npm install shadow-cljs react react-dom --save</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_clojure_dependencies"><a class="anchor" href="#_clojure_dependencies"></a><a class="link" href="#_clojure_dependencies">3.4.1. Clojure Dependencies</a></h4>
<div class="paragraph">
<p>Create a <code>deps.edn</code> file with this content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:paths</span>   [<span class="string"><span class="delimiter">&quot;</span><span class="content">src/main</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">resources</span><span class="delimiter">&quot;</span></span>]
 <span class="symbol">:deps</span>    {org.clojure/clojure    {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1.10.1</span><span class="delimiter">&quot;</span></span>}
           com.fulcrologic/fulcro {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">3.0.0-alpha-18</span><span class="delimiter">&quot;</span></span>}}

 <span class="symbol">:aliases</span> {<span class="symbol">:dev</span> {<span class="symbol">:extra-paths</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">src/dev</span><span class="delimiter">&quot;</span></span>]
                 <span class="symbol">:extra-deps</span>  {org.clojure/clojurescript   {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1.10.520</span><span class="delimiter">&quot;</span></span>}
                               thheller/shadow-cljs        {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">2.8.40</span><span class="delimiter">&quot;</span></span>}
                               binaryage/devtools          {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">0.9.10</span><span class="delimiter">&quot;</span></span>}}}}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_shadow_cljs_compiler_configuration"><a class="anchor" href="#_shadow_cljs_compiler_configuration"></a><a class="link" href="#_shadow_cljs_compiler_configuration">3.4.2. <a href="https://shadow-cljs.github.io/docs/UsersGuide.html">Shadow-cljs</a> Compiler Configuration</a></h4>
<div class="paragraph">
<p>And a <code>shadow-cljs.edn</code> file that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:deps</span>     {<span class="symbol">:aliases</span> [<span class="symbol">:dev</span>]}
 <span class="symbol">:dev-http</span> {<span class="integer">8000</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:public</span><span class="delimiter">&quot;</span></span>}
 <span class="symbol">:builds</span>   {<span class="symbol">:main</span> {<span class="symbol">:target</span>     <span class="symbol">:browser</span>
                   <span class="symbol">:output-dir</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">resources/public/js/main</span><span class="delimiter">&quot;</span></span>
                   <span class="symbol">:asset-path</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/js/main</span><span class="delimiter">&quot;</span></span>
                   <span class="symbol">:modules</span>    {<span class="symbol">:main</span> {<span class="symbol">:init-fn</span> app.client/init
                                       <span class="symbol">:entries</span> [app.client]}}
                   <span class="symbol">:devtools</span>   {<span class="symbol">:after-load</span> app.client/refresh
                                <span class="symbol">:preloads</span>   [com.fulcrologic.fulcro.inspect.preload]}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>init-fn</code> and <code>after-load</code> options give you a place to put code that will set up an application on load, and
trigger UI refreshes on hot code reload.  We&#8217;ll put those functions in the source in a moment.</p>
</div>
<div class="paragraph">
<p>The top-level <code>dev-http</code> server will cause shadow to start a dev web server on port 8080 that serves the files
from our <code>resources/public</code> directory (<code>resources</code> is on our classpath via <code>:paths</code> in <code>deps.edn</code>).</p>
</div>
<div class="paragraph">
<p>The <code>:modules</code> section configures what code gets pulled into a given build.  Every build has at least one module,
and shadow will follow requires in the code so you typically only need your entry-point namespace in <code>:entries</code>.</p>
</div>
<div class="paragraph">
<p>See the  <a href="https://shadow-cljs.github.io/docs/UsersGuide.html">Shadow-cljs User&#8217;s Guide</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_html_file"><a class="anchor" href="#_html_file"></a><a class="link" href="#_html_file">3.4.3. HTML File</a></h4>
<div class="paragraph">
<p>In <code>resources/public/index.html</code> add this content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html"><span class="tag">&lt;html&gt;</span>
 <span class="tag">&lt;meta</span> <span class="attribute-name">charset</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;body&gt;</span>
    <span class="tag">&lt;div</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">app</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><span class="tag">&lt;/div&gt;</span>
    <span class="tag">&lt;script</span> <span class="attribute-name">src</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/js/main/main.js</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><span class="tag">&lt;/script&gt;</span>
  <span class="tag">&lt;/body&gt;</span>
<span class="tag">&lt;/html&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We really only need to load our one (generated) js file and supply a <code>div</code> with an ID.  Our React application will be
rendered on that <code>div</code>. You may, of course, include other content around that: CSS, other divs, etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_application_source"><a class="anchor" href="#_application_source"></a><a class="link" href="#_application_source">3.4.4. Application Source</a></h4>
<div class="paragraph">
<p>Our base source path is <code>src/main</code> for production code, and we want a namespace within the app package.
Our directory structure must match this in CLJ(S), so we create <code>src/main/app/client.cljs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.client</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.application <span class="symbol">:as</span> app]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

(<span class="keyword">defonce</span> <span class="function">app</span> (app/fulcro-app))

(defsc Root [this props]
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">TODO</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">defn</span> ^<span class="symbol">:export</span> init
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Shadow-cljs sets this up to be our entry-point function. See shadow-cljs.edn `:init-fn` in the modules of the main build.</span><span class="delimiter">&quot;</span></span>
  []
  (app/mount! app Root <span class="string"><span class="delimiter">&quot;</span><span class="content">app</span><span class="delimiter">&quot;</span></span>)
  (js/console.log <span class="string"><span class="delimiter">&quot;</span><span class="content">Loaded</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">defn</span> ^<span class="symbol">:export</span> refresh
  <span class="string"><span class="delimiter">&quot;</span><span class="content">During development, shadow-cljs will call this on every hot reload of source. See shadow-cljs.edn</span><span class="delimiter">&quot;</span></span>
  []
  <span class="comment">;; re-mounting will cause forced UI refresh, update internals, etc.</span>
  (app/mount! app Root <span class="string"><span class="delimiter">&quot;</span><span class="content">app</span><span class="delimiter">&quot;</span></span>)
  (js/console.log <span class="string"><span class="delimiter">&quot;</span><span class="content">Hot reload</span><span class="delimiter">&quot;</span></span>))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_summary"><a class="anchor" href="#_summary"></a><a class="link" href="#_summary">3.4.5. Summary</a></h4>
<div class="paragraph">
<p>Your project source tree should now look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ tree .
.
├── deps.edn
├── package.json
├── resources
│   └── public
│       ├── index.html
├── shadow-cljs.edn
└── src
    └── main
        └── app
            └── client.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it!  You have a complete Fulcro application!</p>
</div>
</div>
<div class="sect3">
<h4 id="_build_it"><a class="anchor" href="#_build_it"></a><a class="link" href="#_build_it">3.4.6. Build It!</a></h4>
<div class="paragraph">
<p>You can start the compiler server with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ npx shadow-cljs server</code></pre>
</div>
</div>
<div class="paragraph">
<p>and navigate to the URL it prints out for the compiler server (usually <a href="http://localhost:9630" class="bare">http://localhost:9630</a>). You can then use the
"Builds" menu to turn on/off different client builds and see the progress live as it happens!</p>
</div>
<div class="paragraph">
<p>It also has hot-code (and CSS) reload built in, so there is no need for any additional tools!</p>
</div>
<div class="paragraph">
<p>We configured the <code>shadow-cljs</code> server to also start a development mode HTTP server to serve our HTML file and
javascript. So, if you didn&#8217;t make any typos then your new app should display "TODO" at
<a href="http://localhost:8000" class="bare">http://localhost:8000</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_repl"><a class="anchor" href="#_using_the_repl"></a><a class="link" href="#_using_the_repl">3.4.7. Using the REPL</a></h4>
<div class="paragraph">
<p>Shadow-cljs creates an network REPL for your clojurescript program.  You can actually use a limited REPL via
the shadow-cljs control web page (the one at port 9630).  If you look at the command-line startup output you&#8217;ll also see it
report a port number on which you can connect a more advanced REPL (you can nail that port to a constant using
the setting <code>:nrepl    {:port 9000}</code> at the top-level of <code>shadow-cljs.edn</code>).</p>
</div>
<div class="paragraph">
<p>If you&#8217;re using IntelliJ, edit your run configurations and add a "Clojure &#8594; Remote REPL".  Give it <code>localhost</code>
for the host, and the port reported by shadow&#8217;s startup message.</p>
</div>
<div class="paragraph">
<p>Once you connect to the network REPL you&#8217;ll have to select the build you want to work against (and you <strong>must</strong> already
have that application running in a browser). Just run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">user=&gt; (shadow/repl <span class="symbol">:main</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>to cause it to change over to a CLJS REPL connected to your running application.</p>
</div>
<div class="paragraph">
<p>Now running <code>(js/alert "Hi")</code> should cause the browser to throw up an alert on your application&#8217;s tab.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_basic_ui_components"><a class="anchor" href="#_basic_ui_components"></a><a class="link" href="#_basic_ui_components">3.5. Basic UI Components</a></h3>
<div class="paragraph">
<p>Fulcro supplies a <code>defsc</code> macro to build React components. This macro emits class-based React components (hook support
is coming soon, but does not work with <code>defsc</code>). These components are augmented with Fulcro&#8217;s data management
and render refresh.</p>
</div>
<div class="paragraph">
<p>There are also factory functions for generating all standard HTML5 DOM elements in React in the
<code>com.fulcrologic.fulcro.dom</code> namespace.</p>
</div>
<div class="paragraph">
<p>The basic code to build a simple component has the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc ComponentName
  [this props] <span class="comment">; parameters. Available in body, and in *some* of the options</span>
  <span class="comment">; optional:  { ...options... }</span>
  (dom/div {<span class="symbol">:className</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span> <span class="symbol">:id</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span> <span class="symbol">:style</span> {<span class="symbol">:color</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>}}
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This macro emits the equivalent of a React component with a <code>render</code> method.</p>
</div>
<div class="paragraph">
<p>You can tighten your DOM code up even more if you also <code>:refer</code> the common tags in your namespace declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.client</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom <span class="symbol">:refer</span> [div p]]))

(defsc ComponentName [this props]
  { <span class="keyword">..</span><span class="keyword">.</span>options.<span class="keyword">..</span> }
  (div {<span class="symbol">:className</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span> <span class="symbol">:id</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span> <span class="symbol">:style</span> {<span class="symbol">:color</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>}}
    (p <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>React lifecycle methods are all supported, but we&#8217;ll talk about those later.</p>
</div>
<div class="sect3">
<h4 id="_the_render_method"><a class="anchor" href="#_the_render_method"></a><a class="link" href="#_the_render_method">3.5.1. The <code>render</code> method.</a></h4>
<div class="paragraph">
<p>The body of <code>defsc</code> is the render for the component and can do whatever work you need, but it should be a
"pure" function of the parameters and return
a react element (see <a href="https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html">React Components, Elements, and Instances</a>).
As of React 16 you can return a fragment or sequence of elements as well (though each must have a unique <code>:key</code>).</p>
</div>
<div class="paragraph">
<p>The DOM element functions allow class names and IDs to be written in various forms for convenience. The following are
all equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(dom/div {<span class="symbol">:id</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span> <span class="symbol">:className</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">x y z</span><span class="delimiter">&quot;</span></span> <span class="symbol">:style</span> {<span class="symbol">:color</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>}} <span class="keyword">..</span><span class="keyword">.</span>)
(dom/div <span class="symbol">:.</span>x#id {<span class="symbol">:className</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">y z</span><span class="delimiter">&quot;</span></span> <span class="symbol">:style</span> {<span class="symbol">:color</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>}} <span class="keyword">..</span><span class="keyword">.</span>)
(dom/div <span class="symbol">:.</span>x.y.z#id {<span class="symbol">:style</span> {<span class="symbol">:color</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>}} <span class="keyword">..</span><span class="keyword">.</span>)
(dom/div <span class="symbol">:.</span>x#id {<span class="symbol">:classes</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">z</span><span class="delimiter">&quot;</span></span>] <span class="symbol">:style</span> {<span class="symbol">:color</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>}} <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The keyword notation requires each class to be preceeded by a <code>.</code>, and will give a compile error if you forget to do that.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Children simply placed after the props as nested children.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If you&#8217;re writing your UI in CLJC files then you need to make sure you use a conditional
reader to pull in the proper server DOM functions for Clojure:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.client</span>
  (<span class="symbol">:require</span> <span class="error">#</span>?(<span class="symbol">:clj</span> [com.fulcrologic.fulcro.dom-server <span class="symbol">:as</span> dom] <span class="symbol">:cljs</span> [fulcro.client.dom <span class="symbol">:as</span> dom]))

<span class="keyword">..</span><span class="keyword">.</span> the actual code is the same as before</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reason this is necessary is that CLJS requires macros to be in CLJ files, but in order to get higher-order functions to
operate in CLJ the DOM elements must be functions. In CLJS, you can have both a macro and function with
the same name, but this is not true in CLJ. Therefore, two namespaces are required in order to get the optimal (inlined) client performance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Regarding performance: The <code>dom</code> macros/functions in Fulcro <strong>can be</strong> nearly as fast as calling raw React <code>createElement</code>
directly (the macros, in fact, directly turn into low-level js/createElement calls with <strong>compile-time</strong> conversion of the
cljs props to js in the optimal case), even when using the convenience features;
however, the macros cannot make them that fast if there is ambiguity about
the props vs. children. For example, <code>(div :.a (f))</code> is ambiguous at compile time
(the expression after <code>:.a</code> could be a function call returning a props map or a nested React element), so it will be
forced to add code that checks for a cljs map, and if it finds one, code to convert it to a js object.
Technically you can force the highest level of runtime performance by always including a props map, even if you don&#8217;t
need one: <code>(div :.a {} (f))</code>. This latter example has no ambiguity and the macro can <strong>at compile time</strong> convert
the props to a javascript object for passing directly to React <code>createElement</code>. The speed difference can be about 3-fold,
but even then it is usually so small that it won&#8217;t matter, so you may want to use tighter notation unless you measure a real
performance problem.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_props"><a class="anchor" href="#_props"></a><a class="link" href="#_props">3.5.2. Props</a></h4>
<div class="paragraph">
<p>React components receive their data through props and state (which is local mutable state on the component).
In Fulcro you will usually use props for most things.
The data passed to a component can be accessed (as a cljs map) by
calling <code>comp/props</code> on <code>this</code>, or by destructuring in the second argument of <code>defsc</code>.</p>
</div>
<div class="paragraph">
<p>So, let&#8217;s define a <code>Person</code> component to display details about
a person. We&#8217;ll assume that we&#8217;re going to pass in name and age as properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this {<span class="symbol">:person/keys</span> [<span class="keyword">name</span> age]}]
  (dom/div
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">Name: </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>)
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">Age: </span><span class="delimiter">&quot;</span></span> age)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, in order to use this component we need an element factory. An element factory lets
us use the component within our React UI tree. Name confusion can become an
issue (Person the component vs. person the factory?) we recommend prefixing the factory with <code>ui-</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can compose people into our root:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Root [this props]
  (dom/div
    (ui-person {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">22</span>})))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_hot_code_reload"><a class="anchor" href="#_hot_code_reload"></a><a class="link" href="#_hot_code_reload">3.5.3. Hot Code Reload</a></h4>
<div class="paragraph">
<p>Part of our quick development story is getting hot code reload to update the UI whenever we change the source.
Try editing the UI of <code>Person</code> and save. You should see the UI update even though the person&#8217;s data didn&#8217;t change.</p>
</div>
</div>
<div class="sect3">
<h4 id="_organizing_source"><a class="anchor" href="#_organizing_source"></a><a class="link" href="#_organizing_source">3.5.4. Organizing Source</a></h4>
<div class="paragraph">
<p>At this point it is a good idea to adopt some code organization.  The application itself might be needed from
any number of namespaces, so having it mixed in with things can easily lead to circular requires, which are
not allowed in Clojure(script).</p>
</div>
<div class="paragraph">
<p>To avoid this, we&#8217;ll create <code>src/main/app/application.cljs</code> and put this content there:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.application</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.application <span class="symbol">:as</span> app]))

(<span class="keyword">defonce</span> <span class="function">app</span> (app/fulcro-app))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You probably want to move your actual UI tree to a new namespace for similar reasons.  Create
a new file <code>src/main/app/ui.cljs</code> with this content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

(defsc Person [this {<span class="symbol">:person/keys</span> [<span class="keyword">name</span> age]}]
  (dom/div
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">Name: </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>)
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">Age: </span><span class="delimiter">&quot;</span></span> age)))

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person))

(defsc Root [this props]
  (dom/div
    (ui-person {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">22</span>})))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and now you can pare your <code>client.cljs</code> down to just the initialization code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.client</span>
  (<span class="symbol">:require</span>
    [app.application <span class="symbol">:refer</span> [app]]
    [app.ui <span class="symbol">:as</span> ui]
    [com.fulcrologic.fulcro.application <span class="symbol">:as</span> app]))

(<span class="keyword">defn</span> ^<span class="symbol">:export</span> init []
  (app/mount! app ui/Root <span class="string"><span class="delimiter">&quot;</span><span class="content">app</span><span class="delimiter">&quot;</span></span>)
  (js/console.log <span class="string"><span class="delimiter">&quot;</span><span class="content">Loaded</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">defn</span> ^<span class="symbol">:export</span> refresh []
  <span class="comment">;; re-mounting will cause forced UI refresh</span>
  (app/mount! app ui/Root <span class="string"><span class="delimiter">&quot;</span><span class="content">app</span><span class="delimiter">&quot;</span></span>)
  (js/console.log <span class="string"><span class="delimiter">&quot;</span><span class="content">Hot reload</span><span class="delimiter">&quot;</span></span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Splitting up your source will also typically help with overall incremental compile speed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_composing"><a class="anchor" href="#_composing"></a><a class="link" href="#_composing">3.5.5. Composing</a></h4>
<div class="paragraph">
<p>You should already be getting the picture that your UI is going to be a tree composed from a root element. The
method of data passing (via props) should also be giving you the picture that supplying data to your UI (through root)
means you need to supply an equivalently structured tree of data. This is true of basic React.
However, just to drive the point home let&#8217;s make a slightly more complex UI and see it in detail:</p>
</div>
<div class="paragraph">
<p>Replace your UI content with this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this {<span class="symbol">:person/keys</span> [<span class="keyword">name</span> age]}]
  (dom/li
    (dom/h5 (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content"> (age: </span><span class="delimiter">&quot;</span></span> age <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>))))

<span class="comment">;; The keyfn generates a react key for each element based on props. See React documentation on keys.</span>
(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:person/name</span>}))

(defsc PersonList [this {<span class="symbol">:list/keys</span> [label people]}]
  (dom/div
    (dom/h4 label)
    (dom/ul
      (<span class="keyword">map</span> ui-person people))))

(<span class="keyword">def</span> <span class="function">ui-person-list</span> (comp/factory PersonList))

(defsc Root [this {<span class="symbol">:keys</span> [ui/react-key]}]
  (<span class="keyword">let</span> [ui-data {<span class="symbol">:friends</span> {<span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span> <span class="symbol">:list/people</span>
                                              [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">32</span>}
                                               {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">22</span>}]}
                 <span class="symbol">:enemies</span> {<span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span> <span class="symbol">:list/people</span>
                                              [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">11</span>}
                                               {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">55</span>}]}}]
    (dom/div
      (ui-person-list (<span class="symbol">:friends</span> ui-data))
      (ui-person-list (<span class="symbol">:enemies</span> ui-data)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>So that the UI graph looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/ui-graph.png" alt="ui graph" width="260" height="238">
</div>
</div>
<div class="paragraph">
<p>and the data graph matches the same structure, with map keys acting as the graph "edges":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{ <span class="symbol">:friends</span>           { <span class="symbol">:list/people</span> [PERSON <span class="keyword">..</span><span class="keyword">.</span>]
<span class="comment">;  ==to-one list=&gt;      ==to-many people==&gt;</span>
  <span class="symbol">:enemies</span>           { <span class="symbol">:list/people</span> [PERSON <span class="keyword">..</span><span class="keyword">.</span>] }</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/data-tree.png" alt="data tree" width="280" height="238">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_feeding_the_data_tree"><a class="anchor" href="#_feeding_the_data_tree"></a><a class="link" href="#_feeding_the_data_tree">3.6. Feeding the Data Tree</a></h3>
<div class="paragraph">
<p>Obviously it isn&#8217;t going to be desirable to hand-manage this very well for anything
but the most trivial application (which is the crux of the problems with most UI libraries).</p>
</div>
<div class="paragraph">
<p>At best it does give us a persistent data structure that represents the
current "view" of the application (which has many benefits), but at worst it requires us to "think globally"
about our application. We want local reasoning. We also want to be able to easily re-compose our UI as needed,
and a static data graph like this would have to be updated every time we made a change! Almost equally as bad: if
two different parts of our UI want to show the same data then we&#8217;d have to find and update a bunch of copies
spread all over the data tree.</p>
</div>
<div class="paragraph">
<p>So, how do we solve this?</p>
</div>
<div class="sect3">
<h4 id="_why_not_have_components_just_grab_their_data_sideband"><a class="anchor" href="#_why_not_have_components_just_grab_their_data_sideband"></a><a class="link" href="#_why_not_have_components_just_grab_their_data_sideband">3.6.1. Why not have components just "grab" their data (sideband)?</a></h4>
<div class="paragraph">
<p>This is certainly a possibility; however, it leads to other complications. What is the data model? How do you
interact with remotes to fill your data needs? Fulcro has a very nice cohesive story for these questions,
while other systems end up with complications like event handler middleware, data management instances or modules
peppered through the code, etc.</p>
</div>
<div class="paragraph">
<p>Fulcro has a model for all of this, and it is surprising how simple it makes your application once you
put it all together.  Let&#8217;s look at the steps and parts:</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_1the_initial_state"><a class="anchor" href="#_step_1the_initial_state"></a><a class="link" href="#_step_1the_initial_state">3.6.2. Step 1&#8201;&#8212;&#8201;The Initial State</a></h4>
<div class="paragraph">
<p>All applications have some starting initial state. Since our UI is a tree, our starting state needs to
somehow establish what goes into the initial nodes and edges of the local client database.</p>
</div>
<div class="paragraph">
<p>In Fulcro there is a way to construct the initial tree of data in a way that allows for local reasoning and
easy refactoring: co-locate the initial desired part of the tree with the component that uses it. This allows
you to compose the state tree in exactly the same way as the UI tree.</p>
</div>
<div class="paragraph">
<p>The <code>defsc</code> macro makes short work of this with the <code>initial-state</code> option. Simply give it a
lambda that gets parameters (optionally from the parent) and returns a map representing the state of the component.
You can retrieve this data using <code>(comp/get-initial-state Component)</code>.</p>
</div>
<div class="paragraph">
<p>It looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]))

(defsc Person [this {<span class="symbol">:person/keys</span> [<span class="keyword">name</span> age]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [<span class="keyword">name</span> age] <span class="symbol">:as</span> params}] {<span class="symbol">:person/name</span> <span class="keyword">name</span> <span class="symbol">:person/age</span> age}) }
  (dom/li
    (dom/h5 (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">(age: </span><span class="delimiter">&quot;</span></span> age <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>))))

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:person/name</span>}))

(defsc PersonList [this {<span class="symbol">:list/keys</span> [label people]}]
  {<span class="symbol">:initial-state</span>
   (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [label]}]
     {<span class="symbol">:list/label</span>  label
      <span class="symbol">:list/people</span> (<span class="keyword">if</span> (<span class="keyword">=</span> label <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>)
                            [(comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">32</span>})
                             (comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">22</span>})]
                            [(comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">11</span>})
                             (comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">55</span>})])})}
   (dom/div
     (dom/h4 label)
     (dom/ul
       (<span class="keyword">map</span> ui-person people))))

(<span class="keyword">def</span> <span class="function">ui-person-list</span> (comp/factory PersonList))

<span class="comment">; Root's initial state becomes the entire app's initial state!</span>
(defsc Root [this {<span class="symbol">:keys</span> [friends enemies]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:friends</span> (comp/get-initial-state PersonList {<span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>})
                                <span class="symbol">:enemies</span> (comp/get-initial-state PersonList {<span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>})}) }
  (dom/div
    (ui-person-list friends)
    (ui-person-list enemies)))</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You <strong>must</strong> reload your browser for this to show up. Fulcro pulls this data into the database when the
application <strong>first mounts</strong>, not on hot code reload (because that would change your app state, and hot
code reload is more useful without state changes).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now a lot of the specific data here is just for demonstration purposes. Data like this (people) would almost
certainly come from a server, but it serves to illustrate that we can localize the initial data needs of a
component to the component, and then compose that into the parent in an abstract way
(by calling <code>get-initial-state</code> against that child).</p>
</div>
<div class="paragraph">
<p>There are several benefits of this so far:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It generates the exact tree of data needed to feed the initial UI.</p>
</li>
<li>
<p>That initial state becomes your initial application database.</p>
</li>
<li>
<p>It restores local reasoning (and easy refactoring). Moving a component just means local reasoning about the
component being moved and the component it is being moved from/to: You remove the <code>get-initial-state</code> from one
parent and add it to a different one.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can see that there is no magic if you just pull the initial tree at the REPL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="clojure">dev<span class="symbol">:cljs.user</span>=&gt; (com.fulcrologic.fulcro.components/get-initial-state app.ui.root/Root {})
{<span class="symbol">:friends</span> {<span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>,
           <span class="symbol">:list/people</span> [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">32</span>} {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">22</span>}]},
 <span class="symbol">:enemies</span> {<span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>,
           <span class="symbol">:list/people</span> [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">11</span>} {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">55</span>}]}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s nothing more than function composition. The initial state option on <code>defsc</code> encodes your initial state
into a function that can be accessed via <code>get-initial-state</code> on a class.</p>
</div>
<div class="paragraph">
<p>So behind the scenes Fulcro detects the initial state on the first mount and automatically uses it to initialize your
application state.</p>
</div>
<div class="paragraph">
<p>By default, the entire initial state database is passed into your root node on render, so it is
available for destructuring in Root&#8217;s props.</p>
</div>
<div class="paragraph">
<p>If you even want to see your current application state, you can do so through the <code>app</code> itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">dev<span class="symbol">:cljs.user</span>=&gt; (com.fulcrologic.fulcro.application/current-state app.application/app)</code></pre>
</div>
</div>
<div class="paragraph">
<p>but usually you&#8217;ll look at this state via the Fulcro Inspect Chrome development tool.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s move on and see how we program our UI to access the data in the application state!</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_2establishing_a_query"><a class="anchor" href="#_step_2establishing_a_query"></a><a class="link" href="#_step_2establishing_a_query">3.6.3. Step 2&#8201;&#8212;&#8201;Establishing a Query</a></h4>
<div class="paragraph">
<p>Fulcro unifies the data access story using a co-located query on each component. This sets up data access
for both the client and server, and also continues our story of local reasoning and composition.</p>
</div>
<div class="paragraph">
<p>Queries go on a component in the same way as initial state: in the options map.</p>
</div>
<div class="paragraph">
<p>The query notation is relatively light, and we&#8217;ll just concentrate on two bits of query syntax: props and joins.</p>
</div>
<div class="paragraph">
<p>Queries form a tree just like the UI and data. Obtaining a value at the current node in the tree traversal is done
using the keyword for that value. Walking down the graph (a join) is represented as a map with a single entry whose
key is the name (keyword) for that nested bit of state.</p>
</div>
<div class="paragraph">
<p>So, a data tree like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:friends</span>
 {<span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>,
  <span class="symbol">:list/people</span>
  [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">32</span>}
   {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">22</span>}]},
 <span class="symbol">:enemies</span>
 {<span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>,
  <span class="symbol">:list/people</span>
  [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">11</span>}
   {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">55</span>}]}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>would have a query that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:friends</span>  <span class="comment">; JOIN</span>
    [ <span class="symbol">:list/label</span>
      {<span class="symbol">:list/people</span> <span class="comment">; JOIN</span>
         [<span class="symbol">:person/name</span> <span class="symbol">:person/age</span>]}]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This query reads "At the root you&#8217;ll find <code>:friends</code>, which joins to a nested entity that has a label and people.
People, in turn, is a join that has nested properties name and age.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A vector always means "get this stuff at the current node". Note that this is a <strong>relative</strong> (to the current node) statement.</p>
</li>
<li>
<p><code>:friends</code> is a key in a map, so at the root of the application state the query engine would expect to find that
key, and would expect the value to be nested state (because maps mean joins on the tree)</p>
</li>
<li>
<p>The value in the <code>:friends</code> join is a subquery, and therefore must be a vector because we have to indicate what
we want out of the nested data.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Joins are automatically <code>to-one</code> if the data found in the state is a singular, and <code>to-many</code> if the data found is a
vector. In the example above the <code>:friends</code> field from root pointed to a single <code>PersonList</code>, whereas the <code>PersonList</code>
field <code>:list/people</code> pointed to a vector of <code>Person</code> data.  Beware that you don&#8217;t confuse yourself with
naming (e.g. friends is plural, but points to a single UI element that represents a single list, which in
turn owns the items of that list).</p>
</div>
<div class="paragraph">
<p>The namespacing of keywords in your data (and therefore your query) is highly encouraged, as it makes it clear to the
reader what kind of entity you&#8217;re working against (it also ensures that over-rendering doesn&#8217;t happen on
refreshes later). Furthermore, it enables the full potential of Pathom when you get to the server interactions.</p>
</div>
<div class="paragraph">
<p>You can try this query stuff out in your REPL. Let&#8217;s say you just want the friends list label. The function
<code>fdn/db&#8594;tree</code> can take an application database (which we can generate from initial state) and run a query
against it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">dev<span class="symbol">:cljs.user</span>=&gt; (fdn/db-&gt;tree [{<span class="symbol">:friends</span> [<span class="symbol">:list/label</span>]}] (comp/get-initial-state app.client/Root {}) {})
{<span class="symbol">:friends</span> {<span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>HINT: The mirror of initial state with query is a great way to error-check your work (and <code>defsc</code> does some of that
for you): For each scalar property in initial state, there should be an identical simple property in your query.
For each join of initial state to a child via <code>get-initial-state</code> there should be a query join
via <code>get-query</code> to that same child.</p>
</div>
<div class="sect4">
<h5 id="_adding_queries_to_our_example"><a class="anchor" href="#_adding_queries_to_our_example"></a><a class="link" href="#_adding_queries_to_our_example">Adding Queries to Our Example</a></h5>
<div class="paragraph">
<p>We want our queries to have the same nice local-reasoning as our initial data tree. The <code>get-query</code> function
works just like the <code>get-initial-state</code> function, and can pull the query from a component.
The <code>get-query</code> function actually augments the subqueries with metadata that is
important at a later stage.</p>
</div>
<div class="paragraph">
<p>So, the <code>Person</code> component queries for just the properties it needs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this {<span class="symbol">:person/keys</span> [<span class="keyword">name</span> age]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:person/name</span> <span class="symbol">:person/age</span>]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [<span class="keyword">name</span> age] <span class="symbol">:as</span> params}] {<span class="symbol">:person/name</span> <span class="keyword">name</span> <span class="symbol">:person/age</span> age})}
  (dom/li
    (dom/h5 (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">(age: </span><span class="delimiter">&quot;</span></span> age <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the entire rest of the component <strong>did not</strong> change.</p>
</div>
<div class="paragraph">
<p>Next up the chain, we compose the <code>Person</code> query into <code>PersonList</code> (notice how the composition of state and query
are mirrored):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc PersonList [this {<span class="symbol">:keys</span> [list/label list/people]}]
  {<span class="symbol">:query</span> [<span class="symbol">:list/label</span> {<span class="symbol">:list/people</span> (comp/get-query Person)}]
   <span class="symbol">:initial-state</span>
          (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [label]}]
            {<span class="symbol">:list/label</span>  label
             <span class="symbol">:list/people</span> (<span class="keyword">if</span> (<span class="keyword">=</span> label <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>)
                            [(comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">32</span>})
                             (comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">22</span>})]
                            [(comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">11</span>})
                             (comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">55</span>})])})}
  (dom/div
    (dom/h4 label)
    (dom/ul
      (<span class="keyword">map</span> ui-person people))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>again, nothing else changes.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_3receive_the_data_feed_as_props_in_root"><a class="anchor" href="#_step_3receive_the_data_feed_as_props_in_root"></a><a class="link" href="#_step_3receive_the_data_feed_as_props_in_root">3.6.4. Step 3&#8201;&#8212;&#8201;Receive the Data Feed as Props in Root</a></h4>
<div class="paragraph">
<p>Finally, we compose to <code>Root</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Root [this {<span class="symbol">:keys</span> [friends enemies]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:friends</span> (comp/get-query PersonList)}
                   {<span class="symbol">:enemies</span> (comp/get-query PersonList)}]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:friends</span> (comp/get-initial-state PersonList {<span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>})
                                <span class="symbol">:enemies</span> (comp/get-initial-state PersonList {<span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>})})}
  (dom/div
    (ui-person-list friends)
    (ui-person-list enemies)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This all looks like a minor (and somewhat wordy) addition; However, we&#8217;re getting close to
the magic, so stick with us. The major difference in this code is that even though the database <strong>starts
out</strong> with the initial state, there is nothing to say we have to query for everything that is in there,
or that the state has to start out with everything we might query for in the future. We&#8217;re getting
close to having a dynamic data-driven application.</p>
</div>
<div class="paragraph">
<p>Notice that everything we&#8217;ve done so far has <strong>global client database</strong> implications, but that each component
codes only the <strong>local portion</strong> it is concerned with. Local reasoning is maintained. All software evolution in
this model preserves this critical aspect.</p>
</div>
<div class="paragraph">
<p>Also, you now have application state that can evolve (the query is running against the active application
database stored in an atom).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
You should always think of the query as "running from root". You&#8217;ll
notice that <code>Root</code> still expects to receive the <strong>entire</strong> data tree for the UI (even though it doesn&#8217;t have to
know much about what is in it, other than the names of direct children), and it still picks out those sub-trees
of data and passes them on. In this way an arbitrary component in the UI tree is not querying
for its data directly in a side-band sort of way, but is instead being composed in from parent to parent all the
way to the root. Later, we&#8217;ll learn how Fulcro can optimize this and pull the data from the database for
a specific component, but the <strong>reasoning</strong> will remain the same.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_passing_callbacks_and_other_parent_computed_data"><a class="anchor" href="#_passing_callbacks_and_other_parent_computed_data"></a><a class="link" href="#_passing_callbacks_and_other_parent_computed_data">3.7. Passing Callbacks and Other Parent-computed Data</a></h3>
<div class="paragraph">
<p>The queries on components describe what data the component wants from the <em>database</em>; however, you&#8217;re not allowed
to put code in the database, and sometimes a parent might compute something it needs to pass to a child like
a callback function.</p>
</div>
<div class="paragraph">
<p>It turns out that we <strong>can</strong> optimize away the refresh of components (if their data has not changed). This
means that we can use a component&#8217;s query to directly re-supply data for refresh; however, since doing so
<em>skips the rendering of the parent</em>. If we are not careful this can lead to "losing" these extra bits of
computationally generated data passed <strong>from</strong> the parent, like callbacks.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say we want to render a delete button on our individual people in our UI. This button will mean
"remove the person from this list"&#8230;&#8203;but the person itself has no idea which list it is in. Thus,
the parent will need to pass in a function that the child can call to affect the delete properly:</p>
</div>
<div class="sect3">
<h4 id="_the_incorrect_way"><a class="anchor" href="#_the_incorrect_way"></a><a class="link" href="#_the_incorrect_way">3.7.1. The Incorrect Way:</a></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this {<span class="symbol">:keys</span> [person/name person/age onDelete]}] <span class="comment">; </span><b class="conum">(3)</b>
  {<span class="symbol">:query</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:person/name</span> <span class="symbol">:person/age</span>])
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [<span class="keyword">name</span> age] <span class="symbol">:as</span> params}] {<span class="symbol">:person/name</span> <span class="keyword">name</span> <span class="symbol">:person/age</span> age})}
  (dom/li
    (dom/h5 (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content"> (age: </span><span class="delimiter">&quot;</span></span> age <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>) (dom/button {<span class="symbol">:onClick</span> #(onDelete <span class="keyword">name</span>)} <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>)))) <span class="comment">; </span><b class="conum">(4)</b>

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:person/name</span>}))

(defsc PersonList [this {<span class="symbol">:list/keys</span> [label people]}]
  {<span class="symbol">:query</span> [<span class="symbol">:list/label</span> {<span class="symbol">:list/people</span> (comp/get-query Person)}]
   <span class="symbol">:initial-state</span>
          (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [label]}]
            {<span class="symbol">:list/label</span>  label
             <span class="symbol">:list/people</span> (<span class="keyword">if</span> (<span class="keyword">=</span> label <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>)
                            [(comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">32</span>})
                             (comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">22</span>})]
                            [(comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">11</span>})
                             (comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">55</span>})])})}
  (<span class="keyword">let</span> [delete-person (<span class="keyword">fn</span> [<span class="keyword">name</span>] (<span class="keyword">println</span> label <span class="string"><span class="delimiter">&quot;</span><span class="content">asked to delete</span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))]  <span class="comment">; </span><b class="conum">(1)</b>
    (dom/div
      (dom/h4 label)
      (dom/ul
        (<span class="keyword">map</span> (<span class="keyword">fn</span> [p] (ui-person (<span class="keyword">assoc</span> p <span class="symbol">:onDelete</span> delete-person))) people))))) <span class="comment">; </span><b class="conum">(2)</b>

(<span class="keyword">def</span> <span class="function">ui-person-list</span> (comp/factory PersonList))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A function acting in as a stand-in for our real delete</p>
</li>
<li>
<p>Adding the callback into the props (WRONG)</p>
</li>
<li>
<p>Pulling the onDelete from the passed props (WRONG). The query has to be changed to a lambda to turn off error
checking to even try this method.</p>
</li>
<li>
<p>Invoking the callback when delete is pressed.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This method of passing a callback will work initially, but not consistently. The problem is that we can optimize away a
re-render of a parent when it can figure out how to pull just the data of the child on a refresh, and in that case the
callback will get lost because only the database data will get supplied to the child! Your delete button will work
on the initial render (from root), but may stop working at a later time after a UI refresh.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_correct_way"><a class="anchor" href="#_the_correct_way"></a><a class="link" href="#_the_correct_way">3.7.2. The Correct Way:</a></h4>
<div class="paragraph">
<p>There is a special helper function that can record the computed data like callbacks onto the child that receives them
such that an optimized refresh will still know them. There is also an additional (optional) component parameter to <code>defsc</code>
that you can use to deconstruct them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this {<span class="symbol">:person/keys</span> [<span class="keyword">name</span> age]} {<span class="symbol">:keys</span> [onDelete]}] <span class="comment">; </span><b class="conum">(2)</b>
  {<span class="symbol">:query</span>         [<span class="symbol">:person/name</span> <span class="symbol">:person/age</span>]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [<span class="keyword">name</span> age] <span class="symbol">:as</span> params}] {<span class="symbol">:person/name</span> <span class="keyword">name</span> <span class="symbol">:person/age</span> age})}
  (dom/li
    (dom/h5 (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content"> (age: </span><span class="delimiter">&quot;</span></span> age <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>) (dom/button {<span class="symbol">:onClick</span> #(onDelete <span class="keyword">name</span>)} <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>)))) <span class="comment">; </span><b class="conum">(2)</b>

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:person/name</span>}))

(defsc PersonList [this {<span class="symbol">:list/keys</span> [label people]}] <span class="comment">;</span>
  {<span class="symbol">:query</span> [<span class="symbol">:list/label</span> {<span class="symbol">:list/people</span> (comp/get-query Person)}]
   <span class="symbol">:initial-state</span>
          (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [label]}]
            {<span class="symbol">:list/label</span>  label
             <span class="symbol">:list/people</span> (<span class="keyword">if</span> (<span class="keyword">=</span> label <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>)
                                   [(comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">32</span>})
                                    (comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">22</span>})]
                                   [(comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">11</span>})
                                    (comp/get-initial-state Person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">55</span>})])})}
  (<span class="keyword">let</span> [delete-person (<span class="keyword">fn</span> [<span class="keyword">name</span>] (<span class="keyword">println</span> label <span class="string"><span class="delimiter">&quot;</span><span class="content">asked to delete</span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))] <span class="comment">; </span><b class="conum">(1)</b>
    (dom/div
      (dom/h4 label)
      (dom/ul
        (<span class="keyword">map</span> (<span class="keyword">fn</span> [p] (ui-person (comp/computed p {<span class="symbol">:onDelete</span> delete-person}))) people))))) <span class="comment">; </span><b class="conum">(1)</b>

(<span class="keyword">def</span> <span class="function">ui-person-list</span> (comp/factory PersonList))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>comp/computed</code> function is used to add the computed data to the props being passed.</p>
</li>
<li>
<p>The child adds an additional parameter, and pulls the computed data from there. You can also
use <code>(comp/get-computed this)</code> to pull all of the computed props in the body.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now you can be sure that your callbacks (or other parent-computed data) won&#8217;t be lost to render optimizations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You can create a <code>comp/computed-factory</code> instead of a regular <code>factory</code> for <code>ui-person</code>.  The computed factory
accepts props and computed as two arguments instead of having to use a nested notation.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_updating_the_data_tree"><a class="anchor" href="#_updating_the_data_tree"></a><a class="link" href="#_updating_the_data_tree">3.8. Updating the Data Tree</a></h3>
<div class="paragraph">
<p>Now the real fun begins: Making things dynamic.</p>
</div>
<div class="paragraph">
<p>Most operations that make changes to the client database should happen through the Fulcro transaction system. It
is actually possible to do more advanced low-level things, but that is beyond our current scope.</p>
</div>
<div class="sect3">
<h4 id="Transactions"><a class="anchor" href="#Transactions"></a><a class="link" href="#Transactions">3.8.1. Transactions</a></h4>
<div class="paragraph">
<p>Every change to the application database must go through a transaction processing system. This has two
goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Abstract the operation (like a function)</p>
</li>
<li>
<p>Treat the operation like data (which allows us to generalize it to remote interactions)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The operations themselves are just data and can be written as quoted data structures. Specifically as a vector of mutation
invocations. The entire transaction is just data. It is <strong>not</strong> something run in the UI, but instead
passed into the underlying system for processing.</p>
</div>
<div class="paragraph">
<p>You essentially just "make up" names for the operations you&#8217;d like to do to your database, just like
function names. Namespacing is encouraged, and of course syntax quoting honors namespace aliases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this `[(ops/delete-person {<span class="symbol">:list-name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span>})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>is asking the underlying system to run the mutation <code>ops/delete-person</code> (where ops can be an alias established
in the <code>ns</code>). Of course, you&#8217;ll typically use unquote to embed data from local variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this `[(ops/delete-person {<span class="symbol">:list-name</span> ~<span class="keyword">name</span> <span class="symbol">:person</span> ~person})])</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
When you define mutations they are actually set up to return themselves as data instead if called like functions.
This allows you to avoid the need to quote in most circumstances.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>defmutation</code> macro returns a function-like object that just returns itself as data when called "normally":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">user=&gt; (app.mutations/delete-person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>})
(app.mutations/delete-person {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, here are the rules of using mutations in <code>transact!</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If you can require the mutation namespace without causing circular references, then you can just "call" the mutation
within the transaction as-if it were a function (avoiding quoting). The result will still just embed the mutations
as raw data.</p>
</li>
<li>
<p>If you cannot require the namespace, then you <strong>must</strong> quote it, ensure the fully-qualified namespace is correct,
and unquote any data from the surrounding scope.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With the require:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span>
    [app.mutations <span class="symbol">:as</span> api]))

  <span class="keyword">..</span><span class="keyword">.</span>
  (comp/transact! this [(api/delete-person {<span class="symbol">:list-name</span> <span class="keyword">name</span> <span class="keyword">..</span><span class="keyword">.</span>})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Without the require:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span>
    <span class="keyword">..</span><span class="keyword">.</span>))

  <span class="keyword">..</span><span class="keyword">.</span>
  (comp/transact! this `[(app.mutations/delete-person {<span class="symbol">:list-name</span> ~<span class="keyword">name</span> <span class="keyword">..</span><span class="keyword">.</span>})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both uses generate the <strong>exact same runtime result</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_mutations"><a class="anchor" href="#_handling_mutations"></a><a class="link" href="#_handling_mutations">3.8.2. Handling Mutations</a></h4>
<div class="paragraph">
<p>Mutations can be defined wherever you want, but of course you need to make sure that
namespace is required by files that your program already uses or they won&#8217;t end up being available at runtime.</p>
</div>
<div class="paragraph">
<p>Something like <code>src/main/app/mutations.cljs</code>
is fine, but you might also find it useful to place your mutations in something topical so you can write
the server mutations in the CLJ version of the file, and the client ones in the cljs.  Mutations are always namespaced.</p>
</div>
<div class="paragraph">
<p>A mutation definition looks a bit like a method: It can have a docstring, and the argument list will always receive a
single argument (params) that will be a map (which then allows destructuring).</p>
</div>
<div class="paragraph">
<p>The body looks a bit like a <code>letfn</code>, but some of the names we use for the items are pre-established. The one
we&#8217;re interested in at the moment is <code>action</code>, which is what to do <strong>locally</strong>. The <code>action</code> method will be
passed the application database&#8217;s app-state atom, and it should change the data in that atom to reflect
the new "state of the world" indicated by the mutation.</p>
</div>
<div class="paragraph">
<p>For example, <code>delete-person</code> must find the list of people on the list in question, and filter out the one
that we&#8217;re deleting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.mutations</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]))

(defmutation delete-person
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Mutation: Delete the person with `name` from the list with `list-name`</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [list-name <span class="keyword">name</span>]}]                         <span class="comment">; </span><b class="conum">(1)</b>
  (action [{<span class="symbol">:keys</span> [state]}]                          <span class="comment">; </span><b class="conum">(2)</b>
    (<span class="keyword">let</span> [path     (<span class="keyword">if</span> (<span class="keyword">=</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span> list-name)
                     [<span class="symbol">:friends</span> <span class="symbol">:list/people</span>]
                     [<span class="symbol">:enemies</span> <span class="symbol">:list/people</span>])
          old-list (<span class="keyword">get-in</span> @state path)
          new-list (<span class="keyword">vec</span> (<span class="keyword">filter</span> #(<span class="keyword">not</span><span class="keyword">=</span> (<span class="symbol">:person/name</span> %) <span class="keyword">name</span>) old-list))]
      (<span class="keyword">swap!</span> state <span class="keyword">assoc-in</span> path new-list))))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The argument list for the mutation itself</p>
</li>
<li>
<p>The thing to do, which receives the app-state atom as an argument.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Then all that remains is to change <code>app.ui</code> in the following ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add a require for app.mutations</p>
</li>
<li>
<p>Change the callback to run the correct transaction</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span>
    <span class="comment">; ADD THIS:</span>
    [app.mutations <span class="symbol">:as</span> api])) <span class="comment">; </span><b class="conum">(1)</b>

<span class="keyword">..</span><span class="keyword">.</span>

(defsc PersonList [this {<span class="symbol">:keys</span> [list/label list/people]}]
  <span class="keyword">..</span><span class="keyword">.</span>
  (<span class="keyword">let</span> [delete-person (<span class="keyword">fn</span> [<span class="keyword">name</span>] (comp/transact! this [(api/delete-person {<span class="symbol">:list-name</span> label <span class="symbol">:name</span> <span class="keyword">name</span>})]))] <span class="comment">; </span><b class="conum">(2)</b>
  <span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The require ensures that the mutations are loaded, and also gives us an alias to the namespace of the mutation&#8217;s symbol.</p>
</li>
<li>
<p>Running the transaction in the callback.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that our mutation&#8217;s symbol is actually <code>app.mutations/delete-person</code>, but the first layer of evaluation (calling
a mutation as a function just returns the call itself) will rewrite it to <code>(app.mutations/delete-person &#8230;&#8203;)</code>.
Also realize that the mutation is <strong>not</strong> running in the UI, it is instead being handled "behind the scenes". This
allows a snapshot of the state history to be kept, and also a more seamless integration to full-stack operation
over a network to a server (in fact, the UI code here is <strong>already</strong> full-stack capable <strong>without any changes</strong>!).</p>
</div>
<div class="paragraph">
<p>This is where the power starts to show: all of the minutiae above is leading us to a grand unification when
it comes to writing full-stack applications.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hold_on_something_still_sucks"><a class="anchor" href="#_hold_on_something_still_sucks"></a><a class="link" href="#_hold_on_something_still_sucks">3.8.3. Hold on – Something Still Sucks!</a></h4>
<div class="paragraph">
<p>But first, we should address a problem that many of you may have already noticed: The mutation code is tied to
the shape of the UI tree!!!</p>
</div>
<div class="paragraph">
<p>This breaks our lovely model in several ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We can&#8217;t refactor our UI without also rewriting the mutations (since the data tree would change shape)</p>
</li>
<li>
<p>We can&#8217;t locally reason about any data. Our mutations have to understand things globally!</p>
</li>
<li>
<p>Our mutations could get rather large and ugly as our UI gets big</p>
</li>
<li>
<p>If a fact appears in more than one place in the UI and data tree, then we&#8217;ll have to update <strong>all</strong> of them
in order for things to be correct. Data duplication is never your friend.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_secret_sauce_normalizing_the_database"><a class="anchor" href="#_the_secret_sauce_normalizing_the_database"></a><a class="link" href="#_the_secret_sauce_normalizing_the_database">3.9. The Secret Sauce – Normalizing the Database</a></h3>
<div class="paragraph">
<p>Fortunately, we have a very good solution to the mutation problem above, and it is one that has been around for decades:
database normalization!</p>
</div>
<div class="paragraph">
<p>Here&#8217;s what we&#8217;re going to do:</p>
</div>
<div class="paragraph">
<p>Each UI component represents some conceptual entity with data (assuming it has state and a query). In a fully
normalized database, each such concept would have its own table, and related things would refer to it
through some kind of foreign key. In SQL land this looks like:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/sql-norm.png" alt="sql norm" width="760" height="196">
</div>
</div>
<div class="paragraph">
<p>In a graph database (like Datomic) a reference can have a to-many arity, so the direction can be more natural:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/datomic-norm.png" alt="datomic norm" width="630" height="168">
</div>
</div>
<div class="paragraph">
<p>Since we&#8217;re storing things in a map, we can represent "tables" as an entry in the map where the key is the
table name, and the value is a map from ID to entity value. So, the last diagram could be represented as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:PersonList</span> { <span class="symbol">:friends</span>  { <span class="symbol">:id</span> <span class="symbol">:friends</span>
                           <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>
                           <span class="symbol">:people</span> #{<span class="integer">1</span>, <span class="integer">2</span>} }}
 <span class="symbol">:Person</span> { <span class="integer">1</span> {<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> }
           <span class="integer">2</span> {<span class="symbol">:id</span> <span class="integer">2</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is close, but not quite good enough. The set in <code>:list/people</code> is a problem. There is no schema so there is no
way to know which table to look in for "1" and "2"!</p>
</div>
<div class="paragraph">
<p>The solution is rather easy: code the foreign reference to <strong>include</strong> the name of the table: <code>[:Person 1]</code>.</p>
</div>
<div class="paragraph">
<p>To-one relations are represented as a single one of these, and to-many relations as a vector of these (to preserve
order).</p>
</div>
<div class="paragraph">
<p>In Fulcro <code>[TABLE ID]</code> is known as an <strong><em>ident</em></strong>.</p>
</div>
<div class="paragraph">
<p>So, now that we have the concept and implementation, let&#8217;s talk about conventions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Properties should be namespaced: <code>:person/name</code>, <code>:account/email</code>, etc.</p>
</li>
<li>
<p>Entities are usually identified by a type-centric ID: <code>:person/id</code>, <code>:account/id</code>, etc.</p>
</li>
<li>
<p>Table names in the database are usually the same as the ID key of the entities within it (to facilitate some
nice support in Pathom).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Using these conventions the prior example would have looked like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:list/id</span> { <span class="symbol">:friends</span>  { <span class="symbol">:list/id</span> <span class="symbol">:friends</span>
                        <span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>
                        <span class="symbol">:list/people</span> [[<span class="symbol">:person/id</span> <span class="integer">1</span>] [<span class="symbol">:person/id</span> <span class="integer">2</span>]] }}
 <span class="symbol">:person/id</span> { <span class="integer">1</span> {<span class="symbol">:person/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> }
              <span class="integer">2</span> {<span class="symbol">:person/id</span> <span class="integer">2</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>}}}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_automatic_normalization"><a class="anchor" href="#_automatic_normalization"></a><a class="link" href="#_automatic_normalization">3.9.1. Automatic Normalization</a></h4>
<div class="paragraph">
<p>Fortunately, you don&#8217;t have to hand-normalize your data. The components have everything they need to
do it for you, other than the actual value of the <em>ident</em>. So, we&#8217;ll add one more option to your components
(and we&#8217;ll add IDs to the data at this point, since you can&#8217;t easily normalize things that don&#8217;t have them):</p>
</div>
<div class="paragraph">
<p>The program will now look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span>
    [app.mutations <span class="symbol">:as</span> api]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

(defsc Person [this {<span class="symbol">:person/keys</span> [<span class="keyword">name</span> age] <span class="symbol">:as</span> props} {<span class="symbol">:keys</span> [onDelete]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:person/id</span> <span class="symbol">:person/name</span> <span class="symbol">:person/age</span>] <span class="comment">; </span><b class="conum">(2)</b>
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:person/id</span> (<span class="symbol">:person/id</span> props)]) <span class="comment">; </span><b class="conum">(1)</b>
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [id <span class="keyword">name</span> age] <span class="symbol">:as</span> params}] {<span class="symbol">:person/id</span> id <span class="symbol">:person/name</span> <span class="keyword">name</span> <span class="symbol">:person/age</span> age})} <span class="comment">; </span><b class="conum">(3)</b>
  (dom/li
    (dom/h5 (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content"> (age: </span><span class="delimiter">&quot;</span></span> age <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>) (dom/button {<span class="symbol">:onClick</span> #(onDelete <span class="keyword">name</span>)} <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>)))) <span class="comment">; </span><b class="conum">(4)</b>

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:person/id</span>}))

(defsc PersonList [this {<span class="symbol">:list/keys</span> [id label people] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span> [<span class="symbol">:list/id</span> <span class="symbol">:list/label</span> {<span class="symbol">:list/people</span> (comp/get-query Person)}] <span class="comment">; </span><b class="conum">(5)</b>
   <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] [<span class="symbol">:list/id</span> (<span class="symbol">:list/id</span> props)])
   <span class="symbol">:initial-state</span>
          (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [id label]}]
            {<span class="symbol">:list/id</span>     id
             <span class="symbol">:list/label</span>  label
             <span class="symbol">:list/people</span> (<span class="keyword">if</span> (<span class="keyword">=</span> id <span class="symbol">:friends</span>)
                            [(comp/get-initial-state Person {<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">32</span>})
                             (comp/get-initial-state Person {<span class="symbol">:id</span> <span class="integer">2</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">22</span>})]
                            [(comp/get-initial-state Person {<span class="symbol">:id</span> <span class="integer">3</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">11</span>})
                             (comp/get-initial-state Person {<span class="symbol">:id</span> <span class="integer">4</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">55</span>})])})}
  (<span class="keyword">let</span> [delete-person (<span class="keyword">fn</span> [item-id] (comp/transact! this [(api/delete-person {<span class="symbol">:list</span> id <span class="symbol">:item</span> item-id})]))] <span class="comment">; </span><b class="conum">(4)</b>
    (dom/div
      (dom/h4 label)
      (dom/ul
        (<span class="keyword">map</span> #(ui-person (comp/computed % {<span class="symbol">:onDelete</span> delete-person})) people)))))

(<span class="keyword">def</span> <span class="function">ui-person-list</span> (comp/factory PersonList))

(defsc Root [this {<span class="symbol">:keys</span> [friends enemies]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:friends</span> (comp/get-query PersonList)}
                   {<span class="symbol">:enemies</span> (comp/get-query PersonList)}]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:friends</span> (comp/get-initial-state PersonList {<span class="symbol">:id</span> <span class="symbol">:friends</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>})
                                <span class="symbol">:enemies</span> (comp/get-initial-state PersonList {<span class="symbol">:id</span> <span class="symbol">:enemies</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>})})}
  (dom/div
    (ui-person-list friends)
    (ui-person-list enemies)))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Adding an ident allows Fulcro to know how to build a FK reference to a person (given its props). The <code>props</code> from
the <code>defsc</code> argument list is "in scope" for <code>ident</code>.</p>
</li>
<li>
<p>We will be using IDs now, so we need to add them to the query (and props destructuring).</p>
</li>
<li>
<p>The state of the entity will also need the ID</p>
</li>
<li>
<p>The callback will now be able to delete people by their ID (see below)</p>
</li>
<li>
<p>The list will have an ID, and an Ident as well</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you reload the web page (needed to reinitialize the database state), then you can look at the newly normalized
database at the REPL (<strong>NOTE: It is much easier to look at this using Fulcro Inspect in your developer tools tab</strong>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">dev<span class="symbol">:cljs.user</span>=&gt; (com.fulcrologic.fulcro.application/current-state app.application/app)
{<span class="symbol">:friends</span> [<span class="symbol">:list/id</span> <span class="symbol">:friends</span>]
 <span class="symbol">:enemies</span> [<span class="symbol">:list/id</span> <span class="symbol">:enemies</span>]
 <span class="symbol">:person/id</span> {<span class="integer">1</span> {<span class="symbol">:person/id</span> <span class="integer">1</span>, <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">32</span>}
             <span class="integer">2</span> {<span class="symbol">:person/id</span> <span class="integer">2</span>, <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">22</span>}
             <span class="integer">3</span> {<span class="symbol">:person/id</span> <span class="integer">3</span>, <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">11</span>}
             <span class="integer">4</span> {<span class="symbol">:person/id</span> <span class="integer">4</span>, <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">55</span>}}
 <span class="symbol">:list/id</span> {<span class="symbol">:friends</span> {<span class="symbol">:list/id</span> <span class="symbol">:friends</span>, <span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:list/people</span> [[<span class="symbol">:person/id</span> <span class="integer">1</span>] [<span class="symbol">:person/id</span> <span class="integer">2</span>]]}
           <span class="symbol">:enemies</span> {<span class="symbol">:list/id</span> <span class="symbol">:enemies</span>, <span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:list/people</span> [[<span class="symbol">:person/id</span> <span class="integer">3</span>] [<span class="symbol">:person/id</span> <span class="integer">4</span>]]}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>fdn/db&#8594;tree</code> understands this normalized form, and can convert it (via a query)
to the proper data tree. So, try this at the REPL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">=&gt; (<span class="keyword">def</span> <span class="function">state</span> (com.fulcrologic.fulcro.application/current-state app.application/app))
<span class="error">#</span>'cljs.user/state
=&gt; (<span class="keyword">def</span> <span class="function">query</span> (com.fulcrologic.fulcro.components/get-query app.ui/Root))
<span class="error">#</span>'cljs.user/query
=&gt; (com.fulcrologic.fulcro.algorithms.denormalize/db-&gt;tree query state state)
{<span class="symbol">:friends</span> {<span class="symbol">:list/id</span> <span class="symbol">:friends</span>,
           <span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>,
           <span class="symbol">:list/people</span> [{<span class="symbol">:person/id</span> <span class="integer">1</span>, <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">32</span>}
                         {<span class="symbol">:person/id</span> <span class="integer">2</span>, <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">22</span>}]},
 <span class="symbol">:enemies</span> {<span class="symbol">:list/id</span> <span class="symbol">:enemies</span>,
           <span class="symbol">:list/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>,
           <span class="symbol">:list/people</span> [{<span class="symbol">:person/id</span> <span class="integer">3</span>, <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">11</span>}
                         {<span class="symbol">:person/id</span> <span class="integer">4</span>, <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:person/age</span> <span class="integer">55</span>}]}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mutations_on_a_normalized_database"><a class="anchor" href="#_mutations_on_a_normalized_database"></a><a class="link" href="#_mutations_on_a_normalized_database">3.9.2. Mutations on a Normalized Database</a></h4>
<div class="paragraph">
<p>We have now made it possible to fix the problems with our mutation. Now, instead of removing
a person from a tree, we can remove a FK from a TABLE entry!</p>
</div>
<div class="paragraph">
<p>This is not only much easier to code, but it is completely independent of the shape of the UI tree. Fulcro&#8217;s
<code>com.fulcrologic.fulcro.algorithms/merge</code> namespace includes tools for merging and managing normalized data and includes
some helpers for dealing with lists of idents. Our mutation can now become:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.mutations</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.algorithms.merge <span class="symbol">:as</span> <span class="keyword">merge</span>]))

(defmutation delete-person
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Mutation: Delete the person with `:person/id` from the list with `:list/id`</span><span class="delimiter">&quot;</span></span>
  [{list-id   <span class="symbol">:list/id</span>
    person-id <span class="symbol">:person/id</span>}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state merge/remove-ident* [<span class="symbol">:person/id</span> person-id] [<span class="symbol">:list/id</span> list-id <span class="symbol">:list/people</span>])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mutation "helpers" in fulcro are functions that work against a plain map (normalized app database) so that they
can be used easily in <code>swap!</code>.  By convention these functions have a <code>*</code> suffix, and often have mutation versions that
do not have the suffix.</p>
</div>
<div class="paragraph">
<p>The <code>remove-ident*</code> mutation helper does just that: It removes an ident from a list of idents.  The arguments are
the ident to remove and the path to the list of idents that you want to remove it from.</p>
</div>
<div class="paragraph">
<p>Of course, you&#8217;ll have to change the mutation <strong>usage</strong> in the application to look like this now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this {<span class="symbol">:person/keys</span> [id <span class="keyword">name</span> age] <span class="symbol">:as</span> props} {<span class="symbol">:keys</span> [onDelete]}]  <b class="conum">(1)</b>
    <span class="keyword">..</span><span class="keyword">.</span>
    (dom/h5 (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content"> (age: </span><span class="delimiter">&quot;</span></span> age <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>) (dom/button {<span class="symbol">:onClick</span> #(onDelete id)} <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>)))) <span class="comment">; </span><b class="conum">(2)</b>

<span class="keyword">..</span><span class="keyword">.</span>

(defsc PersonList [this {<span class="symbol">:list/keys</span> [id label people] <span class="symbol">:as</span> props}] <b class="conum">(1)</b>
  <span class="keyword">..</span><span class="keyword">.</span>
  (<span class="keyword">let</span> [delete-person (<span class="keyword">fn</span> [person-id] (comp/transact! this [(api/delete-person {<span class="symbol">:list/id</span> id <span class="symbol">:person/id</span> person-id})]))] <span class="comment">; </span><b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Destructure ID from the props.</p>
</li>
<li>
<p>Use IDs in the mutation and callback.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If we were to now refactor the UI and wrap the person list in any amount of additional UI (e.g. a nav bar, sub-pane,
modal dialog, etc.) this mutation will still work perfectly, since the list itself will only have one place it
ever lives in the database.</p>
</div>
</div>
<div class="sect3">
<h4 id="_how_automatic_normalization_works_optional"><a class="anchor" href="#_how_automatic_normalization_works_optional"></a><a class="link" href="#_how_automatic_normalization_works_optional">3.9.3. How Automatic Normalization Works (optional)</a></h4>
<div class="paragraph">
<p>It is good to know how an arbitrary tree of data (the one in initial app state) can be converted to the normalized form.
Understanding how this is accomplished can help you avoid some mistakes later.</p>
</div>
<div class="paragraph">
<p>When you compose your query (via <code>comp/get-query</code>), the <code>get-query</code> function adds metadata to each component&#8217;s query
fragment that names which component that query fragment came from.</p>
</div>
<div class="paragraph">
<p>For example, try this at the REPL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">dev<span class="symbol">:cljs.user</span>=&gt; (<span class="keyword">meta</span> (com.fulcrologic.fulcro.components/get-query app.ui/PersonList))
{<span class="symbol">:component</span> app.ui/PersonList}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>get-query</code> function adds the component itself to the metadata for that query fragment. We already know that
we can get other static information from a component (in this case we&#8217;re interested in the <code>ident</code>).</p>
</div>
<div class="paragraph">
<p>So, Fulcro includes a function called <code>com.fulcrologic.fulcro.algorithms.normalize/tree&#8594;db</code> that can simultaneously
walk a data tree (in this case initial-state) and a
component-annotated query. When it reaches a data node whose query metadata names a component with an ident it
places that data into the appropriate table (by calling your <code>ident</code> function), and
replaces the <strong>data</strong> in the tree with its ident.</p>
</div>
<div class="paragraph">
<p>Once you realize that the query <strong>and</strong> the ident work together to do normalization, you can more easily
figure out what mistakes you might make that could cause auto-normalization to fail (e.g. stealing a query from
one component and placing it on another, writing the query of a sub-component by-hand instead of pulling it
with <code>get-query</code>, etc.).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_review_so_far"><a class="anchor" href="#_review_so_far"></a><a class="link" href="#_review_so_far">3.10. Review So Far</a></h3>
<div class="ulist">
<ul>
<li>
<p>An initial app state sets up a tree of data for startup to match the UI tree.</p>
</li>
<li>
<p>Component query and ident are used to normalize this initial data into the database.</p>
</li>
<li>
<p>The query is used to pull data from the normalized db into the props of the active Root UI.</p>
</li>
<li>
<p>Transactions invoke abstract mutations.</p>
<div class="ulist">
<ul>
<li>
<p>Mutations modify the (normalized) db.</p>
</li>
<li>
<p>Fulcro and React manage the UI to do a minimal refresh.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_using_better_tools"><a class="anchor" href="#_using_better_tools"></a><a class="link" href="#_using_better_tools">3.11. Using Better Tools</a></h3>
<div class="paragraph">
<p>So far we&#8217;ve been hacking things in place and using the REPL to watch what we&#8217;re doing. There are better ways to work
on Fulcro applications, and now that we&#8217;ve got one basically working, let&#8217;s take a look at them both.</p>
</div>
<div class="sect3">
<h4 id="_fulcro_inspect"><a class="anchor" href="#_fulcro_inspect"></a><a class="link" href="#_fulcro_inspect">3.11.1. Fulcro Inspect</a></h4>
<div class="paragraph">
<p>We&#8217;ve mentioned this before, but now that you know about the centralized database, we want to mention it again: Use it!
The DB tab of this tool shows you your application&#8217;s database <strong>and</strong> has a time slider to see the history of states.  It also
has tabs for showing you transactions that have run, and network interactions. See the tool&#8217;s documentation for more
information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_workspaces"><a class="anchor" href="#_workspaces"></a><a class="link" href="#_workspaces">3.11.2. Workspaces</a></h4>
<div class="paragraph">
<p>The <a href="https://github.com/nubank/workspaces">Workspaces library</a> allows you to start up a development environment where you can
code components, full-stack elements, or even entire applications in a flexible environment.
Remember, we can actually split off chunks of the application because they are all fed data via a normalized database
and coupled only to their parent.</p>
</div>
<div class="paragraph">
<p>Setting up an alternate build for creating sections of your application in isolation can be a real productivity
boost.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="GoingRemote"><a class="anchor" href="#GoingRemote"></a><a class="link" href="#GoingRemote">3.12. Going Remote!</a></h3>
<div class="paragraph">
<p>OK, back to the main story!</p>
</div>
<div class="paragraph">
<p>Believe it or not, there&#8217;s not much to add/change on the client to get it talking
to a server, and there is also a relatively painless way to get a server up and
running.</p>
</div>
<div class="sect3">
<h4 id="_the_communication"><a class="anchor" href="#_the_communication"></a><a class="link" href="#_the_communication">3.12.1. The Communication</a></h4>
<div class="paragraph">
<p>Fulcro uses <a href="https://github.com/cognitect/transit-clj">transit</a> as the over-the-wire protocol for network requests. There
is on API endpoint, and an EQL parser on the server will process the requests and return responses.  The overall
network interaction story is essentially just EQL requests and responses.</p>
</div>
<div class="paragraph">
<p>We recommend using Pathom to process the EQL on the server, and we&#8217;ll set up a simple Pathom parser for our application&#8217;s
server.</p>
</div>
<div class="paragraph">
<p>Add this to your deps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">com.wsscode/pathom     {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">2.2.15</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and create the file <code>src/main/app/parser.clj</code> with this content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.parser</span>
  (<span class="symbol">:require</span>
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [taoensso.timbre <span class="symbol">:as</span> log]))

(<span class="keyword">def</span> <span class="function">resolvers</span> [])

(<span class="keyword">def</span> <span class="function">pathom-parser</span>
  (p/parser {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>                 [p/map-reader
                                                      pc/reader2
                                                      pc/ident-reader
                                                      pc/index-reader]
                          <span class="symbol">::pc/mutation-join-globals</span> [<span class="symbol">:tempids</span>]}
             <span class="symbol">::p/mutate</span>  pc/mutate
             <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> resolvers})
                          p/error-handler-plugin]}))

(<span class="keyword">defn</span> <span class="function">api-parser</span> [query]
  (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Process</span><span class="delimiter">&quot;</span></span> query)
  (pathom-parser {} query))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_a_server"><a class="anchor" href="#_setting_up_a_server"></a><a class="link" href="#_setting_up_a_server">3.12.2. Setting up a Server</a></h4>
<div class="paragraph">
<p>To run a server you&#8217;ll first need something that implements the core HTTP stuff, and some bits of glue. The standard for
this in Clojure is Ring, and a common easy-to-use HTTP server is <code>http-kit</code>.</p>
</div>
<div class="paragraph">
<p>Open your <code>deps.edn</code> file and add dependencies so it looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:paths</span>   [<span class="string"><span class="delimiter">&quot;</span><span class="content">src/main</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">resources</span><span class="delimiter">&quot;</span></span>]
 <span class="symbol">:deps</span>    {org.clojure/clojure    {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1.10.1</span><span class="delimiter">&quot;</span></span>}
           com.fulcrologic/fulcro {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">3.0.0-alpha-18</span><span class="delimiter">&quot;</span></span>}
           com.wsscode/pathom     {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">2.2.15</span><span class="delimiter">&quot;</span></span>}
           ring/ring-core         {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1.6.3</span><span class="delimiter">&quot;</span></span>}
           http-kit               {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">2.3.0</span><span class="delimiter">&quot;</span></span>}}

 <span class="symbol">:aliases</span> {<span class="symbol">:dev</span> {<span class="symbol">:extra-paths</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">src/dev</span><span class="delimiter">&quot;</span></span>]
                 <span class="symbol">:extra-deps</span>  {org.clojure/clojurescript {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1.10.520</span><span class="delimiter">&quot;</span></span>}
                               thheller/shadow-cljs      {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">2.8.40</span><span class="delimiter">&quot;</span></span>}
                               binaryage/devtools        {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">0.9.10</span><span class="delimiter">&quot;</span></span>}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then add a <code>src/main/app/server.clj</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.server</span>
  (<span class="symbol">:require</span>
    [app.parser <span class="symbol">:refer</span> [api-parser]]
    [org.httpkit.server <span class="symbol">:as</span> http]
    [com.fulcrologic.fulcro.server.api-middleware <span class="symbol">:as</span> server]
    [ring.middleware.content-type <span class="symbol">:refer</span> [wrap-content-type]]
    [ring.middleware.resource <span class="symbol">:refer</span> [wrap-resource]]))

(<span class="keyword">def</span> ^<span class="symbol">:private</span> not-found-handler
  (<span class="keyword">fn</span> [req]
    {<span class="symbol">:status</span>  <span class="integer">404</span>
     <span class="symbol">:headers</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">Content-Type</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain</span><span class="delimiter">&quot;</span></span>}
     <span class="symbol">:body</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">Not Found</span><span class="delimiter">&quot;</span></span>}))

(<span class="keyword">def</span> <span class="function">middleware</span>
  (<span class="keyword">-&gt;</span> not-found-handler                                     <span class="comment">; </span><b class="conum">(1)</b>
    (server/wrap-api {<span class="symbol">:uri</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span>
                      <span class="symbol">:parser</span> api-parser})                  <span class="comment">; </span><b class="conum">(2)</b>
    (server/wrap-transit-params)
    (server/wrap-transit-response)
    (wrap-resource <span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>)                                <span class="comment">; </span><b class="conum">(3)</b>
    wrap-content-type))

(<span class="keyword">defonce</span> <span class="function">stop-fn</span> (<span class="keyword">atom</span> <span class="predefined-constant">nil</span>))

(<span class="keyword">defn</span> <span class="function">start</span> []
  (<span class="keyword">reset!</span> stop-fn (http/run-server middleware {<span class="symbol">:port</span> <span class="integer">3000</span>})))

(<span class="keyword">defn</span> <span class="function">stop</span> []
  (<span class="keyword">when</span> @stop-fn
    (@stop-fn)
    (<span class="keyword">reset!</span> stop-fn <span class="predefined-constant">nil</span>)))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The middleware stack ends at a not found handler</p>
</li>
<li>
<p>The <code>wrap-api</code> middleware from Fulcro, along with transit in/out encode/decode.</p>
</li>
<li>
<p>Resource serving (to get our index.html file) and set the content type correctly.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_running_the_server"><a class="anchor" href="#_running_the_server"></a><a class="link" href="#_running_the_server">3.12.3. Running the Server</a></h4>
<div class="paragraph">
<p>The Clojure REPL will automatically start in the <code>user</code> namespace.  During development we can leverage that to
make our lives a little easier. One thing we&#8217;ll commonly want to do it refresh our server when we make code changes.</p>
</div>
<div class="paragraph">
<p>So, we should add a little more to our project.  First, code reloading tools in <code>deps.edn</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:paths</span>   [<span class="string"><span class="delimiter">&quot;</span><span class="content">src/main</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">resources</span><span class="delimiter">&quot;</span></span>]
 <span class="symbol">:deps</span>    {org.clojure/clojure    {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1.10.1</span><span class="delimiter">&quot;</span></span>}
           com.fulcrologic/fulcro {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">3.0.0-alpha-18</span><span class="delimiter">&quot;</span></span>}
           com.wsscode/pathom     {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">2.2.15</span><span class="delimiter">&quot;</span></span>}
           ring/ring-core         {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1.6.3</span><span class="delimiter">&quot;</span></span>}
           http-kit               {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">2.3.0</span><span class="delimiter">&quot;</span></span>}}

 <span class="symbol">:aliases</span> {<span class="symbol">:dev</span> {<span class="symbol">:extra-paths</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">src/dev</span><span class="delimiter">&quot;</span></span>]
                 <span class="symbol">:extra-deps</span>  {org.clojure/clojurescript   {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1.10.520</span><span class="delimiter">&quot;</span></span>}
                               thheller/shadow-cljs        {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">2.8.40</span><span class="delimiter">&quot;</span></span>}
                               binaryage/devtools          {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">0.9.10</span><span class="delimiter">&quot;</span></span>}
                               org.clojure/tools.namespace {<span class="symbol">:mvn/version</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">0.2.11</span><span class="delimiter">&quot;</span></span>}}}}} <span class="comment">; </span><b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Tools for reloading namespaces at runtime.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>and we only want our "development" mode to see our <code>user.clj</code> file, so we&#8217;ll put it in the alternate dev
source path <code>src/dev/user.clj</code>:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
This file goes in <code>src/dev</code>, not <code>src/main</code>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">user</span>
  (<span class="symbol">:require</span>
    [app.server <span class="symbol">:as</span> server]
    [clojure.tools.namespace.repl <span class="symbol">:as</span> tools-ns <span class="symbol">:refer</span> [set-refresh-dirs refresh]]))

<span class="comment">;; Ensure we only refresh the source we care about. This is important</span>
<span class="comment">;; because `resources` is on our classpath and we don't want to</span>
<span class="comment">;; accidentally pull source from there when cljs builds cache files there.</span>
(set-refresh-dirs <span class="string"><span class="delimiter">&quot;</span><span class="content">src/dev</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">src/main</span><span class="delimiter">&quot;</span></span>)

(<span class="keyword">defn</span> <span class="function">start</span> []
  (server/start))

(<span class="keyword">defn</span> <span class="function">restart</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Stop the server, reload all source code, then restart the server.

  See documentation of tools.namespace.repl for more information.</span><span class="delimiter">&quot;</span></span>
  []
  (server/stop)
  (refresh <span class="symbol">:after</span> 'user/start))

<span class="comment">;; These are here so we can run them from the editor with kb shortcuts.  See IntelliJ's &quot;Send Top Form To REPL&quot; in</span>
<span class="comment">;; keymap settings.</span>
(<span class="keyword">comment</span>
  (start)
  (restart))</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Make sure the <code>dev</code> alias is enabled for Clojure when you run your REPL.  In IntelliJ this is in the
"Clojure Deps" tab, under "aliases". From the command line include <code>-A:dev</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you start the server with <code>(start)</code> you should be able to load <code><a href="http://localhost:3000/index.html" class="bare">http://localhost:3000/index.html</a></code>.  Note you must
specify the path because our server is quite literal at the moment.  It has no idea what "/" means.</p>
</div>
</div>
<div class="sect3">
<h4 id="_server_refresh"><a class="anchor" href="#_server_refresh"></a><a class="link" href="#_server_refresh">3.12.4. Server Refresh</a></h4>
<div class="paragraph">
<p>When you add/change code on the server you will want to see those changes in the live server without having to restart
your REPL. The additions we&#8217;ve made make this possible by just running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">user=&gt; (restart)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there are compiler errors, then the <code>user</code> namespace might not reload properly. In that case, you should be able
to recover using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">user=&gt; (tools-ns/refresh)
user=&gt; (start)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_queries"><a class="anchor" href="#_parsing_queries"></a><a class="link" href="#_parsing_queries">3.13. Parsing Queries</a></h3>
<div class="paragraph">
<p>Before we can obtain data from the server we have to understand a little bit about writing resolvers for Pathom.
Pathom is basically a library for building EQL parsers. The two critical things you define are called <strong>resolvers</strong>
and <strong>mutations</strong>.  The latter is pretty much identical to what you&#8217;ve already done in Fulcro, and at the moment
we&#8217;re primarily interested in satisfying some reads.  So let&#8217;s talk about resolvers.</p>
</div>
<div class="paragraph">
<p>Resolvers are defined to <strong>expect</strong> some particular inputs, and <strong>declare</strong> what they can produce.
They are always called with some context (stored in an <code>env</code> parameter) and some optional inputs that match
the expected inputs.  The context includes the portion of the query that is currently being parsed along with
a number of other things.  The idea
is that "given a context and some input" you should be able to write some code that can resolve the desired outputs.</p>
</div>
<div class="paragraph">
<p>In this chapter the following requires with aliases are assumed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="keyword">..</span><span class="keyword">.</span>
  (<span class="symbol">:require</span>
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a sample resolver:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver person-resolver [env input]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/name</span>]}
  (<span class="keyword">let</span> [<span class="keyword">name</span> (get-name-from-database (<span class="symbol">:person/id</span> input))]
    {<span class="symbol">:person/name</span> <span class="keyword">name</span>}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>it declares "Given a <code>:person/id</code> as input, I can produce their name". The inputs are written as a set, and the output
is written as an EQL query.  The body of the function will find the required input in the <code>input</code> parameter, and must
return an EQL response that matches the shape of the declared <code>::pc/output</code>.</p>
</div>
<div class="paragraph">
<p>Furthermore, the <strong>output</strong> of a resolver augments the known context that Pathom is working with, and can be used to
chain lookups across resolvers to fulfill a complete query.</p>
</div>
<div class="paragraph">
<p>For the sake of our examples we&#8217;re going to hand-generate a server-side database in simple maps so that you
can concentrate on the code of interest instead of boilerplate database initialization and queries.</p>
</div>
<div class="paragraph">
<p>Add a <code>src/main/app/resolvers.clj</code> file with this content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.resolvers</span>
  (<span class="symbol">:require</span>
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

(<span class="keyword">def</span> <span class="function">people-table</span>
  {<span class="integer">1</span> {<span class="symbol">:person/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">32</span>}
   <span class="integer">2</span> {<span class="symbol">:person/id</span> <span class="integer">2</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">22</span>}
   <span class="integer">3</span> {<span class="symbol">:person/id</span> <span class="integer">3</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">11</span>}
   <span class="integer">4</span> {<span class="symbol">:person/id</span> <span class="integer">4</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">55</span>}})

(<span class="keyword">def</span> <span class="function">list-table</span>
  {<span class="symbol">:friends</span> {<span class="symbol">:list/id</span>     <span class="symbol">:friends</span>
             <span class="symbol">:list/label</span>  <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>
             <span class="symbol">:list/people</span> [<span class="integer">1</span> <span class="integer">2</span>]}
   <span class="symbol">:enemies</span> {<span class="symbol">:list/id</span>     <span class="symbol">:enemies</span>
             <span class="symbol">:list/label</span>  <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>
             <span class="symbol">:list/people</span> [<span class="integer">4</span> <span class="integer">3</span>]}})

<span class="comment">;; Given :person/id, this can generate the details of a person</span>
(pc/defresolver person-resolver [env {<span class="symbol">:person/keys</span> [id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/name</span> <span class="symbol">:person/age</span>]}
  (<span class="keyword">get</span> people-table id))

<span class="comment">;; Given a :list/id, this can generate a list label and the people</span>
<span class="comment">;; in that list (but just with their IDs)</span>
(pc/defresolver list-resolver [env {<span class="symbol">:list/keys</span> [id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:list/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:list/label</span> {<span class="symbol">:list/people</span> [<span class="symbol">:person/id</span>]}]}
  (<span class="keyword">when-let</span> [<span class="keyword">list</span> (<span class="keyword">get</span> list-table id)]
    (<span class="keyword">assoc</span> <span class="keyword">list</span>
      <span class="symbol">:list/people</span> (mapv (<span class="keyword">fn</span> [id] {<span class="symbol">:person/id</span> id}) (<span class="symbol">:list/people</span> <span class="keyword">list</span>)))))

(<span class="keyword">def</span> <span class="function">resolvers</span> [person-resolver list-resolver])</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then add these resolvers into the <code>parser.clj</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.parser</span>
  (<span class="symbol">:require</span>
    [app.resolvers]
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

(<span class="keyword">def</span> <span class="function">resolvers</span> [app.resolvers/resolvers])

<span class="keyword">..</span><span class="keyword">.</span> as before</code></pre>
</div>
</div>
<div class="paragraph">
<p>These two resolvers already give you a lot of power.  We&#8217;ve been following a convention for some time of giving
idents the "table name" of the ID field.  This is because Pathom can treat an ident as "context" for determining
which resolver to run.</p>
</div>
<div class="paragraph">
<p>It turns out that EQL will allow an <em>ident</em> to be used as a <strong>join key</strong> to establish a particular graph context (i.e.
pretend we&#8217;re on the node with the given ident):
:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{[<span class="symbol">:person/id</span> <span class="integer">3</span>] [<span class="symbol">:person/name</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you load the parser namespace you can try these out in a CLJ REPL (e.g. <code>clj -A:dev</code> at the command line):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">require</span> 'app.parser)

(app.parser/api-parser [{[<span class="symbol">:list/id</span> <span class="symbol">:friends</span>] [<span class="symbol">:list/id</span>]}])
=&gt; {[<span class="symbol">:list/id</span> <span class="symbol">:friends</span>] {<span class="symbol">:list/id</span> <span class="symbol">:friends</span>}}

(app.parser/api-parser [{[<span class="symbol">:person/id</span> <span class="integer">1</span>] [<span class="symbol">:person/name</span>]}])
=&gt; {[<span class="symbol">:person/id</span> <span class="integer">1</span>] {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>}}

(app.parser/api-parser [{[<span class="symbol">:list/id</span> <span class="symbol">:friends</span>] [<span class="symbol">:list/id</span> {<span class="symbol">:list/people</span> [<span class="symbol">:person/name</span>]}]}])
=&gt; {[<span class="symbol">:list/id</span> <span class="symbol">:friends</span>] {<span class="symbol">:list/id</span> <span class="symbol">:friends</span>, <span class="symbol">:list/people</span> [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>} {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>}]}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pathom&#8217;s magic is that it can traverse the graph based on the declared inputs and outputs. The fact that the list
resolver says it outputs <code>:person/id</code> means that Pathom can "connect the dots" to fill in details of that person.</p>
</div>
<div class="paragraph">
<p>Those two resolvers make it possible for us to execute all of the arbitrary queries we&#8217;d need to feed data to
our application at any level!</p>
</div>
<div class="paragraph">
<p>It is also possible to define resolvers that don&#8217;t require any inputs at all.  These "global resolvers" are
the same as "root queries" in GraphQL.  We could use one of these for our application, so add this
to your <code>resolvers.clj</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="keyword">..</span><span class="keyword">.</span>

(pc/defresolver friends-resolver [env input]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:friends</span> [<span class="symbol">:list/id</span>]}]}
  {<span class="symbol">:friends</span> {<span class="symbol">:list/id</span> <span class="symbol">:friends</span>}})

(pc/defresolver enemies-resolver [env input]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:enemies</span> [<span class="symbol">:list/id</span>]}]}
  {<span class="symbol">:enemies</span> {<span class="symbol">:list/id</span> <span class="symbol">:enemies</span>}})

<span class="comment">;; Make sure you add the two resolvers into the list</span>
(<span class="keyword">def</span> <span class="function">resolvers</span> [person-resolver list-resolver friends-resolver enemies-resolver])</code></pre>
</div>
</div>
<div class="paragraph">
<p>and now if you reload the code in your REPL you should be able to run a query like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(app.parser/api-parser [{<span class="symbol">:friends</span> [<span class="symbol">:list/id</span> {<span class="symbol">:list/people</span> [<span class="symbol">:person/name</span>]}]}])
=&gt; {<span class="symbol">:friends</span> {<span class="symbol">:list/id</span> <span class="symbol">:friends</span>, <span class="symbol">:list/people</span> [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>} {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>}]}}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="Loading"><a class="anchor" href="#Loading"></a><a class="link" href="#Loading">3.13.1. Loading Data</a></h4>
<div class="paragraph">
<p>At this point we&#8217;ve actually got everything we need on the server to handle incoming load
requests from the client.</p>
</div>
<div class="paragraph">
<p>In your <strong>clojure</strong> REPL, use <code>(restart)</code> to stop/reload/start the server. If everything went OK you&#8217;ve got a
server that can satisfy client queries.</p>
</div>
<div class="paragraph">
<p>Now we will start to see more of the payoff of our UI co-located queries and auto-normalization. Our application
so far is quite unrealistic: the lists of people we&#8217;re showing should be coming from a server-side database, they
should not be embedded in the code of the client. Let&#8217;s remedy that.</p>
</div>
<div class="paragraph">
<p>Fulcro provides a few mechanisms for loading data, but most important load scenarios can be done using
the <code>com.fulcrologic.fulcro.data-fetch/load!</code> function.</p>
</div>
<div class="paragraph">
<p>It is very important to remember that our application database is completely normalized, so anything we&#8217;d want to put
in that application state will be <strong>at most</strong> 3 levels deep (the table name, the ID of the thing in the table, and the
field within that thing). We&#8217;ve also seen that Fulcro can also auto-normalize complete trees of data,
and has graph queries that can be used to ask for those trees.</p>
</div>
<div class="paragraph">
<p>Thus, there really are not very many scenarios!</p>
</div>
<div class="paragraph">
<p>The three basic scenarios are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Load something into the root of the application state (root prop).</p>
</li>
<li>
<p>Load a tree and normalize it into tables.</p>
</li>
<li>
<p>Target a loaded tree to "start" at some specific edge in the graph.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s try out these different scenarios with our application.</p>
</div>
<div class="paragraph">
<p>First, get rid of the application&#8217;s initial state</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span>
    [app.mutations <span class="symbol">:as</span> api]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

(defsc Person [this {<span class="symbol">:person/keys</span> [id <span class="keyword">name</span> age] <span class="symbol">:as</span> props} {<span class="symbol">:keys</span> [onDelete]}]
  {<span class="symbol">:query</span> [<span class="symbol">:person/id</span> <span class="symbol">:person/name</span> <span class="symbol">:person/age</span>]
   <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] [<span class="symbol">:person/id</span> (<span class="symbol">:person/id</span> props)])}
  (dom/li
    (dom/h5 (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content"> (age: </span><span class="delimiter">&quot;</span></span> age <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>) (dom/button {<span class="symbol">:onClick</span> #(onDelete id)} <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>)))) <span class="comment">; </span><b class="conum">(4)</b>

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:person/id</span>}))

(defsc PersonList [this {<span class="symbol">:list/keys</span> [id label people] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span> [<span class="symbol">:list/id</span> <span class="symbol">:list/label</span> {<span class="symbol">:list/people</span> (comp/get-query Person)}]
   <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] [<span class="symbol">:list/id</span> (<span class="symbol">:list/id</span> props)])}
  (<span class="keyword">let</span> [delete-person (<span class="keyword">fn</span> [person-id] (comp/transact! this [(api/delete-person {<span class="symbol">:list/id</span> id <span class="symbol">:person/id</span> person-id})]))] <span class="comment">; </span><b class="conum">(2)</b>
    (dom/div
      (dom/ul
        (<span class="keyword">map</span> #(ui-person (comp/computed % {<span class="symbol">:onDelete</span> delete-person})) people)))))

(<span class="keyword">def</span> <span class="function">ui-person-list</span> (comp/factory PersonList))

(defsc Root [this {<span class="symbol">:keys</span> [friends enemies]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:friends</span> (comp/get-query PersonList)}
                   {<span class="symbol">:enemies</span> (comp/get-query PersonList)}]
   <span class="symbol">:initial-state</span> {}}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">when</span> friends
      (ui-person-list friends))
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">when</span> enemies
      (ui-person-list enemies))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also added a little "guard code" to test if data was missing so we don&#8217;t try to render <code>nil</code> props.</p>
</div>
<div class="paragraph">
<p>If you now reload your page you should see two headings, but no people.</p>
</div>
<div class="sect4">
<h5 id="_loading_something_into_the_db_root"><a class="anchor" href="#_loading_something_into_the_db_root"></a><a class="link" href="#_loading_something_into_the_db_root">Loading something into the DB root</a></h5>
<div class="paragraph">
<p>Our application has two root-level things that we&#8217;d like to load.
Loads, of course, can be triggered at any time (startup, event, timeout). Loading is just a function call.</p>
</div>
<div class="paragraph">
<p>For this example, let&#8217;s trigger the load just after the application has started, and load our friends
and enemies.</p>
</div>
<div class="paragraph">
<p>Open the <code>app.application</code> namespace and add remote support:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.application</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.application <span class="symbol">:as</span> app]
    [com.fulcrologic.fulcro.networking.http-remote <span class="symbol">:as</span> http]))

(<span class="keyword">defonce</span> <span class="function">app</span> (app/fulcro-app
               {<span class="symbol">:remotes</span> {<span class="symbol">:remote</span> (http/fulcro-http-remote {})}}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then go to <code>client.cljs</code> and add our initial load during application startup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.client</span>
  (<span class="symbol">:require</span>
    [app.application <span class="symbol">:refer</span> [app]]
    [app.ui <span class="symbol">:as</span> ui]
    [com.fulcrologic.fulcro.application <span class="symbol">:as</span> app]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]))

(<span class="keyword">defn</span> ^<span class="symbol">:export</span> init []
  (app/mount! app ui/Root <span class="string"><span class="delimiter">&quot;</span><span class="content">app</span><span class="delimiter">&quot;</span></span>)
  (df/load! app <span class="symbol">:friends</span> ui/PersonList)
  (df/load! app <span class="symbol">:enemies</span> ui/PersonList)
  (js/console.log <span class="string"><span class="delimiter">&quot;</span><span class="content">Loaded</span><span class="delimiter">&quot;</span></span>))

<span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course hot code reload does not restart the app (it just hot patches the code), so to see this load trigger we must
reload the browser page.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Make sure your application is running from <strong>your</strong> server (port 3000), and not the dev server.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Technically, <code>load!</code> is just writing a query for you (in this case <code>[{:friends (comp/get-query PersonList)}]</code>) and sending it to the
server. The server will receive <strong>exactly</strong> that query as a CLJ data structure.</p>
</div>
</div>
<div class="sect4">
<h5 id="_loading_a_specific_entity_and_its_subgraph_by_ident"><a class="anchor" href="#_loading_a_specific_entity_and_its_subgraph_by_ident"></a><a class="link" href="#_loading_a_specific_entity_and_its_subgraph_by_ident">Loading a specific entity and its subgraph (by ident)</a></h5>
<div class="paragraph">
<p>Once things are loaded from the server they are immediately growing stale (unless you&#8217;re pushing updates with
websockets). It is very common to want to re-load a particular thing in your database. Of course, you can trigger
a load just like we&#8217;ve been doing, but in that case we would be reloading a whole bunch of things. What if we just wanted to
refresh a particular person (e.g. in preparation for editing it).</p>
</div>
<div class="paragraph">
<p>The <code>load!</code> function can be used for that as well. Just replace the keyword with an ident, and you&#8217;re there!</p>
</div>
<div class="paragraph">
<p>Load can take the <code>app</code> or any component&#8217;s <code>this</code> as the first argument, so from within the UI we can trigger a load
using <code>this</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load this [<span class="symbol">:person/id</span> <span class="integer">3</span>] Person)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_adding_edges"><a class="anchor" href="#_adding_edges"></a><a class="link" href="#_adding_edges">Adding Edges</a></h5>
<div class="paragraph">
<p>There are a number of ways to "add edges" to the UI data graph when loading. The most common is to use the <code>:target</code> option
of <code>load!</code>.  This option indicates that the incoming data should be "joined" into the graph as a given edge (the default
is to link it to the root node).</p>
</div>
<div class="paragraph">
<p>So, you could add an arbitrary person the the friends list like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load! this [<span class="symbol">:person/id</span> <span class="integer">3</span>] Person {<span class="symbol">:target</span> (targeting/append-to [<span class="symbol">:list/id</span> <span class="symbol">:friends</span> <span class="symbol">:list/people</span>])})</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Targets are just graph database paths. The <code>append-to</code> modifier comes from the <code>com.fulcrologic.fulcro.algorithms.data-targeting</code>
namespace and will append the edge to a to-many relation if (and only if) it isn&#8217;t already there. Remember, any edge is
reachable in our database by a path that is at most three elements long (table, id, field).
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_additional_permutations"><a class="anchor" href="#_additional_permutations"></a><a class="link" href="#_additional_permutations">Additional Permutations</a></h5>
<div class="paragraph">
<p>Fulcro&#8217;s load system covers a number of additional bases that bring the story to completion. There are load markers
(so you can show network activity), server query parameters, error handling, and more. Read the corresponding chapters
in this guide for more details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handling_mutations_on_the_server"><a class="anchor" href="#_handling_mutations_on_the_server"></a><a class="link" href="#_handling_mutations_on_the_server">3.13.2. Handling Mutations on The Server</a></h4>
<div class="paragraph">
<p>Mutations can be handled on the server using Pathom&#8217;s <code>defmutation</code> macro.</p>
</div>
<div class="paragraph">
<p>This has a nearly-identical syntax to the client Fulcro macro of the same name.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
You want to place your mutations in the same namespace on the client and server since the <code>defmutation</code>
macros namespace the symbol into the current namespace. The Pathom <code>defmutation</code> actually lets you override
what symbol it responds to, so this is not absolutely necessary.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So, let&#8217;s add an implementation for our server-side <code>delete-person</code>.</p>
</div>
<div class="paragraph">
<p>First, we need to modify our database tables so we can change them.  Modify the <code>resolvers.clj</code> to be this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.resolvers</span>
  (<span class="symbol">:require</span>
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

(<span class="keyword">def</span> <span class="function">people-table</span>
  <span class="comment">;; changed to an atom so we can update thes &quot;databases&quot;</span>
  (<span class="keyword">atom</span>
    {<span class="integer">1</span> {<span class="symbol">:person/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">32</span>}
     <span class="integer">2</span> {<span class="symbol">:person/id</span> <span class="integer">2</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">22</span>}
     <span class="integer">3</span> {<span class="symbol">:person/id</span> <span class="integer">3</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Fred</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">11</span>}
     <span class="integer">4</span> {<span class="symbol">:person/id</span> <span class="integer">4</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bobby</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">55</span>}}))

(<span class="keyword">def</span> <span class="function">list-table</span>
  (<span class="keyword">atom</span>
    {<span class="symbol">:friends</span> {<span class="symbol">:list/id</span>     <span class="symbol">:friends</span>
               <span class="symbol">:list/label</span>  <span class="string"><span class="delimiter">&quot;</span><span class="content">Friends</span><span class="delimiter">&quot;</span></span>
               <span class="symbol">:list/people</span> [<span class="integer">1</span> <span class="integer">2</span>]}
     <span class="symbol">:enemies</span> {<span class="symbol">:list/id</span>     <span class="symbol">:enemies</span>
               <span class="symbol">:list/label</span>  <span class="string"><span class="delimiter">&quot;</span><span class="content">Enemies</span><span class="delimiter">&quot;</span></span>
               <span class="symbol">:list/people</span> [<span class="integer">4</span> <span class="integer">3</span>]}}))

<span class="comment">;; Given :person/id, this can generate the details of a person</span>
(pc/defresolver person-resolver [env {<span class="symbol">:person/keys</span> [id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/name</span> <span class="symbol">:person/age</span>]}
  (<span class="keyword">get</span> @people-table id))

<span class="comment">;; Given a :list/id, this can generate a list label and the people</span>
<span class="comment">;; in that list (but just with their IDs)</span>
(pc/defresolver list-resolver [env {<span class="symbol">:list/keys</span> [id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:list/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:list/label</span> {<span class="symbol">:list/people</span> [<span class="symbol">:person/id</span>]}]}
  (<span class="keyword">when-let</span> [<span class="keyword">list</span> (<span class="keyword">get</span> @list-table id)]
    (<span class="keyword">assoc</span> <span class="keyword">list</span>
      <span class="symbol">:list/people</span> (mapv (<span class="keyword">fn</span> [id] {<span class="symbol">:person/id</span> id}) (<span class="symbol">:list/people</span> <span class="keyword">list</span>)))))

(pc/defresolver friends-resolver [env input]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:friends</span> [<span class="symbol">:list/id</span>]}]}
  {<span class="symbol">:friends</span> {<span class="symbol">:list/id</span> <span class="symbol">:friends</span>}})

(pc/defresolver enemies-resolver [env input]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:enemies</span> [<span class="symbol">:list/id</span>]}]}
  {<span class="symbol">:enemies</span> {<span class="symbol">:list/id</span> <span class="symbol">:enemies</span>}})

(<span class="keyword">def</span> <span class="function">resolvers</span> [person-resolver list-resolver friends-resolver enemies-resolver])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then create <code>src/main/app/mutations.clj</code> and add this code to it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.mutations</span>
  (<span class="symbol">:require</span>
    [app.resolvers <span class="symbol">:refer</span> [list-table]]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [taoensso.timbre <span class="symbol">:as</span> log]))

(pc/defmutation delete-person [env {list-id   <span class="symbol">:list/id</span>
                                    person-id <span class="symbol">:person/id</span>}]
  <span class="comment">;; optional, this is how you override what symbol it responds to.  Defaults to current ns.</span>
  {<span class="symbol">::pc/sym</span> `delete-person}
  (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Deleting person</span><span class="delimiter">&quot;</span></span> person-id <span class="string"><span class="delimiter">&quot;</span><span class="content">from list</span><span class="delimiter">&quot;</span></span> list-id)
  (<span class="keyword">swap!</span> list-table update list-id update <span class="symbol">:list/people</span> (<span class="keyword">fn</span> [old-list] (filterv #(<span class="keyword">not</span><span class="keyword">=</span> person-id %) old-list))))

(<span class="keyword">def</span> <span class="function">mutations</span> [delete-person])</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then modify <code>parser.clj</code> to require and include the mutations in the overall list of pathom resolvers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.parser</span>
  (<span class="symbol">:require</span>
    [app.resolvers]
    [app.mutations] <span class="comment">; &lt;----- add this</span>
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [taoensso.timbre <span class="symbol">:as</span> log]))

(<span class="keyword">def</span> <span class="function">resolvers</span> [app.resolvers/resolvers app.mutations/mutations]) &lt;---- add to this

<span class="comment">;; no other changes</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Refresh the code on your server with <code>(restart)</code> at the REPL; However, don&#8217;t expect it to work just yet. We have
to tell the client to send the remote request.</p>
</div>
<div class="sect4">
<h5 id="_triggering_the_remote_mutation_from_the_client"><a class="anchor" href="#_triggering_the_remote_mutation_from_the_client"></a><a class="link" href="#_triggering_the_remote_mutation_from_the_client">Triggering the Remote Mutation from the Client</a></h5>
<div class="paragraph">
<p>Mutations are simply optimistic local updates by default. To make them full-stack, you need to add a method-looking
section to your <code>defmutation</code> handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation delete-person
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Mutation: Delete the person with `:person/id` from the list with `:list/id`</span><span class="delimiter">&quot;</span></span>
  [{list-id <span class="symbol">:list/id</span>
    person-id <span class="symbol">:person/id</span>}]
  (action [{<span class="symbol">:keys</span> [state]}] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [env] <span class="predefined-constant">true</span>)) <span class="comment">; This one line is it!!!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax for the addition is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(remote-name [env] boolean-or-ast-or-env)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>remote</code> is the name of a remote server (the default is <code>remote</code>). You can have any number of network remotes.
The default one talks to the
page origin at <code>/api</code>. What is this AST we speak of? It is the abstract syntax tree of the mutation itself (as data).
Using a boolean true means "send it just as the client specified". If you wish you can pull the AST from the <code>env</code>,
augment it (or completely change it) and return that instead.</p>
</div>
<div class="paragraph">
<p>Now that you&#8217;ve got the UI in place, try deleting a person. It should disappear from the UI as it did before; however,
now if you&#8217;re watching the network you&#8217;ll see a request to the server. If you server is working right, it will handle
the delete.</p>
</div>
<div class="paragraph">
<p>Try reloading your page from the server. That person should still be missing, indicating that it really was removed
from the server.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wrapping_up"><a class="anchor" href="#_wrapping_up"></a><a class="link" href="#_wrapping_up">3.14. Wrapping Up</a></h3>
<div class="paragraph">
<p>At this point you&#8217;ve gotten more detailed view of what a Fulcro application looks like.  The remaining chapters of this
book go into considerably more detail about each important part of the API.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_components_and_rendering"><a class="anchor" href="#_components_and_rendering"></a><a class="link" href="#_components_and_rendering">4. Components and Rendering</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_html5_element_factories"><a class="anchor" href="#_html5_element_factories"></a><a class="link" href="#_html5_element_factories">4.1. HTML5 Element Factories</a></h3>
<div class="paragraph">
<p>The core HTML5 elements all have simple factory functions that
generate the core elements that stand-in for the real DOM.
These stand-ins (commonly referred to as the virtual DOM or VDOM)
are ultimately what React uses to generate, diff, and update the real DOM.</p>
</div>
<div class="paragraph">
<p>So, there are functions for every possible HTML5 element. These are in the
<code>com.fulcrologic.fulcro.dom</code> namespace.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

<span class="keyword">..</span><span class="keyword">.</span>

(dom/div <span class="symbol">:.</span>some-class
  (dom/ul {<span class="symbol">:style</span> {<span class="symbol">:color</span> <span class="symbol">:red</span>}}
    (dom/li <span class="keyword">..</span><span class="keyword">.</span>)))</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If you&#8217;re writing your UI in CLJC files then you need to make sure you use a conditional
reader to pull in the proper server DOM functions for Clojure:
<code>(ns app.ui (:require #?(:clj [com.fulcrologic.fulcro.dom-server :as dom] :cljs [fulcro.client.dom :as dom]))</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The notation allowed is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello</span><span class="delimiter">&quot;</span></span>) <span class="comment">; no props</span>
(dom/div <span class="predefined-constant">nil</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello</span><span class="delimiter">&quot;</span></span>) <span class="comment">; nil props (may perform slightly better)</span>
(dom/div <span class="error">#</span>js {<span class="symbol">:data-x</span> <span class="integer">1</span>} <span class="keyword">..</span><span class="keyword">.</span>) <span class="comment">; js objects are allowed</span>
(dom/div <span class="symbol">:.</span>cls.cls2#id <span class="keyword">..</span><span class="keyword">.</span>) <span class="comment">; shorthand for specifying static classes and ID</span>
(dom/div <span class="symbol">:.</span>cls {<span class="symbol">:data-x</span> <span class="integer">2</span>} <span class="string"><span class="delimiter">&quot;</span><span class="content">Ho</span><span class="delimiter">&quot;</span></span>) <span class="comment">; shorthand + props</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a <code>:classes</code> property that can be used to add (typically via expressions) additional
classes. It drops nil, and allows classname keywords and strings as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(dom/div <span class="symbol">:.</span>a {<span class="symbol">:className</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">other</span><span class="delimiter">&quot;</span></span> <span class="symbol">:classes</span> [(<span class="keyword">when</span> hidden <span class="string"><span class="delimiter">&quot;</span><span class="content">hidden</span><span class="delimiter">&quot;</span></span>) (<span class="keyword">if</span> tall <span class="symbol">:.</span>tall <span class="symbol">:.</span><span class="keyword">short</span>)]} <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming <code>hidden</code> and <code>(not tall)</code> would yield classes "a other hidden short" on output. Of course you probably don&#8217;t need
all of these at once, but supporting them all lets you programmatically combine them when generating props. NOTE: This feature
does not work on props sent with <code>#js</code> notation.</p>
</div>
<div class="paragraph">
<p>Remember that this (nested) call of functions results in a representation (React Elements) of
what you&#8217;d like to end up on the screen.</p>
</div>
<div class="paragraph">
<p>The next level of abstraction is simply a function.
Combining more complex bits of UI into a function is a great way to group
re-usable nested DOM:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">my-header</span> []
  (dom/div <span class="symbol">:.</span>some-class
    (dom/ul
      (dom/li <span class="keyword">..</span><span class="keyword">.</span>))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>but remember that a function has no component hooks, so it cannot do things like short-circuit rendering when props
have not changed.</p>
</div>
<div class="sect3">
<h4 id="_fulcro_and_react_dom_notes"><a class="anchor" href="#_fulcro_and_react_dom_notes"></a><a class="link" href="#_fulcro_and_react_dom_notes">4.1.1. Fulcro and React DOM – Notes</a></h4>
<div class="paragraph">
<p>Here are some common things you&#8217;ll want to know how to do that are different when rendering with Fulcro:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Attributes follow the react naming conventions for [Tags and Attributes](<a href="https://facebook.github.io/react/docs/tags-and-attributes.html" class="bare">https://facebook.github.io/react/docs/tags-and-attributes.html</a>)</p>
<div class="ulist">
<ul>
<li>
<p>As an example - CSS class names are specified with <code>:className</code> instead of <code>:class</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Any time an element includes a collection of children they should each have a unique <code>:key</code>
attribute. This helps the React diff figure out how that collection has changed. You will
get warnings in the browser console if you fail to do so.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_converting_html_to_fulcro"><a class="anchor" href="#_converting_html_to_fulcro"></a><a class="link" href="#_converting_html_to_fulcro">4.1.2. Converting HTML to Fulcro</a></h4>
<div class="paragraph">
<p>Below is a simple little live application that can convert valid HTML into the Clojure(script) you&#8217;d use
within a Fulcro component. Note that stray whitespace will be converted to (harmless) things like <code>" \n"</code> that can be easily
removed, and the output indentation isn&#8217;t ideal; Still, it turns the task into one of simple formatting:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. <a id="HTMLConverter"></a><a href="#HTMLConverter">HTML Converter</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('html-converter')">Focus Inspector</button>
<div class="short wide example" id="html-converter"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.html-converter</span>
  (<span class="symbol">:require</span>
    <span class="error">#</span>?(<span class="symbol">:cljs</span> [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
       <span class="symbol">:clj</span>  [com.fulcrologic.fulcro.dom-server <span class="symbol">:as</span> dom])
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.dom.html-entities <span class="symbol">:as</span> ent]
    [taoensso.timbre <span class="symbol">:as</span> log]
    [camel-snake-kebab.core <span class="symbol">:as</span> csk]
    [hickory.core <span class="symbol">:as</span> hc]
    [clojure.set <span class="symbol">:as</span> <span class="keyword">set</span>]
    [clojure.pprint <span class="symbol">:refer</span> [pprint]]
    [clojure.string <span class="symbol">:as</span> <span class="keyword">str</span>]))

(<span class="keyword">def</span> <span class="function">attr-renames</span> {<span class="symbol">:class</span>        <span class="symbol">:className</span>
                   <span class="symbol">:for</span>          <span class="symbol">:htmlFor</span>
                   <span class="symbol">:tabindex</span>     <span class="symbol">:tabIndex</span>
                   <span class="symbol">:viewbox</span>      <span class="symbol">:viewBox</span>
                   <span class="symbol">:spellcheck</span>   <span class="symbol">:spellcheck</span>
                   <span class="symbol">:autocorrect</span>  <span class="symbol">:autoCorrect</span>
                   <span class="symbol">:autocomplete</span> <span class="symbol">:autoComplete</span>})

(<span class="keyword">defn</span> <span class="function">fix-style</span> [style]
  (<span class="keyword">try</span>
    (<span class="keyword">let</span> [lines     (str/split style <span class="regexp"><span class="delimiter">#&quot;</span><span class="content">;</span><span class="delimiter">&quot;</span></span>)
          style-map (<span class="keyword">into</span> {} (<span class="keyword">map</span> (<span class="keyword">fn</span> [line]
                                    (<span class="keyword">let</span> [[k v] (str/split line <span class="regexp"><span class="delimiter">#&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>)]
                                      [(csk/-&gt;camelCase (<span class="keyword">keyword</span> k)) (str/trim v)])) lines))]

      style-map)
    (<span class="keyword">catch</span> <span class="error">#</span>?(<span class="symbol">:cljs</span> <span class="symbol">:default</span> <span class="symbol">:clj</span> Exception) e
      style)))

(<span class="keyword">defn</span> <span class="function">classes-&gt;keyword</span> [className]
  (<span class="keyword">when</span> (<span class="keyword">seq</span> (str/trim className))
    (<span class="keyword">let</span> [classes (keep (<span class="keyword">fn</span> [e] (<span class="keyword">when</span> (<span class="keyword">seq</span> e) e)) (str/split className <span class="regexp"><span class="delimiter">#&quot;</span><span class="content">  *</span><span class="delimiter">&quot;</span></span>))
          kw      (<span class="keyword">keyword</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">.</span><span class="delimiter">&quot;</span></span> (str/join <span class="string"><span class="delimiter">&quot;</span><span class="content">.</span><span class="delimiter">&quot;</span></span> classes)))]
      kw)))

(<span class="keyword">defn-</span> <span class="function">chars-&gt;entity</span> [<span class="keyword">ns</span> <span class="namespace">chars</span>]
  (<span class="keyword">if</span> (<span class="keyword">=</span> <span class="char">\#</span> (<span class="keyword">first</span> <span class="keyword">chars</span>))
    (<span class="keyword">apply</span> <span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&amp;</span><span class="delimiter">&quot;</span></span> (<span class="keyword">conj</span> <span class="keyword">chars</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">;</span><span class="delimiter">&quot;</span></span>))                        <span class="comment">; skip it. needs (parse int, convert base, format to 4-digit code)</span>
    (<span class="keyword">if</span> (<span class="keyword">seq</span> <span class="keyword">ns</span>)
      (<span class="keyword">symbol</span> <span class="keyword">ns</span> (<span class="keyword">apply</span> <span class="keyword">str</span> <span class="keyword">chars</span>))
      (<span class="keyword">symbol</span> (<span class="keyword">apply</span> <span class="keyword">str</span> <span class="keyword">chars</span>)))))

(<span class="keyword">defn-</span> <span class="function">parse-entity</span> [stream result {<span class="symbol">:keys</span> [entity-ns] <span class="symbol">:as</span> options}]
  (<span class="keyword">loop</span> [s stream <span class="keyword">chars</span> []]
    (<span class="keyword">let</span> [c (<span class="keyword">first</span> s)]
      (<span class="keyword">case</span> c
        (<span class="char">\;</span> <span class="predefined-constant">nil</span>) [(<span class="keyword">rest</span> s) (<span class="keyword">if</span> (<span class="keyword">seq</span> <span class="keyword">chars</span>)
                             (<span class="keyword">conj</span> result (chars-&gt;entity entity-ns <span class="keyword">chars</span>))
                             result)]
        (<span class="keyword">recur</span> (<span class="keyword">rest</span> s) (<span class="keyword">conj</span> <span class="keyword">chars</span> c))))))

(<span class="keyword">defn-</span> <span class="function">html-string-&gt;react-string</span> [html-str {<span class="symbol">:keys</span> [ignore-entities?] <span class="symbol">:as</span> options}]
  (<span class="keyword">if</span> ignore-entities?
    html-str
    (<span class="keyword">loop</span> [s html-str result []]
      (<span class="keyword">let</span> [c (<span class="keyword">first</span> s)
            [new-stream new-result] (<span class="keyword">case</span> c
                                      <span class="predefined-constant">nil</span> [<span class="predefined-constant">nil</span> result]
                                      <span class="char">\&amp;</span> (parse-entity (<span class="keyword">rest</span> s) result options)
                                      [(<span class="keyword">rest</span> s) (<span class="keyword">conj</span> result c)])]
        (<span class="keyword">if</span> new-stream
          (<span class="keyword">recur</span> new-stream new-result)
          (<span class="keyword">let</span> [segments (partition-by <span class="keyword">char?</span> new-result)
                result   (mapv (<span class="keyword">fn</span> [s]
                                 (<span class="keyword">if</span> (<span class="keyword">char?</span> (<span class="keyword">first</span> s))
                                   (<span class="keyword">apply</span> <span class="keyword">str</span> s)
                                   (<span class="keyword">first</span> s))) segments)]
            result))))))

(<span class="keyword">defn</span> <span class="function">element-&gt;call</span>
  ([elem]
   (element-&gt;call elem {}))
  ([elem {<span class="symbol">:keys</span> [ns-alias keep-empty-attrs?] <span class="symbol">:as</span> options}]
   (<span class="keyword">cond</span>
     (<span class="keyword">and</span> (<span class="keyword">string?</span> elem)
       (<span class="keyword">let</span> [elem (str/trim elem)]
         (<span class="keyword">or</span>
           (<span class="keyword">=</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> elem)
           (<span class="keyword">and</span>
             (str/starts-with? elem <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;!--</span><span class="delimiter">&quot;</span></span>)
             (str/ends-with? elem <span class="string"><span class="delimiter">&quot;</span><span class="content">--&gt;</span><span class="delimiter">&quot;</span></span>))
           (<span class="keyword">re-matches</span> <span class="regexp"><span class="delimiter">#&quot;</span><span class="content">^[ </span><span class="content">\n</span><span class="content">]*$</span><span class="delimiter">&quot;</span></span> elem)))) <span class="predefined-constant">nil</span>
     (<span class="keyword">string?</span> elem) (html-string-&gt;react-string (str/trim elem) options)
     (<span class="keyword">vector?</span> elem) (<span class="keyword">let</span> [tag               (<span class="keyword">name</span> (<span class="keyword">first</span> elem))
                          raw-props         (<span class="keyword">second</span> elem)
                          classkey          (<span class="keyword">when</span> (<span class="keyword">contains?</span> raw-props <span class="symbol">:class</span>)
                                              (classes-&gt;keyword (<span class="symbol">:class</span> raw-props)))
                          attrs             (cond-&gt; (set/rename-keys raw-props attr-renames)
                                              (<span class="keyword">contains?</span> raw-props <span class="symbol">:class</span>) (<span class="keyword">dissoc</span> <span class="symbol">:className</span>)
                                              (<span class="keyword">contains?</span> raw-props <span class="symbol">:style</span>) (update <span class="symbol">:style</span> fix-style))
                          children          (keep (<span class="keyword">fn</span> [c] (element-&gt;call c options)) (<span class="keyword">drop</span> <span class="integer">2</span> elem))
                          expanded-children (<span class="keyword">reduce</span>
                                              (<span class="keyword">fn</span> [acc c]
                                                (<span class="keyword">if</span> (<span class="keyword">vector?</span> c)
                                                  (<span class="keyword">into</span> [] (<span class="keyword">concat</span> acc c))
                                                  (<span class="keyword">conj</span> acc c)))
                                              []
                                              children)]
                      (<span class="keyword">concat</span> (<span class="keyword">list</span>) (keep <span class="keyword">identity</span>
                                       [(<span class="keyword">if</span> (<span class="keyword">seq</span> ns-alias)
                                          (<span class="keyword">symbol</span> ns-alias tag)
                                          (<span class="keyword">symbol</span> tag))
                                        (<span class="keyword">when</span> classkey classkey)
                                        (<span class="keyword">if</span> keep-empty-attrs?
                                          attrs
                                          (<span class="keyword">when</span> (<span class="keyword">seq</span> attrs) attrs))]) expanded-children))
     <span class="symbol">:otherwise</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">defn</span> <span class="function">html-&gt;clj-dom</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Convert an HTML fragment (containing just one tag) into a corresponding Dom cljs.

  Options is a map that can contain:

  - `ns-alias`: The primary DOM namespace alias to use.  If not set, the calls will not be namespaced.
  - `keep-empty-attrs?`: Boolean (default false). Output (dom/p {} ...) vs (dom/p ...).
  - `entity-ns`: String (defaults to </span><span class="content">\&quot;</span><span class="content">ent</span><span class="content">\&quot;</span><span class="content">). When named HTML entities are found they are converted to the Fulcro
    HTML entity ns symbols that stand for the correct unicode (e.g. </span><span class="content">\&quot;</span><span class="content">&amp;quot;</span><span class="content">\&quot;</span><span class="content"> -&gt; `ent/quot`). This is the ns alias
    for those.
  - `ignore-entities?`: Boolean (default false). If true, entities in strings will not be touched.
  </span><span class="delimiter">&quot;</span></span>
  ([html-fragment options]
   (<span class="keyword">let</span> [hiccup-list (<span class="keyword">map</span> hc/as-hiccup (hc/parse-fragment html-fragment))
         options     (cond-&gt; options
                       (<span class="keyword">not</span> (<span class="keyword">contains?</span> options <span class="symbol">:entity-ns</span>)) (<span class="keyword">assoc</span> <span class="symbol">:entity-ns</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">ent</span><span class="delimiter">&quot;</span></span>))]
     (<span class="keyword">let</span> [result (keep (<span class="keyword">fn</span> [e] (element-&gt;call e options)) hiccup-list)]
       (<span class="keyword">if</span> (<span class="keyword">&lt;</span> <span class="integer">1</span> (<span class="keyword">count</span> result))
         (<span class="keyword">vec</span> result)
         (<span class="keyword">first</span> result)))))
  ([html-fragment]
   (html-&gt;clj-dom html-fragment {<span class="symbol">:ns-alias</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">dom</span><span class="delimiter">&quot;</span></span>})))

(defmutation convert [p]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">let</span> [html (<span class="keyword">get-in</span> @state [<span class="symbol">:top</span> <span class="symbol">:conv</span> <span class="symbol">:html</span>])
          cljs (html-&gt;clj-dom html)]
      (<span class="keyword">swap!</span> state <span class="keyword">assoc-in</span> [<span class="symbol">:top</span> <span class="symbol">:conv</span> <span class="symbol">:cljs</span>] {<span class="symbol">:code</span> cljs}))))

(defsc HTMLConverter [this {<span class="symbol">:keys</span> [html cljs]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:html</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;div id=</span><span class="content">\&quot;</span><span class="content">3</span><span class="content">\&quot;</span><span class="content"> class=</span><span class="content">\&quot;</span><span class="content">b</span><span class="content">\&quot;</span><span class="content">&gt;&lt;p&gt;Paragraph&lt;/p&gt;&lt;/div&gt;</span><span class="delimiter">&quot;</span></span> <span class="symbol">:cljs</span> {<span class="symbol">:code</span> (<span class="keyword">list</span>)}})
   <span class="symbol">:query</span>         [<span class="symbol">:cljs</span> <span class="symbol">:html</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:top</span> <span class="symbol">:conv</span>])}
  (dom/div {<span class="symbol">:className</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>}
    (dom/textarea {<span class="symbol">:cols</span>     <span class="integer">80</span> <span class="symbol">:rows</span> <span class="integer">10</span>
                   <span class="symbol">:onChange</span> (<span class="keyword">fn</span> [evt] (m/set-string! this <span class="symbol">:html</span> <span class="symbol">:event</span> evt))
                   <span class="symbol">:value</span>    html})
    (dom/button <span class="symbol">:.</span>c-button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [evt]
                                       (comp/transact! this `[(convert {})]))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Convert</span><span class="delimiter">&quot;</span></span>)
    (dom/pre {} (<span class="keyword">with-out-str</span> (pprint (<span class="symbol">:code</span> cljs))))))

(<span class="keyword">def</span> <span class="function">ui-html-convert</span> (comp/factory HTMLConverter))

(defsc Root [this {<span class="symbol">:keys</span> [converter]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:converter</span> {}}
   <span class="symbol">:query</span>         [{<span class="symbol">:converter</span> (comp/get-query HTMLConverter)}]}
  (ui-html-convert converter))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_defsc_macro"><a class="anchor" href="#_the_defsc_macro"></a><a class="link" href="#_the_defsc_macro">4.2. The <code>defsc</code> Macro</a></h3>
<div class="paragraph">
<p>Fulcro&#8217;s defsc is the main macro you&#8217;ll use to create components. It is sanity-checked for the most common elements:
ident (optional), query, props destructuring, and initial state (optional). The sanity checking prevents a lot of the
most common errors when writing a component,
and the concise syntax reduces boilerplate to the essential novelty. The name means "define stateful component" and is
intended to be used with components that have queries (though that is not a requirement).</p>
</div>
<div class="sect3">
<h4 id="_the_argument_list"><a class="anchor" href="#_the_argument_list"></a><a class="link" href="#_the_argument_list">4.2.1. The Argument List</a></h4>
<div class="paragraph">
<p>The primary argument list contains the common elements you might need to use in the body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc [this props &lt;optional-computed&gt; &lt;optional-extensible-arg&gt;]
 { <span class="keyword">..</span><span class="keyword">.</span>options.<span class="keyword">..</span> }
 (dom/div {<span class="symbol">:onClick</span> (<span class="symbol">:onClick</span> computed)} (<span class="symbol">:db/id</span> props)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last parameter is used by libraries to augment <code>defsc</code> with any additional data they might want to make
convenient.  See the <code>fulcro-garden-css</code> library for an example.</p>
</div>
<div class="paragraph">
<p>Only the first two parameters are required, so you can even write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc [this props]
 { <span class="keyword">..</span><span class="keyword">.</span>options.<span class="keyword">..</span> }
 (dom/div (<span class="symbol">:db/id</span> props)))</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_argument_destructuring"><a class="anchor" href="#_argument_destructuring"></a><a class="link" href="#_argument_destructuring">Argument Destructuring</a></h5>
<div class="paragraph">
<p>The parameter list fully supports Clojure destructuring on the props, computed, and "extra map" without having to write a
separate let:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc DestructuredExample [this
                            {<span class="symbol">:keys</span> [db/id] <span class="symbol">:as</span> props}
                            {<span class="symbol">:keys</span> [onClick] <span class="symbol">:as</span> computed <span class="symbol">:or</span> {onClick <span class="keyword">identity</span>}}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="integer">22</span>}}
  (dom/div
    (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Component: </span><span class="delimiter">&quot;</span></span> id)))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_options_lambda_vs_template"><a class="anchor" href="#_options_lambda_vs_template"></a><a class="link" href="#_options_lambda_vs_template">4.2.2. Options – Lambda vs. Template</a></h4>
<div class="paragraph">
<p>The core options (<code>:query</code>, <code>:ident</code>, <code>:initial-state</code>) of <code>defsc</code> are special.  They support both a lambda and a template
form. The template form is shorter and enables some sanity checks; however, it is not expressive enough to cover all
possible cases. The lambda form is slightly more verbose, but enables full flexibility at the expense of the sanity checks.</p>
</div>
<div class="paragraph">
<p>IMPORTANT NOTE: In lambda mode <code>ident</code> can use <code>this</code> and <code>props</code> from the <code>defsc</code> argument list. The other two are primarily
used "statically" and have no sane <code>this</code> or <code>props</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ident_generation"><a class="anchor" href="#_ident_generation"></a><a class="link" href="#_ident_generation">4.2.3. Ident Generation</a></h4>
<div class="paragraph">
<p>If you include <code>:ident</code>, it can take three possible forms: a template, lambda, or keyword.</p>
</div>
<div class="sect4">
<h5 id="_keyword_idents"><a class="anchor" href="#_keyword_idents"></a><a class="link" href="#_keyword_idents">Keyword Idents</a></h5>
<div class="paragraph">
<p>The keyword option is a popular option if you&#8217;re following the recommended naming conventions.  It means that the table
name <strong>and</strong> the ID key of the entity are the same.</p>
</div>
</div>
<div class="sect4">
<h5 id="_template_idents"><a class="anchor" href="#_template_idents"></a><a class="link" href="#_template_idents">Template Idents</a></h5>
<div class="paragraph">
<p>A template ident is just a vector that patterns what goes in the ident. The first element is always literal, and the
second is the name of the property to pull from props to get the ID.</p>
</div>
<div class="paragraph">
<p>If you use the template mechanism you get some added sanity checks: it won&#8217;t compile
if your ID key isn&#8217;t in your query, eliminating some possible frustration.</p>
</div>
<div class="paragraph">
<p>So, the following two forms are identical:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [_ _]
 {<span class="symbol">:ident</span> <span class="symbol">:person/id</span>
  <span class="keyword">..</span><span class="keyword">.</span>

<span class="comment">;; OR</span>

(defsc Person [_ _]
 {<span class="symbol">:ident</span> [<span class="symbol">:person/id</span> <span class="symbol">:person/id</span>]
  <span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_lambda_idents"><a class="anchor" href="#_lambda_idents"></a><a class="link" href="#_lambda_idents">Lambda Idents</a></h5>
<div class="paragraph">
<p>The above options are great for the common cases, but they don&#8217;t work if you have a single instance ever (i.e. you want
a literal second element), and they won&#8217;t work at all for union queries. They also do not support embedded code.
Therefore, if you want a more advanced ident you&#8217;ll need to spell out the code.</p>
</div>
<div class="paragraph">
<p><code>defsc</code> causes an ident lamda to "close over" the <code>defsc</code> argument list, which at least eliminates some of the boilerplate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc UnionComponent [this {<span class="symbol">:keys</span> [db/id component/type]}]
  {<span class="symbol">:ident</span> (<span class="keyword">fn</span> [] (union-ident <span class="keyword">type</span> id))} <span class="comment">; id and type are destructured into the method for you.</span>
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_query"><a class="anchor" href="#_query"></a><a class="link" href="#_query">4.2.4. Query</a></h4>
<div class="paragraph">
<p><code>defsc</code> also allows you to specify the query as a template or lambda.</p>
</div>
<div class="sect4">
<h5 id="_template_query"><a class="anchor" href="#_template_query"></a><a class="link" href="#_template_query">Template Query</a></h5>
<div class="paragraph">
<p>The template form is strongly recommended for most cases, because without it many of the sanity checks won&#8217;t work.</p>
</div>
<div class="paragraph">
<p>In template mode, the following sanity checks are enabled:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The props destructuring can only include things that are in the query.</p>
</li>
<li>
<p>The ident&#8217;s id propery is checked to make sure it is in the query (if ident is in template mode)</p>
</li>
<li>
<p>The initial app state can only contains things that are also queried for (if it is in template mode as well)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_lambda_query"><a class="anchor" href="#_lambda_query"></a><a class="link" href="#_lambda_query">Lambda Query</a></h5>
<div class="paragraph">
<p>This mode is necessary if you use more complex queries. The template mode currently does not support union queries or
wildcards.  It is also useful when you want to disable the sanity checks for any reason.</p>
</div>
<div class="paragraph">
<p>To use this mode, specify your query as <code>(fn [] [:x])</code>. In lambda mode, <code>this</code> comes from the argument list of <code>defsc</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_initial_state"><a class="anchor" href="#_initial_state"></a><a class="link" href="#_initial_state">4.2.5. Initial State</a></h4>
<div class="paragraph">
<p>As with <code>:query</code> and <code>:ident</code>, <code>:initial-state</code> supports a template and lambda form.</p>
</div>
<div class="paragraph">
<p>The template form for initial state is a bit magical, because it tries to sanity check your initial state, but also has
to support relations through joins. Finally it tries to eliminate typing for you by auto-wrapping nested relation
initializations in <code>get-initial-state</code> for you by deriving the correct class to use from the query.
This further reduces the chances of error; however, you may find the terse result more difficult to read and
instead choose to write it yourself. Both ways are supported:</p>
</div>
<div class="sect4">
<h5 id="_lambda_mode"><a class="anchor" href="#_lambda_mode"></a><a class="link" href="#_lambda_mode">Lambda mode</a></h5>
<div class="paragraph">
<p>This is simple to understand, and all you need to see is a simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Component [this props]
 {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] <span class="keyword">..</span><span class="keyword">.</span>exactly the state this component should start with.<span class="keyword">..</span>)}
 <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_template_mode"><a class="anchor" href="#_template_mode"></a><a class="link" href="#_template_mode">Template Mode</a></h5>
<div class="paragraph">
<p>In template mode <code>:initial-state</code> converts incoming parameters (which must use simple keywords) into :param/X keys. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this props]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="symbol">:param/id</span>}}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>means:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:db/id</span> (<span class="symbol">:id</span> params)}})}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is even more powerful than that, because it analyzes your query and can deal with to-one and to-many join initialization as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this props]
  {<span class="symbol">:query</span> [{<span class="symbol">:person/job</span> (comp/get-query Job)}]
  <span class="symbol">:initial-state</span> {<span class="symbol">:person/job</span> {<span class="symbol">:job/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Welder</span><span class="delimiter">&quot;</span></span>}}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>means (in simplified terms):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:person/job</span> (comp/get-initial-state Job {<span class="symbol">:job/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Welder</span><span class="delimiter">&quot;</span></span>})})}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the magic there. <code>Job</code> was pulled from the query by looking for joins on the initialization keyword (<code>:person/job</code>).</p>
</div>
<div class="paragraph">
<p>To-many relations are also auto-derived:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this props]
  {<span class="symbol">:query</span> [{<span class="symbol">:person/prior-jobs</span> (comp/get-query Job)}]
  <span class="symbol">:initial-state</span> {<span class="symbol">:person/prior-jobs</span> [{<span class="symbol">:job/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Welder</span><span class="delimiter">&quot;</span></span>} {<span class="symbol">:job/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Cashier</span><span class="delimiter">&quot;</span></span>]}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>means (in simplified terms):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params]
    {<span class="symbol">:person/prior-jobs</span> [(comp/get-initial-state Job {<span class="symbol">:job/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Welder</span><span class="delimiter">&quot;</span></span>})
                         (comp/get-initial-state Job {<span class="symbol">:job/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Cashier</span><span class="delimiter">&quot;</span></span>})]})}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The internal steps for processing this template are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Replace all uses of :param/nm with (get params :nm)</p>
</li>
<li>
<p>The query is analyzed for joins on keywords (ident joins are not supported).</p>
<div class="ulist">
<ul>
<li>
<p>If a key in the initial state matches up with a join, then the value in initial state must be a map or a vector.
In that case (get-initial-state JoinClass p) will be called for each map (to-one) or mapped across the vector (to-many).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>REMEMBER: the value that you use in the initial-state for children is the parameter map to use against that child&#8217;s
initial state function. To-one and to-many relations are implied by what you pass (a map is to-one, a vector is to-many).</p>
</div>
<div class="paragraph">
<p>Step (1) means that nesting of param-namespaced keywords is supported, but realize that the params come from the
<strong>declaring component&#8217;s</strong> initial state parameters, they are substituted <strong>before</strong> being passed to the child.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pre_merge"><a class="anchor" href="#_pre_merge"></a><a class="link" href="#_pre_merge">4.2.6. Pre-Merge</a></h4>
<div class="paragraph">
<p>The <code>:pre-merge</code> option offers a hook to manipulate data entering your Fulcro app at a component level. The option looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Countdown [this props]
  {<span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [env] <span class="keyword">..</span><span class="keyword">.</span>)}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:pre-merge</code> lambda receives a single map containing the following keys:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:data-tree</code> - the new data tree entering the database (e.g. from a load or explicit <code>merge-component!</code>)</p>
</li>
<li>
<p><code>:current-normalized</code> - the current entity value (normalized form in the db)</p>
</li>
<li>
<p><code>:state-map</code> - the current normalized client database (as a map, not an atom)</p>
</li>
<li>
<p><code>:query</code> - the query being used to for this request (user may have modified the original using <code>:focus</code>, <code>:without</code> or <code>:update-query</code> during the load call</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and returns the data that should actually be merged into app state. This feature requires
a complete understanding of normalization and full stack operation, and is covered in a
<a href="#PreMerge">later chapter</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_component_constructor"><a class="anchor" href="#_component_constructor"></a><a class="link" href="#_component_constructor">4.2.7. Component Constructor</a></h4>
<div class="paragraph">
<p>It is sometimes useful to be able to run some code once on component construction. In React this is particularly useful
when you want a function for saving off <code>:ref</code> or as other callbacks (so the function isn&#8217;t changing all the time), or copy something from props into state.</p>
</div>
<div class="paragraph">
<p>Use <code>:initLocalState</code> to do these operations before you return a value.</p>
</div>
</div>
<div class="sect3">
<h4 id="_react_lifecycle_methods"><a class="anchor" href="#_react_lifecycle_methods"></a><a class="link" href="#_react_lifecycle_methods">4.2.8. React Lifecycle Methods</a></h4>
<div class="paragraph">
<p>The options of defsc allow for React Lifecycle methods to be defined (as lambdas).
The first argument of all non-static lifecycle methods is <code>this</code>.  The React documentation describes any further
arguments. Where props or state are expected you will be given Fulcro&#8217;s version of those (cljs data instead of raw js).
Where the current props are not an argument you can call <code>(comp/props this)</code>  to get them, and
you can obtain computed using <code>comp/get-computed</code>.</p>
</div>
<div class="paragraph">
<p>The signatures are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Component [this props]
    <span class="symbol">:initLocalState</span>            (<span class="keyword">fn</span> [this props] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:shouldComponentUpdate</span>     (<span class="keyword">fn</span> [this next-props next-state] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:componentWillReceiveProps</span> (<span class="keyword">fn</span> [this next-props] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:componentWillUpdate</span>       (<span class="keyword">fn</span> [this next-props next-state] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:componentDidUpdate</span>        (<span class="keyword">fn</span> [this prev-props prev-state] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:componentWillMount</span>        (<span class="keyword">fn</span> [this] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:componentDidMount</span>         (<span class="keyword">fn</span> [this] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:componentWillUnmount</span>      (<span class="keyword">fn</span> [this] <span class="keyword">..</span><span class="keyword">.</span>)

    <span class="comment">;; Replacements for deprecated methods in React 16.3+</span>
    <span class="symbol">:UNSAFE_componentWillReceiveProps</span> (<span class="keyword">fn</span> [this next-props] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:UNSAFE_componentWillUpdate</span>       (<span class="keyword">fn</span> [this next-props next-state] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:UNSAFE_componentWillMount</span>        (<span class="keyword">fn</span> [this] <span class="keyword">..</span><span class="keyword">.</span>)

    <span class="comment">;; ADDED for React 16:</span>
    <span class="symbol">:componentDidCatch</span>         (<span class="keyword">fn</span> [this error info] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:getSnapshotBeforeUpdate</span>   (<span class="keyword">fn</span> [this prevProps prevState] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:getDerivedStateFromProps</span>  (<span class="keyword">fn</span> [props state] <span class="keyword">..</span><span class="keyword">.</span>) <span class="comment">; static</span>

    <span class="comment">;; ADDED for React 16.6:</span>
    <span class="symbol">:getDerivedStateFromError</span>  (<span class="keyword">fn</span> [error] <span class="keyword">..</span><span class="keyword">.</span>)  <span class="comment">; static. **NOTE**: Sets low-level state, Use get-react-state.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the React documentation for more details on how these work.</p>
</div>
<div class="sect4">
<h5 id="_component_local_state_and_errors"><a class="anchor" href="#_component_local_state_and_errors"></a><a class="link" href="#_component_local_state_and_errors">Component Local State and Errors</a></h5>
<div class="paragraph">
<p>Fulcro wraps React&#8217;s state such that you can easily store cljs data in the component (e.g.
arguments to methods like <code>componentDidUpdate</code> <code>prev-state</code> will be a cljs map, NOT the raw JS one
that React uses).</p>
</div>
<div class="paragraph">
<p>The same is true for the return value of <code>initLocalState</code>: You return a CLJS map, and it is safely stored in react
state but otherwise behaves just like the native.</p>
</div>
<div class="paragraph">
<p>The advantage of this is twofold:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Convenience: You get to use immutable data for component-local state</p>
</li>
<li>
<p>Speed: Fulcro is able to very quickly compare and short-circuit React rendering because immutable state is very
fast to compare (it can mostly be a single reference compare).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is accomplished by storing the "Fulcro" version of component state under the <code>fulcro$state</code> key in the low-level js
state.  Normally, this is of no concern to you at all, but React 16.7 added a <strong>static</strong> lifecycle method
called <code>getDerivedStateFromError</code> whose return value is meant to be a js map that gets <strong>merged</strong> to the low-level state,
and there is no internal hook or hack (yet found) to merge that into the correct Fulcro location.</p>
</div>
<div class="paragraph">
<p>Thus, if you provide a <code>getDerivedStateFromError</code> your return value (a CLJS map) will <strong>overwrite</strong> your current
component local state.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re not using component local state for anything else, then this is probably just fine, but if you have
important information in component-local state you may want to choose an alternative.</p>
</div>
<div class="paragraph">
<p>One workaround is to set state in <code>componentDidCatch</code>.  This is deprecated by React because it happens in a different
phase of the React processing, so you should read up on that in the React docs to see if it is acceptable for your
case.</p>
</div>
<div class="paragraph">
<p>Another (trivial but possibly annoying) workaround is to write a wrapper component that does nothing but deal with errors, so
that the state is never used for anything <strong>but</strong> error handling.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sanity_checking"><a class="anchor" href="#_sanity_checking"></a><a class="link" href="#_sanity_checking">4.2.9. Sanity Checking</a></h4>
<div class="paragraph">
<p>The sanity checking mentioned in the earlier sections causes compile errors. The errors are intended to be self-explanatory.
They will catch common mistakes (like forgetting to query for data that you&#8217;re pulling out of props, or mis-spelling a property).</p>
</div>
<div class="paragraph">
<p>For example, try:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mismatching the name of a prop in a query with a destructured name in props.</p>
</li>
<li>
<p>Destructuring a prop that isn&#8217;t in the query</p>
</li>
<li>
<p>Including initial state for a field that is not listed as a prop or child in options.</p>
</li>
<li>
<p>Using a scalar value for the initial value of a joined child (instead of a map or vector of maps)</p>
</li>
<li>
<p>Forget to query for the ID field of a component that is used in an ident</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In some cases the sanity checking is too aggressive or may mis-detect a problem.
To get around it simply use the lambda style.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_component_registry"><a class="anchor" href="#_the_component_registry"></a><a class="link" href="#_the_component_registry">4.3. The Component Registry</a></h3>
<div class="paragraph">
<p>You may find it useful to note that any Fulcro component that is loaded in your
application will appear in a global component registry.  You can look up such components using a symbol or keyword
that matches the fully namespace-qualified name of the component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/registry-key-&gt;class `app.ui/Root)

<span class="comment">;; OR</span>

(comp/registry-key-&gt;class <span class="symbol">:app.ui/Root</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This comes in handy for things like code splitting (where the dynamically loaded code will appear in the registry),
tracking classes (by name) in app state (which cannot appear there as "code").</p>
</div>
</div>
<div class="sect2">
<h3 id="_factories"><a class="anchor" href="#_factories"></a><a class="link" href="#_factories">4.4. Factories</a></h3>
<div class="paragraph">
<p>Factories are how you generate React elements (the virtual DOM nodes) from your React classes defined with
<code>defsc</code>. You make a new factory using <code>com.fulcrologic.fulcro.components/factory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">ui-component</span> (comp/factory MyComponent {<span class="symbol">:keyfn</span> f}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:keyfn</code> option is a function against <code>props</code> to generate a React key. This should be supplied on any component
that will appear as a to-many child to ensure React rendering can properly diff.</p>
</div>
<div class="paragraph">
<p>In Fulcro documentation we generally adopt the naming convention for UI factories to be prefixed with <code>ui-</code>. This
is because you often want to name joins the same thing as a component: e.g. your query might be
<code>[{:ui/child (comp/get-query Child)}]</code>, and then when you destructure in render: <code>(let [{:ui/keys [child]} (comp/props this) &#8230;&#8203;</code>
you have local data in the symbol <code>child</code>. If your UI factory was also called <code>child</code> then it would cause annoying name
collisions. Prefixing the factories with <code>ui-</code> eliminates such collisions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_render_and_props"><a class="anchor" href="#_render_and_props"></a><a class="link" href="#_render_and_props">4.5. Render and Props</a></h3>
<div class="paragraph">
<p>Properties are always passed to a component factory as the first argument and are not optional:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(ui-child child-props)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The properties are available as the second argument to <code>defsc</code> for the render body, but can also be accessed
by calling <code>com.fulcrologic.fulcro.components/props</code> on <code>this</code>. The latter approach is useful in functions that
receive the instance as an argument.</p>
</div>
<div class="paragraph">
<p>In components with queries there is a strong correlation between the query (which must join the child&#8217;s query),
props (from which you must extract the child&#8217;s props), and calling of the child&#8217;s factory
(to which you must pass the child&#8217;s data).</p>
</div>
<div class="paragraph">
<p>If you are using components that do not have queries, then you may pass whatever properties you deem useful. Such
components do not take advantage of any other Fulcro advantages, such as render optimizations.</p>
</div>
<div class="paragraph">
<p>Details about additional aspects of rendering are in the sections that follow.</p>
</div>
<div class="sect3">
<h4 id="_derived_values"><a class="anchor" href="#_derived_values"></a><a class="link" href="#_derived_values">4.5.1. Derived Values</a></h4>
<div class="paragraph">
<p>It is possible that your logic and state will be much simpler if your UI components derive some values at render time.
A prime example of this is the state of a "check all" button. The state of such a button is dependent on other components
in the UI, and it is <strong>not</strong> a separate value. Thus, your UI may want to compute it and not store it else it could
easily become out of sync and lead to more complex logic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">item-checked?</span> [item] (<span class="symbol">:checked?</span> item))

(defsc Checkboxes [this {<span class="symbol">:list/keys</span> [items]}]
  {<span class="symbol">:query</span> [{<span class="symbol">:list/items</span> (comp/get-query CheckboxItem)}]}
  (<span class="keyword">let</span> [all-checked? (every item-checked? items)]
    (dom/div
      <span class="string"><span class="delimiter">&quot;</span><span class="content">All: </span><span class="delimiter">&quot;</span></span> (dom/input {<span class="symbol">:checked</span> all-checked? <span class="keyword">..</span><span class="keyword">.</span>})
    (dom/ul <span class="keyword">..</span><span class="keyword">.</span>))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a problem, though: the rendering refresh algorithms of Fulcro tries to avoid rendering things that don&#8217;t actually
change.  In this case the thing that is changing is a child (it is being toggled). Technically this changes the parent&#8217;s
props (because the child flows through it) but some of Fulcro&#8217;s rendering optimizations might not see it that way
(nothing the parent <strong>directly</strong> queried for changed).</p>
</div>
<div class="paragraph">
<p>If you&#8217;re using the default ident-optimized render, then you&#8217;ll want to add a refresh option to the transaction that
changes the child:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this [(toggle-checkbox {<span class="keyword">..</span><span class="keyword">.</span>})] {<span class="symbol">:refresh</span> [<span class="symbol">:list/items</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:refresh</code> option indicates that the property (or ident) listed changed in a way that any component querying directly
for it should be refreshed even if the data that the component itself uses did not change.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The ident of <code>this</code> is always included in the refresh list for you; therefore you can avoid having to deal with
this additional parameter if you run the toggle against the parent (e.g. via a callback sent to the child).
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_general_guidelines_for_derived_values"><a class="anchor" href="#_general_guidelines_for_derived_values"></a><a class="link" href="#_general_guidelines_for_derived_values">General Guidelines for Derived Values</a></h5>
<div class="paragraph">
<p>You should consider computing a derived value when:
* The known data from the props already gives you sufficient information to calculate the value.
* The computation is relatively light.</p>
</div>
<div class="paragraph">
<p>Some examples where UI computation are effective, light, or even necessary:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rendering an internationalized value. (e.g. <code>tr</code>)</p>
</li>
<li>
<p>Rendering a check-all button</p>
</li>
<li>
<p>Rendering "row numbering" or other decorations like row highlighting</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are some trade-offs, but most significantly you generally do <strong>not</strong> want to compute things like the order/pagination of a list of items.
The logic and overhead in sorting and pagination often needs caching, and there are
clear and easy "events" (user clicking on sort-by-name) that make it clear when to call the mutation to update
the database. You still have to store the selected sort order, and you have to have idents pointing to the list of
items. It is possible for your "selected sort order" and list to become out of sync, but the trade-offs of sorting
in the UI are typically high, particularly when pagination is involved and large amounts of data would have
to be fed to the UI.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_computed_props_and_callbacks"><a class="anchor" href="#_computed_props_and_callbacks"></a><a class="link" href="#_computed_props_and_callbacks">4.5.2. Computed Props and Callbacks</a></h4>
<div class="paragraph">
<p>Many reusable components will need to tell their parent about some event. For example, a list item generally wants
to tell the parent when the user has clicked on the "remove" button for that item. The item itself cannot
be truly composable if it has to know details of the parent. But a parent must always know the details of
a child (it rendered it, didn&#8217;t it?). As such, manipulations that affect the content of a parent should be
communicated to that parent for processing. The mechanism for this is identical to what you&#8217;d do in stock
React: callbacks from the child.</p>
</div>
<div class="paragraph">
<p>The one <strong>major</strong> difference is how you pass the callback <strong>to</strong> a component.</p>
</div>
<div class="paragraph">
<p>The query and data feed mechanisms that supply props to a component are capable of refreshing a child <strong>without</strong>
refreshing a parent. This UI optimization can pull the props directly from the database using the query, and
re-feed them to the child.</p>
</div>
<div class="paragraph">
<p>But this mechanism knows nothing about callbacks, because they are not (and should not be) stored in
the client database. Parents should not pass callbacks through the props
because the parent is where they are created, but the parent may not be involved in the refresh!</p>
</div>
<div class="paragraph">
<p>So, any value (function or otherwise) that is generated on-the-fly by the parent must be passed by wrapping them in
<code>com.fulcrologic.fulcro.components/computed</code>. This tells the data feed system how to reconstruct the complete data
should it do a targeted update.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Child [this {<span class="symbol">:keys</span> [y]}]
  {<span class="symbol">:query</span> [<span class="symbol">:y</span>]}
  (<span class="keyword">let</span> [onDelete (comp/get-computed this <span class="symbol">:onDelete</span>)]
    <span class="keyword">..</span><span class="keyword">.</span>))

(defsc Parent [this {<span class="symbol">:keys</span> [x child]}]
  {<span class="symbol">:query</span>  [<span class="symbol">:x</span> {<span class="symbol">:child</span> (comp/get-query Child)}]}
  (<span class="keyword">let</span> [onDelete (<span class="keyword">fn</span> [id] (comp/transact! <span class="keyword">..</span><span class="keyword">.</span>))
        child-props-with-callbacks (comp/computed child {<span class="symbol">:onDelete</span> onDelete})]
    (ui-child child-props-with-callbacks)))</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Not understanding this can cause a lot of head scratching: The initial render will always work perfectly,
because the parent is involved. All events will be processed, and you&#8217;ll think everything is fine; however, if you
have passed a callback incorrectly it will mysteriously stop working after a (possibly unnoticeable) refresh. This
means you&#8217;ll "test it" and say it is OK, only to discover you have a bug that shows up during subsequent use.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For convenience there is a function that can generate a factory that accepts computed data as a second argument to
the factory so you can avoid calling <code>computed</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Child [this {<span class="symbol">:keys</span> [y]}]
  {<span class="symbol">:query</span> [<span class="symbol">:y</span>]}
  (<span class="keyword">let</span> [onDelete (comp/get-computed this <span class="symbol">:onDelete</span>)]
    <span class="keyword">..</span><span class="keyword">.</span>))

(<span class="keyword">def</span> <span class="function">ui-child</span> (comp/computed-factory Child))

(defsc Parent [this {<span class="symbol">:keys</span> [x child]}]
  {<span class="symbol">:query</span>  [<span class="symbol">:x</span> {<span class="symbol">:child</span> (comp/get-query Child)}]}
  (<span class="keyword">let</span> [onDelete (<span class="keyword">fn</span> [id] (comp/transact! <span class="keyword">..</span><span class="keyword">.</span>))]
    (ui-child child {<span class="symbol">:onDelete</span> onDelete})))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_children"><a class="anchor" href="#_children"></a><a class="link" href="#_children">4.5.3. Children</a></h4>
<div class="paragraph">
<p>A very common pattern in React is to define a number of custom components that are intended to work in a nested fashion. So,
instead of just passing <code>props</code> to a factory, you might also want to pass other React elements. This is fully supported
in Fulcro, but can cause confusion when you first try to mix it with the data-driven aspect of the system.</p>
</div>
<div class="sect4">
<h5 id="_working_with_children"><a class="anchor" href="#_working_with_children"></a><a class="link" href="#_working_with_children">Working with Children</a></h5>
<div class="paragraph">
<p>If children are passed to your factory they will be available in <code>(comp/children this)</code>.
Basically, the child or children can simply be dropped into the place where they should be rendered.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Parent [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:x</span>]}
  (<span class="keyword">apply</span> dom/div <span class="symbol">:.</span>ui.grid
    (comp/children this)))

(<span class="keyword">def</span> <span class="function">ui-parent</span> (comp/factory Parent))

(defsc Component [this {<span class="symbol">:keys</span> [parent-props child-props other-child-props]}]
  {<span class="symbol">:query</span> [{<span class="symbol">:parent-props</span> (get-query X)}
           {<span class="symbol">:child-props</span> (get-query Y)}
           {<span class="symbol">:other-child-props</span> (get-query Z)}]
   <span class="keyword">..</span><span class="keyword">.</span>}
  (ui-parent parent-props
    (ui-child child-props)
    (ui-child other-child-props)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main trick is making sure you get the data feed right.  In this case the data is all obtained by the component
rendering this custer, even though the UI tree has a slightly different shape.  Technically they are all "data children"
of <code>Component</code>. Often, the <code>Parent</code> in this situation is something like a modal or layout component that may or may
not even need a query.</p>
</div>
</div>
<div class="sect4">
<h5 id="_react_16_fragments_and_returning_multiple_children"><a class="anchor" href="#_react_16_fragments_and_returning_multiple_children"></a><a class="link" href="#_react_16_fragments_and_returning_multiple_children">React 16 Fragments and Returning Multiple Children</a></h5>
<div class="paragraph">
<p>React 16 allows you to return a vector of children or a <code>Fragment</code> from a component (so you no longer
are forced to have a single child as a return value). Fulcro&#8217;s <code>components</code> namespaces include a <code>fragment</code>
function to wrap elements in a fragment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc X [this props]
  (comp/fragment <span class="comment">; in the comp namespace, because it isn't DOM specific. Could be used with native.</span>
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc X [this props]
  [(dom/p {<span class="symbol">:key</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>} <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>) (dom/p {<span class="symbol">:key</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>} <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>)])

(<span class="keyword">def</span> <span class="function">ui-x</span> (comp/factory X))</code></pre>
</div>
</div>
<div class="paragraph">
<p>allows your component to return multiple elements that are spliced into the parent without any "wrapping" elements
in the DOM. If you return a vector then you also need to supply React keys.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(dom/div (ui-x)) =&gt; &lt;div&gt;&lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See React documentation for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="_mixing_data_driven_children_with_ui_only_concerns"><a class="anchor" href="#_mixing_data_driven_children_with_ui_only_concerns"></a><a class="link" href="#_mixing_data_driven_children_with_ui_only_concerns">Mixing Data-Driven Children with UI-Only Concerns</a></h5>
<div class="paragraph">
<p>At first this seems a little mind-bending, because you are in fact nesting components in the UI, but
the query nesting need only mimic the <strong>stateful</strong> portion of the UI tree. This means there is ample opportunity
to use React children in a way that looks incorrect from what you&#8217;ve learned so far. On deeper inspection
it turns out it is alignment with the rules, but it takes a minute on first exposure.</p>
</div>
<div class="paragraph">
<p>Take a collapse component: It needs state of its own in order to know when it is collapsed,
and we&#8217;d like that to be part of the application database.
However, the children of the collapse cannot be known in advance when writing the collapse
reusable library component.</p>
</div>
<div class="paragraph">
<p>The solution is simple once you see it: Query for the collapse component&#8217;s state and the child state in
the common parent component, then do the UI nesting in that component. Technically the component that is "laying out" the
UI (the ultimate parent) is in charge of both obtaining and rendering the data.  The fact that the UI child ends
up nested in a query sibling is perfectly fine.</p>
</div>
<div class="paragraph">
<p>The collapse component itself is only concerned with the fact that it is open/closed, and that it has children that
should be shown/hidden. The actual DOM elements of those children are immaterial, and can be assembled by the parent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc CollapseExample [this {<span class="symbol">:keys</span> [collapse-1 child]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {<span class="symbol">:collapse-1</span> (comp/get-initial-state Collapse {<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:start-open</span> <span class="predefined-constant">false</span>})})
   <span class="symbol">:query</span> [{<span class="symbol">:collapse-1</span> (comp/get-query Collapse)}
           {<span class="symbol">:child</span> (comp/get-query SomeChild)}]}
  (dom/div
    (ui-collapse collapse-1
      (ui-child child))))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_controlled_inputs"><a class="anchor" href="#_controlled_inputs"></a><a class="link" href="#_controlled_inputs">4.6. Controlled Inputs</a></h3>
<div class="paragraph">
<p>Form inputs in React can take two possible approaches: controlled and uncontrolled. The browser normally maintains
the value state of inputs for you as mutable data; however, this breaks our overall model of pure rendering! The
advantage is UI interaction speed: If your UI gets rather large, it is possible that UI updates on keystrokes in
form inputs may be too slow. This is the same sort of trade-off that we talked about when covering component
local state for rendering speed with more graphical components. Fulcro is designed to be fast enough that
then your application should be fast enough to do database updates on every keystroke, and you can keep all input
changes in your client database. See the <a href="#Performance">optimization guidelines</a> if you have problems.</p>
</div>
<div class="paragraph">
<p>In general it is recommended that you use controlled inputs and retain the benefits of pure rendering: no embedded
state, your UI exactly represents your data representation, concrete devcards support for UI prototyping, and full
support viewer support.</p>
</div>
<div class="paragraph">
<p>Most inputs become controlled when you set their <code>:value</code> property. The table below lists the mechanism whereby
a form input is completely controlled by React:</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Input type</th>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">input</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(not checkboxes or radio)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkbox</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:checked</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">radio</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:checked</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(only one in a group should be checked)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">textarea</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:value</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">select</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instead of marking an option selected. Match <code>select&#8217;s `:value</code> to the <code>:value</code> of a nested <code>option</code>.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
React will consider <code>nil</code> to mean you want an uncontrolled component. This can result in
a warning about converting uncontrolled to controlled components. In order to prevent this warning you should make
sure that <code>:checked</code> is always a boolean, and that other inputs have a valid <code>:value</code> (e.g. an empty string). The
<code>select</code> input can be given an "extra" option that stands for "not selected yet" so that you can start its value
at something valid.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Most HTML inputs deal in strings (even date and numeric controls). Be careful when using the value from change
events in your database, because you may change your data to a string by mistake. A nice way to handle this is to wrap
inputs with your own components that do data transforms in-between <code>:value</code> and <code>:onChange</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="https://facebook.github.io/react/docs/forms.html">React Forms</a> for more details.</p>
</div>
<div class="sect3">
<h4 id="_advanced_details_of_wrapped_inputs"><a class="anchor" href="#_advanced_details_of_wrapped_inputs"></a><a class="link" href="#_advanced_details_of_wrapped_inputs">4.6.1. Advanced Details of Wrapped Inputs</a></h4>
<div class="paragraph">
<p>React is actually designed for you to do controlled components via component-local state, and in reality it
<a href="https://stackoverflow.com/questions/28922275/in-reactjs-why-does-setstate-behave-differently-when-called-synchronously/28922465#28922465">doesn&#8217;t
deal well</a> with a behind-the-scenes persistence mechanism tracking the state. Fulcro actually has a wrapper around
inputs to deal with these complications for you.</p>
</div>
<div class="paragraph">
<p>If you use any kind of library that provides input-like controls you may experience similar kinds of issues. You have
two easy options to make them behave correctly: Use component-local state with them, or similarly wrap them using
Fulcro&#8217;s pre-built wrapper code. There is a function in the <code>dom</code> namespace called <code>wrap-form-element</code> that can be used
to create a factory for input-like controls that misbehave.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defscForOptimization"><a class="anchor" href="#defscForOptimization"></a><a class="link" href="#defscForOptimization">4.7. Using <code>defsc</code> for Rendering Optimization</a></h3>
<div class="paragraph">
<p>Normally you&#8217;ll define components that have both a query and ident; however, it is perfectly legal to
define components that are completely controlled by their parent and have no identity of their own. This
is useful when you have a component that has a rather large UI, but for which the query does not need further breakdown.
Using <code>defsc</code> instead of <code>defn</code> to render subsections of a component means that you get <code>shouldComponentUpdate</code> optimizations
that will short-circuit automatically when the props sent to those components have not changed.</p>
</div>
<div class="paragraph">
<p>A simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc TopBar [this {<span class="symbol">:keys</span> [title]}]
  {}
  (dom/div
   <span class="keyword">..</span><span class="keyword">.</span>
   (dom/h3 title)))

(<span class="keyword">def</span> <span class="function">ui-top-bar</span> (comp/factory TopBar))</code></pre>
</div>
</div>
<div class="paragraph">
<p>instead of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">ui-top-bar</span> [{<span class="symbol">:keys</span> [title]}]
  (dom/div
    <span class="keyword">..</span><span class="keyword">.</span>
    (dom/h3 title)))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ReactLifecycle"><a class="anchor" href="#ReactLifecycle"></a><a class="link" href="#ReactLifecycle">4.8. React Lifecycle Examples</a></h3>
<div class="paragraph">
<p>There are some common use-cases that can only be solved by working directly with the React Lifecycle methods.</p>
</div>
<div class="paragraph">
<p>Some topics you should be familiar with in React to accomplish many of these things are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Component references: A mechanism that allows you access to the <strong>real</strong> DOM of the component once it&#8217;s on-screen.</p>
</li>
<li>
<p>Component-local state: A stateful mechanism where mutable data is stored on the component instance.</p>
</li>
<li>
<p>General DOM manipulation. Clojurescript builds using the Google Closure compiler and therefore
includes the Google Closure library, which in turn has all sorts of helpful low-level functions should you need them.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_focusing_an_input"><a class="anchor" href="#_focusing_an_input"></a><a class="link" href="#_focusing_an_input">4.8.1. Focusing an input</a></h4>
<div class="paragraph">
<p>Focus is a stateful browser mechanism, and React cannot infer the rendering of "focus" from pure data. As such, when you need
to deal with UI focus it generally involves some interpretation, and possibly component local state. The most common way
of dealing with deciding when to focus is to look at a component&#8217;s prior vs. next properties. This can be
done in <code>componentDidUpdate</code>. For example, say you have an item that renders as a string, but when clicked
turns into an input field. You&#8217;d certainly want to focus that, and place the cursor at the end of the
existing data (or highlight it all).</p>
</div>
<div class="paragraph">
<p>If your component had a property called <code>editing?</code> that you made true to indicate it should render as an input
instead of just a value, then you could write your focus logic based on the transition of your component&#8217;s props
from <code>:editing?</code> false to <code>:editing?</code> true.</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. <a id="InputFocusandReactRefsLifecycle"></a><a href="#InputFocusandReactRefsLifecycle">Input Focus and React Refs Lifecycle</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('focus-example')">Focus Inspector</button>
<div class="short narrow example" id="focus-example"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.ui.focus-example</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
            [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
            [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
            [goog.object <span class="symbol">:as</span> gobj]))

(defsc ClickToEditField [this {<span class="symbol">:keys</span> [value editing?]}]
  {<span class="symbol">:initial-state</span>      {<span class="symbol">:value</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">ABC</span><span class="delimiter">&quot;</span></span>
                        <span class="symbol">:db/id</span>    <span class="integer">1</span>
                        <span class="symbol">:editing?</span> <span class="predefined-constant">false</span>}
   <span class="symbol">:query</span>              [<span class="symbol">:db/id</span> <span class="symbol">:value</span> <span class="symbol">:editing?</span>]
   <span class="symbol">:ident</span>              [<span class="symbol">:field/by-id</span> <span class="symbol">:db/id</span>]
   <span class="symbol">:initLocalState</span>     (<span class="keyword">fn</span> [this _]
                         {<span class="symbol">:save-ref</span> (<span class="keyword">fn</span> [r] (gobj/set this <span class="string"><span class="delimiter">&quot;</span><span class="content">input-ref</span><span class="delimiter">&quot;</span></span> r))})
   <span class="symbol">:componentDidUpdate</span> (<span class="keyword">fn</span> [this prev-props _]
                         (<span class="keyword">when</span> (<span class="keyword">and</span> (<span class="keyword">not</span> (<span class="symbol">:editing?</span> prev-props)) (<span class="symbol">:editing?</span> (comp/props this)))
                           (<span class="keyword">when-let</span> [input-field (gobj/get this <span class="string"><span class="delimiter">&quot;</span><span class="content">input-ref</span><span class="delimiter">&quot;</span></span>)]
                             (<span class="keyword">.</span>focus input-field))))}
  (<span class="keyword">let</span> [save-ref (comp/get-state this <span class="symbol">:save-ref</span>)]
    (dom/div
      <span class="comment">; trigger a focus based on a state change (componentDidUpdate)</span>
      (dom/a {<span class="symbol">:onClick</span> #(m/toggle! this <span class="symbol">:editing?</span>)}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Click to focus (if not already editing): </span><span class="delimiter">&quot;</span></span>)
      (dom/input {<span class="symbol">:value</span>    value
                  <span class="symbol">:onChange</span> #(m/set-string! this <span class="symbol">:event</span> %)
                  <span class="symbol">:ref</span>      save-ref})
      <span class="comment">; do an explicit focus</span>
      (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> []
                              (<span class="keyword">when-let</span> [input-field (gobj/get this <span class="string"><span class="delimiter">&quot;</span><span class="content">input-ref</span><span class="delimiter">&quot;</span></span>)]
                                (<span class="keyword">.</span>focus input-field)
                                (<span class="keyword">.</span>setSelectionRange input-field <span class="integer">0</span> (<span class="keyword">..</span> input-field -value -length))))}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Highlight All</span><span class="delimiter">&quot;</span></span>))))

(<span class="keyword">def</span> <span class="function">ui-click-to-edit</span> (comp/factory ClickToEditField))

(defsc Root [this {<span class="symbol">:keys</span> [field] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:field</span> (comp/get-query ClickToEditField)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:field</span> {}}}
  (ui-click-to-edit field))</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The older string support for refs is still present, but will not be supported in future versions. Use the
function-based version of refs and port old code to that to avoid future problems.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_taking_control_of_the_sub_dom_d3_etc"><a class="anchor" href="#_taking_control_of_the_sub_dom_d3_etc"></a><a class="link" href="#_taking_control_of_the_sub_dom_d3_etc">4.8.2. Taking control of the sub-DOM (D3, etc)</a></h4>
<div class="paragraph">
<p>Libraries like D3 are great for dynamic visualizations, but they need full control
of the portion of the DOM that they create and manipulate.</p>
</div>
<div class="paragraph">
<p>In general this means that your <code>render</code> method should be called once
(and only once) to install the base DOM onto which the other library
will control.</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say we wanted to use D3 to render things. We&#8217;d first
write a function that would take the <strong>real</strong> DOM node and the incoming
props:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">db-render</span> [DOM-NODE props] <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function should do everything necessary to render the sub-dom (and
update it if the props change). Then we&#8217;d wrap that under a component that
doesn&#8217;t allow React to refresh that sub-tree via <code>shouldComponentUpdate</code>.</p>
</div>
<div class="paragraph">
<p>Below is a demo of this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. <a id="D3"></a><a href="#D3">D3</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('ui-d3')">Focus Inspector</button>
<div class="short narrow example" id="ui-d3"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.ui.d3-example</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    <span class="comment">;; REQUIRES shadow-cljs, with &quot;d3&quot; in package.json</span>
    [<span class="string"><span class="delimiter">&quot;</span><span class="content">d3</span><span class="delimiter">&quot;</span></span> <span class="symbol">:as</span> d3]
    [goog.object <span class="symbol">:as</span> gobj]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]))

(<span class="keyword">defn</span> <span class="function">render-squares</span> [dom-node props]
  (<span class="keyword">let</span> [svg       (<span class="keyword">-&gt;</span> d3 (<span class="keyword">.</span>select dom-node))
        data      (clj-&gt;js (<span class="symbol">:squares</span> props))
        selection (<span class="keyword">-&gt;</span> svg
                    (<span class="keyword">.</span>selectAll <span class="string"><span class="delimiter">&quot;</span><span class="content">rect</span><span class="delimiter">&quot;</span></span>)
                    (<span class="keyword">.</span>data data (<span class="keyword">fn</span> [d] (<span class="keyword">.</span>-id d))))]
    (<span class="keyword">-&gt;</span> selection
      <span class="keyword">.</span>enter
      (<span class="keyword">.</span>append <span class="string"><span class="delimiter">&quot;</span><span class="content">rect</span><span class="delimiter">&quot;</span></span>)
      (<span class="keyword">.</span>style <span class="string"><span class="delimiter">&quot;</span><span class="content">fill</span><span class="delimiter">&quot;</span></span> (<span class="keyword">fn</span> [d] (<span class="keyword">.</span>-color d)))
      (<span class="keyword">.</span>attr <span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span>)
      (<span class="keyword">.</span>attr <span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span>)
      <span class="keyword">.</span>transition
      (<span class="keyword">.</span>attr <span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span> (<span class="keyword">fn</span> [d] (<span class="keyword">.</span>-x d)))
      (<span class="keyword">.</span>attr <span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span> (<span class="keyword">fn</span> [d] (<span class="keyword">.</span>-y d)))
      (<span class="keyword">.</span>attr <span class="string"><span class="delimiter">&quot;</span><span class="content">width</span><span class="delimiter">&quot;</span></span> (<span class="keyword">fn</span> [d] (<span class="keyword">.</span>-size d)))
      (<span class="keyword">.</span>attr <span class="string"><span class="delimiter">&quot;</span><span class="content">height</span><span class="delimiter">&quot;</span></span> (<span class="keyword">fn</span> [d] (<span class="keyword">.</span>-size d))))
    (<span class="keyword">-&gt;</span> selection
      <span class="keyword">.</span>exit
      <span class="keyword">.</span>transition
      (<span class="keyword">.</span>style <span class="string"><span class="delimiter">&quot;</span><span class="content">opacity</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span>)
      <span class="keyword">.</span><span class="keyword">remove</span>)
    <span class="predefined-constant">false</span>))

(defsc D3Thing [this props]
  {<span class="symbol">:componentDidMount</span>     (<span class="keyword">fn</span> [this]
                            (<span class="keyword">when-let</span> [dom-node (gobj/get this <span class="string"><span class="delimiter">&quot;</span><span class="content">svg</span><span class="delimiter">&quot;</span></span>)]
                              (render-squares dom-node (comp/props this))))
   <span class="symbol">:shouldComponentUpdate</span> (<span class="keyword">fn</span> [this next-props next-state]
                            (<span class="keyword">when-let</span> [dom-node (gobj/get this <span class="string"><span class="delimiter">&quot;</span><span class="content">svg</span><span class="delimiter">&quot;</span></span>)]
                              (render-squares dom-node next-props))
                            <span class="predefined-constant">false</span>)}
  (dom/svg {<span class="symbol">:style</span>   {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">rgb(240,240,240)</span><span class="delimiter">&quot;</span></span>}
            <span class="symbol">:width</span>   <span class="integer">200</span> <span class="symbol">:height</span> <span class="integer">200</span>
            <span class="symbol">:ref</span>     (<span class="keyword">fn</span> [r] (gobj/set this <span class="string"><span class="delimiter">&quot;</span><span class="content">svg</span><span class="delimiter">&quot;</span></span> r))
            <span class="symbol">:viewBox</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">0 0 1000 1000</span><span class="delimiter">&quot;</span></span>}))

(<span class="keyword">def</span> <span class="function">d3-thing</span> (comp/factory D3Thing))

(<span class="keyword">defn</span> <span class="function">random-square</span> []
  {
   <span class="symbol">:id</span>    (<span class="keyword">rand-int</span> <span class="integer">10000000</span>)
   <span class="symbol">:x</span>     (<span class="keyword">rand-int</span> <span class="integer">900</span>)
   <span class="symbol">:y</span>     (<span class="keyword">rand-int</span> <span class="integer">900</span>)
   <span class="symbol">:size</span>  (<span class="keyword">+</span> <span class="integer">50</span> (<span class="keyword">rand-int</span> <span class="integer">300</span>))
   <span class="symbol">:color</span> (<span class="keyword">case</span> (<span class="keyword">rand-int</span> <span class="integer">5</span>)
            <span class="integer">0</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">yellow</span><span class="delimiter">&quot;</span></span>
            <span class="integer">1</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">green</span><span class="delimiter">&quot;</span></span>
            <span class="integer">2</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">orange</span><span class="delimiter">&quot;</span></span>
            <span class="integer">3</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">blue</span><span class="delimiter">&quot;</span></span>
            <span class="integer">4</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">black</span><span class="delimiter">&quot;</span></span>)})

(defmutation add-square [params]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state update <span class="symbol">:squares</span> <span class="keyword">conj</span> (random-square))))

(defmutation clear-squares [params]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state <span class="keyword">assoc</span> <span class="symbol">:squares</span> [])))

(defsc Root [this props]
  {<span class="symbol">:query</span>         [<span class="symbol">:squares</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:squares</span> []}}
  (dom/div
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this
                             `[(add-square {})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Add Random Square</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this
                             `[(clear-squares {})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Clear</span><span class="delimiter">&quot;</span></span>)
    (dom/br)
    (dom/br)
    (d3-thing props)))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The things to note for this example are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We override the React lifecycle method <code>shouldComponentUpdate</code> to return false. This tells React to never ever call
render once the component is mounted. D3 is in control of the underlying stuff.</p>
</li>
<li>
<p>We override <code>componentWillReceiveProps</code> and <code>componentDidMount</code> to do the actual D3 render/update. The former will
get incoming data changes, and the latter is called on initial mount. Our render method
delegates all of the hard work to D3.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_dynamically_rendering_into_a_canvas"><a class="anchor" href="#_dynamically_rendering_into_a_canvas"></a><a class="link" href="#_dynamically_rendering_into_a_canvas">4.8.3. Dynamically rendering into a canvas</a></h4>
<div class="paragraph">
<p>Sometimes you need to use component-local state to avoid the overhead in running a query to feed props. An example
of this is when handing mouse interactions like drag. You&#8217;ll typically use React refs to grab the actual low-level canvas.</p>
</div>
<div class="paragraph">
<p>The <code>set-state!</code> function is a Fulcro wrapper of React&#8217;s <code>setState</code>, but it let&#8217;s you use cljs maps instead of
js ones. The shallow merge described by React is honored as if you used an updater function (there is no need
for an updater function). The <code>set-state!</code> also allows a callback to give you full React compatibility. Note, however,
that React 16&#8217;s <code>setState</code> schedules a state update and render. It is not guaranteed to be immediate.</p>
</div>
<div class="paragraph">
<p>The <code>update-state!</code> function in Fulcro is like Clojurescripts <code>swap!</code> function, and uses <code>set-state!</code> behind the
scenes.</p>
</div>
<div class="paragraph">
<p>The following code is an example using component local state to render a box that follows the hover position
of the mouse.</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. <a id="DrawinginaCanvas"></a><a href="#DrawinginaCanvas">Drawing in a Canvas</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('hover-example')">Focus Inspector</button>
<div class="short narrow example" id="hover-example"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.ui.hover-example</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc initial-state]]
    [goog.object <span class="symbol">:as</span> gobj]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

(<span class="keyword">defn</span> <span class="function">change-size*</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Change the size of the canvas by some (pos or neg) amount..</span><span class="delimiter">&quot;</span></span>
  [state-map amount]
  (<span class="keyword">let</span> [current-size (<span class="keyword">get-in</span> state-map [<span class="symbol">:child/by-id</span> <span class="integer">0</span> <span class="symbol">:size</span>])
        new-size     (<span class="keyword">+</span> amount current-size)]
    (<span class="keyword">assoc-in</span> state-map [<span class="symbol">:child/by-id</span> <span class="integer">0</span> <span class="symbol">:size</span>] new-size)))

<span class="comment">; Make the canvas smaller. This will cause</span>
(defmutation ^<span class="symbol">:intern</span> make-smaller [p]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state change-size* <span class="integer">-20</span>)))

(defmutation ^<span class="symbol">:intern</span> make-bigger [p]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state change-size* <span class="integer">20</span>)))

(defmutation ^<span class="symbol">:intern</span> update-marker [{<span class="symbol">:keys</span> [coords]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state <span class="keyword">assoc-in</span> [<span class="symbol">:child/by-id</span> <span class="integer">0</span> <span class="symbol">:marker</span>] coords)))


(<span class="keyword">defn</span> <span class="function">event-&gt;dom-coords</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Translate a javascript evt to a clj [x y] within the given dom element.</span><span class="delimiter">&quot;</span></span>
  [evt dom-ele]
  (<span class="keyword">let</span> [cx (<span class="keyword">.</span>-clientX evt)
        cy (<span class="keyword">.</span>-clientY evt)
        BB (<span class="keyword">.</span>getBoundingClientRect dom-ele)
        x  (<span class="keyword">-</span> cx (<span class="keyword">.</span>-left BB))
        y  (<span class="keyword">-</span> cy (<span class="keyword">.</span>-top BB))]
    [x y]))

(<span class="keyword">defn</span> <span class="function">event-&gt;normalized-coords</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Translate a javascript evt to a clj [x y] within the given dom element as normalized (0 to 1) coordinates.</span><span class="delimiter">&quot;</span></span>
  [evt dom-ele]
  (<span class="keyword">let</span> [cx (<span class="keyword">.</span>-clientX evt)
        cy (<span class="keyword">.</span>-clientY evt)
        BB (<span class="keyword">.</span>getBoundingClientRect dom-ele)
        w  (<span class="keyword">-</span> (<span class="keyword">.</span>-right BB) (<span class="keyword">.</span>-left BB))
        h  (<span class="keyword">-</span> (<span class="keyword">.</span>-bottom BB) (<span class="keyword">.</span>-top BB))
        x  (<span class="keyword">/</span> (<span class="keyword">-</span> cx (<span class="keyword">.</span>-left BB))
             w)
        y  (<span class="keyword">/</span> (<span class="keyword">-</span> cy (<span class="keyword">.</span>-top BB))
             h)]
    [x y]))

(<span class="keyword">defn</span> <span class="function">render-hover-and-marker</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Render the graphics in the canvas. Pass the component props and state. </span><span class="delimiter">&quot;</span></span>
  [canvas props coords]
  (<span class="keyword">let</span> [marker             (<span class="symbol">:marker</span> props)
        size               (<span class="symbol">:size</span> props)
        real-marker-coords (mapv (<span class="keyword">partial</span> <span class="keyword">*</span> size) marker)
        <span class="comment">; See HTML5 canvas docs</span>
        ctx                (<span class="keyword">.</span>getContext canvas <span class="string"><span class="delimiter">&quot;</span><span class="content">2d</span><span class="delimiter">&quot;</span></span>)
        clear              (<span class="keyword">fn</span> []
                             (set! (<span class="keyword">.</span>-fillStyle ctx) <span class="string"><span class="delimiter">&quot;</span><span class="content">white</span><span class="delimiter">&quot;</span></span>)
                             (<span class="keyword">.</span>fillRect ctx <span class="integer">0</span> <span class="integer">0</span> size size))
        drawHover          (<span class="keyword">fn</span> []
                             (set! (<span class="keyword">.</span>-strokeStyle ctx) <span class="string"><span class="delimiter">&quot;</span><span class="content">gray</span><span class="delimiter">&quot;</span></span>)
                             (<span class="keyword">.</span>strokeRect ctx (<span class="keyword">-</span> (<span class="keyword">first</span> coords) <span class="integer">5</span>) (<span class="keyword">-</span> (<span class="keyword">second</span> coords) <span class="integer">5</span>) <span class="integer">10</span> <span class="integer">10</span>))
        drawMarker         (<span class="keyword">fn</span> []
                             (set! (<span class="keyword">.</span>-strokeStyle ctx) <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>)
                             (<span class="keyword">.</span>strokeRect ctx (<span class="keyword">-</span> (<span class="keyword">first</span> real-marker-coords) <span class="integer">5</span>) (<span class="keyword">-</span> (<span class="keyword">second</span> real-marker-coords) <span class="integer">5</span>) <span class="integer">10</span> <span class="integer">10</span>))]
    (<span class="keyword">.</span>save ctx)
    (clear)
    (drawHover)
    (drawMarker)
    (<span class="keyword">.</span>restore ctx)))

(<span class="keyword">defn</span> <span class="function">place-marker</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Update the marker in app state. Derives normalized coordinates, and updates the marker in application state.</span><span class="delimiter">&quot;</span></span>
  [child evt]
  (<span class="keyword">let</span> [canvas (gobj/get child <span class="string"><span class="delimiter">&quot;</span><span class="content">canvas</span><span class="delimiter">&quot;</span></span>)]
    (comp/transact! child `[(update-marker
                              {<span class="symbol">:coords</span> ~(event-&gt;normalized-coords evt canvas)})])))

(<span class="keyword">defn</span> <span class="function">hover-marker</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Updates the hover location of a proposed marker using canvas coordinates. Hover location
   is stored in component local state (meaning that a low-level app database query will not
   run to do the render that responds to this change)</span><span class="delimiter">&quot;</span></span>
  [child evt]
  (<span class="keyword">let</span> [canvas         (gobj/get child <span class="string"><span class="delimiter">&quot;</span><span class="content">canvas</span><span class="delimiter">&quot;</span></span>)
        updated-coords (event-&gt;dom-coords evt canvas)]
    (comp/set-state! child {<span class="symbol">:coords</span> updated-coords})
    (render-hover-and-marker canvas (comp/props child) updated-coords)))

(defsc Child [this {<span class="symbol">:keys</span> [id size] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span>          [<span class="symbol">:id</span> <span class="symbol">:size</span> <span class="symbol">:marker</span>]
   <span class="symbol">:initial-state</span>  (<span class="keyword">fn</span> [_] {<span class="symbol">:id</span> <span class="integer">0</span> <span class="symbol">:size</span> <span class="integer">50</span> <span class="symbol">:marker</span> [<span class="float">0.5</span> <span class="float">0.5</span>]})
   <span class="symbol">:ident</span>          (<span class="keyword">fn</span> [] [<span class="symbol">:child/by-id</span> id])
   <span class="symbol">:initLocalState</span> (<span class="keyword">fn</span> [this _] {<span class="symbol">:coords</span> [<span class="integer">-50</span> <span class="integer">-50</span>]})}
  <span class="comment">; Remember that this &quot;render&quot; just renders the DOM (e.g. the canvas DOM element). The graphical</span>
  <span class="comment">; rendering within the canvas is done during event handling.</span>
  <span class="comment">; size comes from props. Transactions on size will cause the canvas to resize in the DOM</span>
  (<span class="keyword">when-let</span> [canvas (gobj/get this <span class="string"><span class="delimiter">&quot;</span><span class="content">canvas</span><span class="delimiter">&quot;</span></span>)]
    (render-hover-and-marker canvas props (comp/get-state this <span class="symbol">:coords</span>)))
  (dom/canvas {<span class="symbol">:width</span>       (<span class="keyword">str</span> size <span class="string"><span class="delimiter">&quot;</span><span class="content">px</span><span class="delimiter">&quot;</span></span>)
               <span class="symbol">:height</span>      (<span class="keyword">str</span> size <span class="string"><span class="delimiter">&quot;</span><span class="content">px</span><span class="delimiter">&quot;</span></span>)
               <span class="symbol">:onMouseDown</span> (<span class="keyword">fn</span> [evt] (place-marker this evt))
               <span class="symbol">:onMouseMove</span> (<span class="keyword">fn</span> [evt] (hover-marker this evt))
               <span class="comment">; This is a pure React mechanism for getting the underlying DOM element.</span>
               <span class="comment">; Note: when the DOM element changes this fn gets called with nil</span>
               <span class="comment">; (to help you manage memory leaks), then the new element</span>
               <span class="symbol">:ref</span>         (<span class="keyword">fn</span> [r]
                              (<span class="keyword">when</span> r
                                (gobj/set this <span class="string"><span class="delimiter">&quot;</span><span class="content">canvas</span><span class="delimiter">&quot;</span></span> r)
                                (render-hover-and-marker r props (comp/get-state this <span class="symbol">:coords</span>))))
               <span class="symbol">:style</span>       {<span class="symbol">:border</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1px solid black</span><span class="delimiter">&quot;</span></span>}}))

(<span class="keyword">def</span> <span class="function">ui-child</span> (comp/factory Child))

(defsc Root [this {<span class="symbol">:keys</span> [child]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:child</span> (comp/get-query Child)}]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:ui/react-key</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">K</span><span class="delimiter">&quot;</span></span> <span class="symbol">:child</span> (comp/get-initial-state Child <span class="predefined-constant">nil</span>)})}
  (dom/div
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(make-bigger {})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Bigger!</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(make-smaller {})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Smaller!</span><span class="delimiter">&quot;</span></span>)
    (dom/br)
    (dom/br)
    (ui-child child)))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The component receives mouse move events to show a hover box. In this case we really don&#8217;t care to take the overhead
to track the cursor position in real app state, so we leverage component local state instead.
Clicking to save the box position and resizing the container are real transactions, and will actually cause
a refresh from application state to update the rendering.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_javascript_react_components"><a class="anchor" href="#_using_javascript_react_components"></a><a class="link" href="#_using_javascript_react_components">4.9. Using Javascript React Components</a></h3>
<div class="paragraph">
<p>One of the great parts about React is the ecosystem. There are some great libraries out there. Many libraries
will work without issue as long as you&#8217;re using shadow-cljs as your compiler;
However, the interop story isn&#8217;t always that easy. The goal of this section is to make that story a little clearer.</p>
</div>
<div class="sect3">
<h4 id="_factory_functions_for_js_react_components"><a class="anchor" href="#_factory_functions_for_js_react_components"></a><a class="link" href="#_factory_functions_for_js_react_components">4.9.1. Factory Functions for JS React Components</a></h4>
<div class="paragraph">
<p>You must understand React and the ecosystem. This book is not a tutorial on the fundamental js ecosystem.
Some important points to understand:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If you are importing third party components, you should be importing the class, not a factory.</p>
</li>
<li>
<p>You need to explicitly create react elements with factories. The relevant js functions are React.createElement,
and React.createFactory.</p>
<div class="ulist">
<ul>
<li>
<p>Children. JS does not have a built in notion of lazy sequences. Clojurescript does. This can create subtle bugs
when evaluating the children of a component. <code>com.fulcrologic.fulcro.algorithms.misc/force-children</code> helps us in this
regard by taking a seq and returning a vector.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can use this to create our own factory function, much like React.createFactory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">factory-force-children</span>
  [<span class="keyword">class</span>]
  (<span class="keyword">fn</span> [props &amp; children]
    (js/React.createElement <span class="keyword">class</span>
      props
      (util/force-children children))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is fine, but you will notice that children in our factory may be missing keys. Because we passed a vector in,
React won&#8217;t attach the key attribute. We can solve this problem by using the apply function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">factory-apply</span>
  [<span class="keyword">class</span>]
  (<span class="keyword">fn</span> [props &amp; children]
    (<span class="keyword">apply</span> js/React.createElement
      <span class="keyword">class</span>
      props
      children)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the apply function will pass the children in as args to <code>React.createElement</code>, thus avoiding the key problem
as well as the issue with lazy sequences.</p>
</div>
<div class="paragraph">
<p>Now that we have some background on creating React Elements it&#8217;s pretty simple to implement something.
Let' look at making a chart using Victory. We are going to make a simple line chart, with an X axis that contains
years, and a Y axis that contains dollar amounts. Really the data is irrelevant, it&#8217;s the implementation we care about.</p>
</div>
<div class="paragraph">
<p>The running code and source are below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. <a id="UsingExternalReactLibraries"></a><a href="#UsingExternalReactLibraries">Using External React Libraries</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('victory-example')">Focus Inspector</button>
<div class="short narrow example" id="victory-example"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.ui.victory-example</span>
  (<span class="symbol">:require</span>
    [cljs.pprint <span class="symbol">:refer</span> [cl-format]]
    <span class="comment">;; REQUIRES shadow-cljs, with &quot;victory&quot; in package.json</span>
    [<span class="string"><span class="delimiter">&quot;</span><span class="content">victory</span><span class="delimiter">&quot;</span></span> <span class="symbol">:refer</span> [VictoryChart VictoryAxis VictoryLine]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.algorithms.misc <span class="symbol">:as</span> util]
    [taoensso.timbre <span class="symbol">:as</span> log]))

(<span class="keyword">defn</span> <span class="function">us-dollars</span> [n]
  (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">$</span><span class="delimiter">&quot;</span></span> (cl-format <span class="predefined-constant">nil</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">~:d</span><span class="delimiter">&quot;</span></span> n)))

(<span class="keyword">defn</span> <span class="function">factory-force-children</span>
  [<span class="keyword">class</span>]
  (<span class="keyword">fn</span> [props &amp; children]
    (js/React.createElement <span class="keyword">class</span>
      props
      (util/force-children children))))

(<span class="keyword">defn</span> <span class="function">factory-apply</span>
  [<span class="keyword">class</span>]
  (<span class="keyword">fn</span> [props &amp; children]
    (<span class="keyword">apply</span> js/React.createElement
      <span class="keyword">class</span>
      props
      children)))

(<span class="keyword">def</span> <span class="function">vchart</span> (factory-apply VictoryChart))
(<span class="keyword">def</span> <span class="function">vaxis</span> (factory-apply VictoryAxis))
(<span class="keyword">def</span> <span class="function">vline</span> (factory-apply VictoryLine))

<span class="comment">;; &quot; [ {:year 1991 :value 2345 } ...] &quot;</span>
(defsc YearlyValueChart [this {<span class="symbol">:keys</span> [label plot-data x-step]}]
  (<span class="keyword">let</span> [start-year (<span class="keyword">apply</span> <span class="keyword">min</span> (<span class="keyword">map</span> <span class="symbol">:year</span> plot-data))
        end-year   (<span class="keyword">apply</span> <span class="keyword">max</span> (<span class="keyword">map</span> <span class="symbol">:year</span> plot-data))
        years      (<span class="keyword">range</span> start-year (<span class="keyword">inc</span> end-year) x-step)
        dates      (clj-&gt;js (mapv #(<span class="keyword">new</span> js/Date % <span class="integer">1</span> <span class="integer">2</span>) years))
        {<span class="symbol">:keys</span> [min-value
                max-value]} (<span class="keyword">reduce</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [min-value max-value] <span class="symbol">:as</span> acc}
                                         {<span class="symbol">:keys</span> [value] <span class="symbol">:as</span> n}]
                                      (<span class="keyword">assoc</span> acc
                                        <span class="symbol">:min-value</span> (<span class="keyword">min</span> min-value value)
                                        <span class="symbol">:max-value</span> (<span class="keyword">max</span> max-value value)))
                              {}
                              plot-data)
        min-value  (<span class="keyword">int</span> (<span class="keyword">*</span> <span class="float">0.8</span> min-value))
        max-value  (<span class="keyword">int</span> (<span class="keyword">*</span> <span class="float">1.2</span> max-value))
        points     (clj-&gt;js (mapv (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [year value]}]
                                    {<span class="symbol">:x</span> (<span class="keyword">new</span> js/Date year <span class="integer">1</span> <span class="integer">2</span>)
                                     <span class="symbol">:y</span> value})
                              plot-data))]
    (vchart <span class="predefined-constant">nil</span>
      (vaxis <span class="error">#</span>js {<span class="symbol">:label</span>      label
                  <span class="symbol">:standalone</span> <span class="predefined-constant">false</span>
                  <span class="symbol">:scale</span>      <span class="string"><span class="delimiter">&quot;</span><span class="content">time</span><span class="delimiter">&quot;</span></span>
                  <span class="symbol">:tickFormat</span> (<span class="keyword">fn</span> [d] (<span class="keyword">.</span>getFullYear d))
                  <span class="symbol">:tickValues</span> dates})
      (vaxis <span class="error">#</span>js {<span class="symbol">:dependentAxis</span> <span class="predefined-constant">true</span>
                  <span class="symbol">:standalone</span>    <span class="predefined-constant">false</span>
                  <span class="symbol">:tickFormat</span>    (<span class="keyword">fn</span> [y] (us-dollars y))
                  <span class="symbol">:domain</span>        <span class="error">#</span>js [min-value max-value]})
      (vline <span class="error">#</span>js {<span class="symbol">:data</span> points}))))

(<span class="keyword">def</span> <span class="function">yearly-value-chart</span> (comp/factory YearlyValueChart))

(defsc Root [this props]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:label</span>     <span class="string"><span class="delimiter">&quot;</span><span class="content">Yearly Value</span><span class="delimiter">&quot;</span></span>
                   <span class="symbol">:x-step</span>    <span class="integer">2</span>
                   <span class="symbol">:plot-data</span> [{<span class="symbol">:year</span> <span class="integer">1983</span> <span class="symbol">:value</span> <span class="integer">100</span>}
                               {<span class="symbol">:year</span> <span class="integer">1984</span> <span class="symbol">:value</span> <span class="integer">100</span>}
                               {<span class="symbol">:year</span> <span class="integer">1985</span> <span class="symbol">:value</span> <span class="integer">90</span>}
                               {<span class="symbol">:year</span> <span class="integer">1986</span> <span class="symbol">:value</span> <span class="integer">89</span>}
                               {<span class="symbol">:year</span> <span class="integer">1987</span> <span class="symbol">:value</span> <span class="integer">88</span>}
                               {<span class="symbol">:year</span> <span class="integer">1988</span> <span class="symbol">:value</span> <span class="integer">85</span>}
                               {<span class="symbol">:year</span> <span class="integer">1989</span> <span class="symbol">:value</span> <span class="integer">83</span>}
                               {<span class="symbol">:year</span> <span class="integer">1990</span> <span class="symbol">:value</span> <span class="integer">80</span>}
                               {<span class="symbol">:year</span> <span class="integer">1991</span> <span class="symbol">:value</span> <span class="integer">70</span>}
                               {<span class="symbol">:year</span> <span class="integer">1992</span> <span class="symbol">:value</span> <span class="integer">80</span>}
                               {<span class="symbol">:year</span> <span class="integer">1993</span> <span class="symbol">:value</span> <span class="integer">90</span>}
                               {<span class="symbol">:year</span> <span class="integer">1994</span> <span class="symbol">:value</span> <span class="integer">95</span>}
                               {<span class="symbol">:year</span> <span class="integer">1995</span> <span class="symbol">:value</span> <span class="integer">110</span>}
                               {<span class="symbol">:year</span> <span class="integer">1996</span> <span class="symbol">:value</span> <span class="integer">120</span>}
                               {<span class="symbol">:year</span> <span class="integer">1997</span> <span class="symbol">:value</span> <span class="integer">160</span>}
                               {<span class="symbol">:year</span> <span class="integer">1998</span> <span class="symbol">:value</span> <span class="integer">170</span>}
                               {<span class="symbol">:year</span> <span class="integer">1999</span> <span class="symbol">:value</span> <span class="integer">180</span>}
                               {<span class="symbol">:year</span> <span class="integer">2000</span> <span class="symbol">:value</span> <span class="integer">180</span>}
                               {<span class="symbol">:year</span> <span class="integer">2001</span> <span class="symbol">:value</span> <span class="integer">200</span>}]}}
  (dom/div
    (yearly-value-chart props)))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_function_as_a_child_pattern"><a class="anchor" href="#_the_function_as_a_child_pattern"></a><a class="link" href="#_the_function_as_a_child_pattern">4.9.2. The Function-As-a-Child Pattern</a></h4>
<div class="paragraph">
<p>A common pattern in React libraries is to use a function as a single child instead of an actual element. This
is an accepted and widely used pattern, but you need to do a simple extra step for it to work properly with
Fulcro. You see, Fulcro components use some behind-the-scenes bindings to allow for targeted UI rendering
optimizations, and when you embed them in a function that is invoked from external JS out of that context things
won&#8217;t work correctly.</p>
</div>
<div class="paragraph">
<p>For example, the <code>react-motion</code> library gives you React tools that can animate DOM motion. It animates variables
that you apply to nested DOM, and it does this through the function-as-a-child pattern. Here&#8217;s an example from
a <a href="https://github.com/awkay/fulcro-react-motion">demo project</a> (which uses shadow-cljs to get easy access to NPM
libraries):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">sample</span>
  (<span class="symbol">:require</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">react-motion</span><span class="delimiter">&quot;</span></span> <span class="symbol">:refer</span> [Motion spring]]
            [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
            [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
            [goog.object <span class="symbol">:as</span> gobj]))

(<span class="keyword">def</span> <span class="function">ui-motion</span> (factory-apply Motion))

(defsc Demo [this {<span class="symbol">:keys</span> [ui/slid? block]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:ui/slid?</span> {<span class="symbol">:block</span> (comp/get-query Block)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:ui/slid?</span> <span class="predefined-constant">false</span> <span class="symbol">:block</span> {<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">N</span><span class="delimiter">&quot;</span></span>}}
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:control</span> <span class="symbol">:demo</span>])}
  (dom/div
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [] (m/toggle! this <span class="symbol">:ui/slid?</span>))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Toggle</span><span class="delimiter">&quot;</span></span>)
    (ui-motion (clj-&gt;js {<span class="symbol">:style</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span> (spring (<span class="keyword">if</span> slid? <span class="integer">400</span> <span class="integer">0</span>))}})
      (<span class="keyword">fn</span> [p]
        (<span class="keyword">let</span> [x (gobj/get p <span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>)]
          <span class="comment">; The binding wrapper ensures that internal fulcro bindings are held within the lambda</span>
          (comp/with-parent-context this
            (dom/div <span class="symbol">:.</span>demo
              (ui-block (comp/computed block {<span class="symbol">:x</span> x})))))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The key is the call to <code>with-parent-context</code>. It causes the enclosed elements to have bindings pulled
from the component passed as the first parameter (in this case <code>this</code>).  Rendering will work
correctly without this wrapper, but interactions (particularly <code>transact!</code>) will not operate correctly
without it.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ColocatedCSS"><a class="anchor" href="#ColocatedCSS"></a><a class="link" href="#ColocatedCSS">4.10. Colocated CSS</a></h3>
<div class="paragraph">
<p>Please see <a href="https://github.com/fulcrologic/fulcro-garden-css">fulcro-garden-css</a> for a library
that allows you to co-locate CSS with Fulcro components.</p>
</div>
</div>
<div class="sect2">
<h3 id="_component_middleware"><a class="anchor" href="#_component_middleware"></a><a class="link" href="#_component_middleware">4.11. Component Middleware</a></h3>
<div class="paragraph">
<p>When creating a Fulcro application you have the option of setting two bits of
component middleware:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">app</span> (fulcro-app {<span class="symbol">:props-middleware</span> <span class="keyword">..</span><span class="keyword">.</span>
                      <span class="symbol">:render-middleware</span> <span class="keyword">..</span><span class="keyword">.</span>}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>These enable some advanced functionality for Fulcro without having to write your own
macro that deals with various internals.</p>
</div>
<div class="sect3">
<h4 id="_render_middleware"><a class="anchor" href="#_render_middleware"></a><a class="link" href="#_render_middleware">4.11.1. Render Middleware</a></h4>
<div class="paragraph">
<p>The render middleware is a function
(or chain of functions) with the general form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">fn</span> [this real-render]
   <span class="keyword">..</span><span class="keyword">.</span>
   (real-render))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The intention is that you can wrap or instrument/measure rendering.  For example, using
the <code>tufte</code> library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">my.ui</span>
  (<span class="symbol">:require</span>
    <span class="keyword">..</span><span class="keyword">.</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span>]
    [com.fulcrologic.fulcro.rendering.ident-optimized-render <span class="symbol">:refer</span> [render!]]
    [taoensso.tufte <span class="symbol">:as</span> tufte <span class="symbol">:refer</span> [p profile]]))

(tufte/add-basic-println-handler! {})

(<span class="keyword">defonce</span> <span class="function">SPA</span> (app/fulcro-app
               {<span class="symbol">:render-middleware</span> (<span class="keyword">fn</span> [this real-render]
                                     <span class="comment">;; record how long each component, by name, takes to render</span>
                                     (p {<span class="symbol">:id</span> (comp/component-name this)}
                                       (real-render)))
                <span class="symbol">:optimized-render!</span> (<span class="keyword">fn</span> render-performance
                                     ([app options]
                                      <span class="comment">;; capture the recordings and print a report at the end</span>
                                      (profile {}
                                        (render! app options)))
                                     ([app] (render-performance app {})))</code></pre>
</div>
</div>
<div class="paragraph">
<p>would print statistics like this to the Chrome developer&#8217;s console:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="raw">pId                  nCalls        Min      50% ≤      90% ≤      95% ≤      99% ≤        Max       Mean   MAD      Clock  Total

app.ui.root/Root          1        3ms        3ms        3ms        3ms        3ms        3ms        3ms   ±0%        3ms    17%
app.ui.root/User          1        0ns        0ns        0ns        0ns        0ns        0ns        0ns ±NaN%        0ns     0%

Accounted                                                                                                             3ms    17%
Clock                                                                                                                18ms   100%</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can <strong>see</strong> the component props using <code>comp/props</code> on the component you&#8217;re passed,
but you are not allowed to manipulate it.  Limited manipulation can be done via
the props middleware.</p>
</div>
</div>
<div class="sect3">
<h4 id="_extra_props_middleware"><a class="anchor" href="#_extra_props_middleware"></a><a class="link" href="#_extra_props_middleware">4.11.2. Extra Props Middleware</a></h4>
<div class="paragraph">
<p>The props middleware lets you manipulate the raw props that flow through your components.</p>
</div>
<div class="paragraph">
<p>This is an advanced functionality, since misuse could cause your application to fail to
work properly at all.</p>
</div>
<div class="paragraph">
<p>The primary use for this middleware is to allow libraries to extend the "extra" props
argument that <code>defsc</code> suppports.</p>
</div>
<div class="paragraph">
<p>The <code>defsc</code> macro actually supports up to four arguments: <code>this</code>, <code>props</code> , <code>computed</code>, and
<code>extra</code>.  This last arg is a map that can be filled by libraries that wish to more
tightly integrate with Fulcro&#8217;s component system.</p>
</div>
<div class="paragraph">
<p>Typically you&#8217;ll set such middleware something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">app</span> (app/fulcro-app
           {<span class="symbol">:props-middleware</span> (comp/wrap-update-extra-props
                                (<span class="keyword">fn</span> [cls extra-props]
                                   (<span class="keyword">assoc</span> extra-props <span class="symbol">:x</span> <span class="integer">1</span>)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>which then allows you to write components like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc MyComponent [this props computed {<span class="symbol">:keys</span> [x]]
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The "extra props" are actually encoded onto the internal raw js props of React,
so the most common operation is to leverage <code>wrap-update-extra-props</code> so you only
affect those.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_component_options"><a class="anchor" href="#_component_options"></a><a class="link" href="#_component_options">4.12. Component Options</a></h3>
<div class="paragraph">
<p>The component options map that appears after the argument list is just that: a plain map.  The
<code>defsc</code> macro adds a bit of magic to the three central items (<code>initial-state</code>, <code>query</code>, and
<code>ident</code>), but otherwise the map is open; that is to say you can add you own stuff to it, and
whatever you add will be available via <code>comp/component-options</code> on both the component class
and the instances.</p>
</div>
<div class="paragraph">
<p>This opens up all sorts of possibilities for extensions. The form-state library, component-local CSS,
and new dynamic router use this fact and add their own keys that only they use and know about.
You can too.</p>
</div>
</div>
<div class="sect2">
<h3 id="_react_higher_order_components"><a class="anchor" href="#_react_higher_order_components"></a><a class="link" href="#_react_higher_order_components">4.13. React Higher-Order Components</a></h3>
<div class="paragraph">
<p>When using external libraries with Fulcro you&#8217;ll often run into the higher-order component pattern.
<a href="https://reactjs.org/docs/higher-order-components.html">React Higher Order Components (HOC)</a> can be used with
<a href="http://fulcro.fulcrologic.com/">Fulcro</a> but due to how Fulcro works internally interop/glue code is needed.</p>
</div>
<div class="paragraph">
<p><a href="https://reactpatterns.com/#higher-order-component">Higher Order Components is a pattern in React</a> similar to the
<a href="https://en.wikipedia.org/wiki/Decorator_pattern">Decorator pattern</a> in object-oriented programming: you wrap one
component class with another component to decorate it with extra behaviour.</p>
</div>
<div class="paragraph">
<p>Some React reusable components provide HOC components to wrap cross cutting logic needed for the wrapped components to work.</p>
</div>
<div class="paragraph">
<p>For example <a href="https://github.com/fullstackreact/google-maps-react/">google-maps-react</a> provides <code>GoogleApiWrapper</code> HOC that handles
dynamic loading and initialisation of Google Maps Javascript library so it doesn&#8217;t have to be handled manually in every place where
Google Maps React component (like <code>Map</code> or <code>Marker</code>) is used. In this particular example, <code>GoogleApiWrapper</code> creates a wrapper
component class that behaves in the following way:
- it will display a placeholder "Loading" component and trigger Google Maps script loading and initialisation
- when the script loading and initialisation is complete it will replace "Loading" placeholder with the wrapped component</p>
</div>
<div class="sect3">
<h4 id="_fulcro_and_react_hoc"><a class="anchor" href="#_fulcro_and_react_hoc"></a><a class="link" href="#_fulcro_and_react_hoc">4.13.1. Fulcro and React HOC</a></h4>
<div class="paragraph">
<p>So what&#8217;s the issue with using React HOC in Fulcro Interop:
* Fulcro will embed React JS components (ones created by HOC)
* React JS HOC will wrap Fulcro components</p>
</div>
<div class="paragraph">
<p>In the first case React JS components (like these from google-maps-react) expect props to be plain JavaScript objects,
not ClojureScript maps. Fulcro components pass ClojureScript to nested components thus props need to be converted.
This part is described in Fulcro Book&#8217;s chapter on
<a href="http://book.fulcrologic.com/#_using_javascript_react_components">Factory Functions for JS React Components</a>.
All we need to do is to have a factory function that will do the conversion. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">hoc-example</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [<span class="string"><span class="delimiter">&quot;</span><span class="content">google-maps-react</span><span class="delimiter">&quot;</span></span> <span class="symbol">:refer</span> [GoogleApiWrapper Map Marker]]))

(<span class="keyword">defn</span> <span class="function">factory-apply</span> [js-component-class]
  (<span class="keyword">fn</span> [props &amp; children]
    (<span class="keyword">apply</span> js/React.createElement
           js-component-class
           <span class="comment">;; convert-props makes sure that props passed to React.createElement are plain JS object</span>
           (dom/convert-props props)
           children)))

<span class="comment">;; Fulcro wrapper factory for google-maps-react's Map component</span>
(<span class="keyword">def</span> <span class="function">ui-google-map</span> (factory-apply Map))

<span class="comment">;; Another wrapper factory for Marker component</span>
(<span class="keyword">def</span> <span class="function">ui-map-marker</span> (factory-apply Marker))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the second scenario we will have React JS component passing plain JS object props to our Fulcro component and we need to
add a layer that will do JS &#8594; Cljs props conversion.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create our sample Fulcro <code>LocationView</code> component. It queries for view title, location&#8217;s lat and lng and <code>google</code>
which is the Google Maps API object required by google-maps-react components. It&#8217;s managed by google-maps-react HOC wrapper
and provided in props passed in our wrapped component.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc LocationView [this {<span class="symbol">:keys</span> [title lat lng google]}]
  {<span class="symbol">:query</span> [<span class="symbol">:lat</span> <span class="symbol">:lng</span> <span class="symbol">:google</span>]}
  (dom/div
    (dom/h1 title)
    (dom/div {<span class="symbol">:style</span> {<span class="symbol">:width</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">250px</span><span class="delimiter">&quot;</span></span> <span class="symbol">:height</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">250px</span><span class="delimiter">&quot;</span></span>}}
      (ui-google-map {<span class="symbol">:google</span> google
                      <span class="symbol">:zoom</span> <span class="integer">15</span>
                      <span class="symbol">:initialCenter</span> {<span class="symbol">:lat</span> lat <span class="symbol">:lng</span> lng}
                      <span class="symbol">:style</span> {<span class="symbol">:width</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">90%</span><span class="delimiter">&quot;</span></span> <span class="symbol">:height</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">90%</span><span class="delimiter">&quot;</span></span>}}
        (ui-map-marker {<span class="symbol">:position</span> {<span class="symbol">:lat</span> lat <span class="symbol">:lng</span> lng}})))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we need to create a factory for our <code>LocationView</code>. It will need to sneak props as Cljs map so it&#8217;s available
for our wrapped <code>LocationView</code> component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">hoc-wrapper-factory-apply</span> [component-class]
  (<span class="keyword">fn</span> [props &amp; children]
    (<span class="keyword">apply</span> js/React.createElement
           component-class
           <span class="error">#</span>js {<span class="symbol">:hocFulcroCljPropsPassthrough</span> props}
           children)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also need <code>LocationView</code> factory that will get JS props received from HOC
and will recover our Cljs map props enhancing it also with <code>google</code> object provided by HOC. We use <a href="https://reactpatterns.com/#function-as-children">"function as child" React pattern</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; Plain Fulcro factory that will be used in our interop layer.</span>
<span class="comment">;; It won't be used directly in our client UI code.</span>
(<span class="keyword">def</span> <span class="function">ui-location-view-wrapped</span> (comp/factory LocationView)

(<span class="keyword">defn</span> <span class="function">ui-location-view-interop</span> [js-props]
  (<span class="keyword">let</span> [fulcro-clj-props (<span class="keyword">.</span>-hocFulcroCljPropsPassthrough js-props) <span class="comment">;; unwrapping Fulcro Cljs props wrapped by hoc-factory-apply</span>
        google (<span class="keyword">.</span>-google js-props) <span class="comment">;; we need to extract google object passed by google-maps-react HOC</span>
        props (<span class="keyword">assoc</span> fulcro-clj-props <span class="symbol">:google</span> google)] <span class="comment">;; final version of cljs props that has a proper format for our LocationView component</span>
    (ui-location-view-wrapped props)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can finally create a factory for <code>LocationView</code> component that will be used in our client UI code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">ui-location-view</span>
  <span class="comment">;; GoogleApiWrapper is a function returning HOC with specified configuration parameters like API key</span>
  <span class="comment">;; Notice that it's a plain JS function thus it requires its options to be plain JS map thus #js usage</span>
  (<span class="keyword">let</span> [hoc (GoogleApiWrapper <span class="error">#</span>js {<span class="symbol">:apiKey</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">AIzaSyDAiFHA9fwVjW83jUFjgL43D_KP9EFcIfE</span><span class="delimiter">&quot;</span></span>})
        WrappedLocationView (hoc ui-location-view-interop)]
    (hoc-wrapper-factory-apply WrappedLocationView)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can use our <code>LocationView</code> in our views:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(ui-location-view {<span class="symbol">:lat</span> <span class="float">37.778519</span> <span class="symbol">:lng</span> <span class="float">-122.405640</span>})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reusable_hoc_factory"><a class="anchor" href="#_reusable_hoc_factory"></a><a class="link" href="#_reusable_hoc_factory">4.13.2. Reusable HOC factory</a></h4>
<div class="paragraph">
<p><code>utils-hoc</code> namespace presented below provides a reusable <code>hoc-factory</code> that can be used to handle all
the boilerplate code and interop gluing. It supports <code>:extra-props-fn</code> in the opts argument that can be
used to customize the final props passed to the wrapped component. The code below shows its usage where <code>google</code> value
from <code>js-props</code> (injected by google-maps-react HOC wrapper) needs to be propagated under <code>:google</code> entry in Cljs
props passed to the wrapped <code>LocationView</code> component.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">utils.hoc</span>
  (<span class="symbol">:require</span>
    goog.object
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span>]))

(<span class="keyword">defn</span> <span class="function">hoc-factory</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Creates a factory for HOC wrapped component class.
  extra-props-fn allows for additional customization of props passed to the wrapped component. It will be provided
  plain js-props and cljs-props unwrapped from js-props and must return cljs-props with modified contents if needed.</span><span class="delimiter">&quot;</span></span>
  ([hoc-wrapper-fn wrapped-component-class]
   (hoc-factory hoc-wrapper-fn wrapped-component-class <span class="predefined-constant">nil</span>))
  ([hoc-wrapper-fn wrapped-component-class {<span class="symbol">:keys</span> [extra-props-fn]}]
   (<span class="keyword">let</span> [cljs-props-key (<span class="keyword">name</span> (<span class="keyword">gensym</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-cljs-props</span><span class="delimiter">&quot;</span></span>))
         wrapped-component-factory (comp/factory wrapped-component-class)
         js-&gt;clj-props-interop (<span class="keyword">fn</span> js-&gt;clj-props-interop [js-props]
                                 (<span class="keyword">let</span> [clj-props (goog.object/get js-props cljs-props-key)
                                       props (<span class="keyword">if</span> extra-props-fn
                                               (extra-props-fn js-props clj-props)
                                               clj-props)]
                                   (wrapped-component-factory props)))
         hoc-wrapped-component-class (hoc-wrapper-fn js-&gt;clj-props-interop)]
     (<span class="keyword">fn</span> [props &amp; children]
       (<span class="keyword">apply</span> js/React.createElement
         hoc-wrapped-component-class
         (js-obj cljs-props-key props)
         children)))))

(<span class="keyword">comment</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Example usage</span><span class="delimiter">&quot;</span></span>

  (defsc LocationView [this {<span class="symbol">:keys</span> [lat lon google]}]
    {<span class="symbol">:query</span> [<span class="symbol">:lat</span> <span class="symbol">:lon</span> <span class="symbol">:google</span>]}
    (dom/div {<span class="symbol">:style</span> {<span class="symbol">:width</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">250px</span><span class="delimiter">&quot;</span></span> <span class="symbol">:height</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">250px</span><span class="delimiter">&quot;</span></span>}}
      (ui-google-map {<span class="symbol">:zoom</span> <span class="integer">15</span>
                      <span class="symbol">:google</span> google
                      <span class="symbol">:initialCenter</span> {<span class="symbol">:lat</span> lat <span class="symbol">:lng</span> lon}
                      <span class="symbol">:style</span> {<span class="symbol">:width</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">90%</span><span class="delimiter">&quot;</span></span> <span class="symbol">:height</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">90%</span><span class="delimiter">&quot;</span></span>}}
      (ui-map-marker {<span class="symbol">:position</span> {<span class="symbol">:lat</span> lat <span class="symbol">:lng</span> lon}}))))

  (<span class="keyword">def</span> <span class="function">google-maps-hoc</span> (gmaps/google-api-wrapper <span class="error">#</span>js {<span class="symbol">:apiKey</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">AIzaSyDAiFHA9fwVjW83jUFjgL43D_KP9EFcIfE</span><span class="delimiter">&quot;</span></span>}))

  (<span class="keyword">def</span> <span class="function">ui-location-view</span>
    (hoc-factory
      google-maps-hoc
      LocationView
      {<span class="symbol">:extra-props-fn</span> (<span class="keyword">fn</span> propagate-google-api [js-props cljs-props]
                         (<span class="keyword">assoc</span> cljs-props <span class="symbol">:google</span> (goog.object/get js-props <span class="string"><span class="delimiter">&quot;</span><span class="content">google</span><span class="delimiter">&quot;</span></span>)))}))

  (ui-location-view {<span class="symbol">:lat</span> <span class="float">37.778519</span> <span class="symbol">:lng</span> <span class="float">-122.405640</span>}))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_eqlthe_query_and_mutation_language"><a class="anchor" href="#_eqlthe_query_and_mutation_language"></a><a class="link" href="#_eqlthe_query_and_mutation_language">5. EQL&#8201;&#8212;&#8201;The Query and Mutation Language</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before reading this chapter you should make sure you&#8217;ve read <a href="#GraphDB">The Graph Database Section</a>. It details
the low-level format of the application state, and talks about general details that
are referenced in this chapter.</p>
</div>
<div class="paragraph">
<p>In Fulcro all data is queried and manipulated from the UI using the EDN Query Language (EQL). EQL is a subset of
Datomic&#8217;s pull query syntax with extensions for unions and mutations. A query is a graph walk, so it is a relative notation: it must start at some specific spot,
but that spot is not always named in the query itself. On the client side the starting point is usually the root node
of your database. Thus,
a complete query from the Root UI component will be a graph query that can start at the root node of the database.</p>
</div>
<div class="paragraph">
<p>However, you&#8217;ll note that any query <strong>fragment</strong> is implied to be relative to where we are in the walk of the graph
database. This is important to understand: no component&#8217;s query can just be grabbed and run against the database
as-is. Then again, if you know the <code>ident</code> of a component, then you can <strong>start</strong> at that table entry in the database
and go from there.</p>
</div>
<div class="paragraph">
<p>The mutation portion of the language is a data representation of the abstract actions you&#8217;d like to take on the data model. It is
intended to be network agnostic: The UI need not be aware that a given mutation does local-only modifications and/or
remote operations against any number of remote servers. As such, the mutations, like queries, are simply data. Data
that can be interpreted by local logic, or data that can be sent over the wire to be interpreted by a server.</p>
</div>
<div class="paragraph">
<p>Queries can either be a vector or a map of vectors. The former is a regular component query, and the latter is
known as a <strong>union</strong> query. Union queries are useful when you&#8217;re walking a graph edge and the target could be
one of many different kinds of nodes, so you&#8217;re not sure which query to use until you actually are walking
the graph.</p>
</div>
<div class="sect2">
<h3 id="_properties"><a class="anchor" href="#_properties"></a><a class="link" href="#_properties">5.1. Properties</a></h3>
<div class="paragraph">
<p>The simplest thing to query are properties "right here" in the relative node of the graph. Properties are queried
by a simple keyword. Their values can be any scalar data value that is serializable in <a href="https://github.com/edn-format/edn">EDN</a>.</p>
</div>
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">:a</span> <span class="symbol">:b</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>is asking for the properties known as <code>:a</code> and <code>:b</code> at the "current node" in the graph traversal.</p>
</div>
</div>
<div class="sect2">
<h3 id="_joins"><a class="anchor" href="#_joins"></a><a class="link" href="#_joins">5.2. Joins</a></h3>
<div class="paragraph">
<p>A join represents a traversal of an edge to another node in the graph. The notation is a map with a single key
(the local key on the current node that holds the "pointer" to another node) whose single value is the
query for the remainder of the graph walk:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:children</span> (comp/get-query Child)}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The query itself cannot specify that this is a to-one or to-many join. The data in the <strong>database graph itself</strong>
determines the arity when the query is being run. Basically, if walking the join property leads to a vector of
links, it is to-many. If it leads to a single link, then it is to-one. Rendering the data is going
to have the same concern so the arity of the relation more strongly affects the rendering code.</p>
</div>
<div class="paragraph">
<p>Joins should always use <code>get-query</code> to get the next component in the graph. This annotates (with metadata) the sub-query
so that normalization can work correctly.</p>
</div>
</div>
<div class="sect2">
<h3 id="Unions"><a class="anchor" href="#Unions"></a><a class="link" href="#Unions">5.3. Unions</a></h3>
<div class="paragraph">
<p>Unions represent a map of queries, only one of which applies at a given graph edge. This is a form of
dynamic query that adjusts based on the actual linkage of data. Unions cannot stand alone.
They are meant to select one of many possible alternate queries when a link (to-one or to-many join) in the
graph is reached. Unions are always used in tandem with a join, and can therefore not be used on root-level
components. The union query itself is a map of the possible queries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc PersonPlaceOrThingUnion [this props]
  <span class="comment">; lambda form required for unions (a limitation of the error checking routines in defsc)</span>
  {<span class="symbol">:query</span> (<span class="keyword">fn</span> [] {<span class="symbol">:person/id</span> (comp/get-query Person)
                  <span class="symbol">:place/id</span> (comp/get-query Place)
                  <span class="symbol">:thing/id</span> (comp/get-query Thing)})}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and such a query must be joined by a parent component. Therefore, you&#8217;ll always end up with something
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Parent [this props]
  {<span class="symbol">:query</span> [{<span class="symbol">:person-place-or-thing</span> (comp/get-query PersonPlaceOrThingUnion)}]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Union queries take a little getting used to because there are a number of rules to follow when
using them in order for everything to work correctly (normalization, queries, and rendering).</p>
</div>
<div class="paragraph">
<p>Here is what a graph database might look like for the above query assuming we started at <code>Parent</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{ <span class="symbol">:person-place-or-thing</span> [<span class="symbol">:place/id</span> <span class="integer">3</span>]
  <span class="symbol">:place/id</span> { <span class="integer">3</span> { <span class="symbol">:place/id</span> <span class="integer">3</span> <span class="symbol">:location</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">New York</span><span class="delimiter">&quot;</span></span> }}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The query would start at the root. When it saw the join it would detect a union. The union would be resolved
by looking at the <strong>first</strong> element of the <strong>ident in the database</strong> (in this case <code>:place</code> from <code>[:place 3]</code>). That keyword
would then be used to select the <strong>query</strong> from the subcomponent union (in this example, <code>(comp/get-query Place)</code>).</p>
</div>
<div class="paragraph">
<p>Processing of the query then continues as normal as if the join was just on <code>Place</code>.</p>
</div>
<div class="paragraph">
<p>A to-many linkage works just as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{ <span class="symbol">:person-place-or-thing</span> [[<span class="symbol">:person/id</span> <span class="integer">1</span>] [<span class="symbol">:place/id</span> <span class="integer">3</span>]]
  <span class="symbol">:person/id</span> { <span class="integer">1</span> { <span class="symbol">:person/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Julie</span><span class="delimiter">&quot;</span></span> }}
  <span class="symbol">:place/id</span> { <span class="integer">3</span> { <span class="symbol">:place/id</span> <span class="integer">3</span> <span class="symbol">:place/location</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">New York</span><span class="delimiter">&quot;</span></span> }}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and now you have a mixed to-many relationship where the correct sub-query will be used for each item in turn.</p>
</div>
<div class="paragraph">
<p>Normalization of unions requires that the union component <strong>itself</strong> have an ident function that can properly
generate idents for <strong>all of the possible kinds of things that could be found</strong>. Often this means that you&#8217;ll need
to encode some kind of type indicator in the data itself.</p>
</div>
<div class="paragraph">
<p>Say you had this incoming tree of data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person-place-or-thing</span> [ {<span class="symbol">:person/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>} {<span class="symbol">:place/id</span> <span class="integer">3</span> <span class="symbol">:place/location</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">New York</span><span class="delimiter">&quot;</span></span>} ]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to normalize this correctly we need to end up with the correct <code>person</code> and <code>place</code> idents. The resulting
ident function might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc PersonPlaceOrThingUnion [this props]
  {<span class="symbol">:ident</span> (<span class="keyword">fn</span> []
    (<span class="keyword">cond</span>
      (<span class="keyword">contains?</span> props <span class="symbol">:person/id</span>) [<span class="symbol">:person/id</span> (<span class="symbol">:person/id</span> props)]
      (<span class="keyword">contains?</span> props <span class="symbol">:place/id</span>) [<span class="symbol">:place/id</span> (<span class="symbol">:place/id</span> props)]
      <span class="symbol">:else</span> [<span class="symbol">:thing/id</span> (<span class="symbol">:thing/id</span> props)]))}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rendering the correct thing in the UI of the union component has the same concern: you must detect what
kind of data (among the options) that you actually receive, and pass that on to the correct child factory (e.g.
<code>ui-person</code>, <code>ui-place</code>, or <code>ui-thing</code>.</p>
</div>
<div class="sect3">
<h4 id="_demo_using_unions_as_a_ui_type_selector"><a class="anchor" href="#_demo_using_unions_as_a_ui_type_selector"></a><a class="link" href="#_demo_using_unions_as_a_ui_type_selector">5.3.1. Demo – Using Unions as a UI Type Selector</a></h4>
<div class="paragraph">
<p>The <code>com.fulcrologic.fulcro.routing.legacy-ui-routers/defsc-router</code> macro (2.6.18+) emits a union component that can be switched to point at any kind
of component that it knows about. The support for parameterized routers in the routing tree makes it possible
to very easily reuse the UI router as a component that can show one of many screens in the same location.</p>
</div>
<div class="paragraph">
<p>This is particularly useful when you have a list of items that have varying types, and you&#8217;d like to, for example,
show the list on one side of the screen and the detail on the other.</p>
</div>
<div class="paragraph">
<p>To write such a thing one would follow these steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create one component for each item type that represents how it will look in the list.</p>
</li>
<li>
<p>Create one component for each item type that represents the fine detail view for that item.</p>
</li>
<li>
<p>Join (1) together into a union component and use it in a component that shows them as a list. In other words
the union will represent a to-many edge in your graph. Remember that unions cannot stand alone, so there
will be a union component (to switch the UI) and a list component to iterate through the items.</p>
</li>
<li>
<p>Combine the detail components from (2) into a <code>defsc-router</code> (e.g. with ID :detail-router).</p>
</li>
<li>
<p>Create a routing tree that includes the :detail-router, and parameterize both elements of the target ident (kind and id)</p>
</li>
<li>
<p>Hook a click event from the items to a <code>route-to</code> mutation, and send route parameters for the kind and id.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The output of the macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc-router ItemDetail [this props]
  {<span class="symbol">:router-id</span> <span class="symbol">:detail-router</span>
   <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:default-route</span> PersonDetail
   <span class="symbol">:router-targets</span> {<span class="symbol">:person/id</span> PersonDetail
                    <span class="symbol">:place/id</span> PlaceDetail
                    <span class="symbol">:thing/id</span> ThingDetail}}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Route not set</span><span class="delimiter">&quot;</span></span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>is roughly this (cleaned up from macro output):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc ItemDetail-Union [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] (comp/get-initial-state PersonDetail params)) <span class="comment">;; defaults to the first one listed</span>
   <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:query</span> (<span class="keyword">fn</span> [] {<span class="symbol">:person/id</span> (comp/get-query PersonDetail),
                  <span class="symbol">:place/id</span> (comp/get-query PlaceDetail),
                  <span class="symbol">:thing/id</span> (comp/get-query ThingDetail)}}
   (<span class="keyword">let</span> [page (<span class="keyword">first</span> (comp/get-ident this))]
    (<span class="keyword">case</span> page
     <span class="symbol">:person/id</span> ((comp/factory PersonDetail) (comp/props this))
     <span class="symbol">:place/id</span> ((comp/factory PlaceDetail) (comp/props this))
     <span class="symbol">:thing/id</span> ((comp/factory ThingDetail) (comp/props this))
     (dom/div (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot route: Unknown Screen </span><span class="delimiter">&quot;</span></span> page))))

(defsc ItemDetail [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:com.fulcrologic.fulcro.routing.legacy-ui-routers/id</span> <span class="symbol">:detail-router</span>
                                <span class="symbol">:com.fulcrologic.fulcro.routing.legacy-ui-routers/current-route</span> (comp/get-initial-state ItemDetail-Union params)})
   <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] [<span class="symbol">:com.fulcrologic.fulcro.routing.legacy-ui-routers.routers/id</span> <span class="symbol">:detail-router</span>])
   <span class="symbol">:query</span> [<span class="symbol">:com.fulcrologic.fulcro.routing.legacy-ui-routers/id</span> {<span class="symbol">:fulcro.client.routing/current-route</span> (comp/get-query ItemDetail-Union)}]}
  (<span class="keyword">let</span> [computed (comp/get-computed this)
        props (<span class="symbol">:com.fulcrologic.fulcro.routing.legacy-ui-routers/current-route</span> (comp/props this))
        props-with-computed (comp/computed props computed)]
   ((comp/factory ItemDetail-Union) props-with-computed)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that this just defines a union whose "selection" is controlled by the <code>:current-route</code> property!</p>
</div>
<div class="paragraph">
<p>Here is a complete working example that uses this to make a UI around displaying things of various types:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. <a id="UnionstoSelectType"></a><a href="#UnionstoSelectType">Unions to Select Type</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('union-example-1')">Focus Inspector</button>
<div class="short narrow example" id="union-example-1"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.queries.union-example-1</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom <span class="symbol">:refer</span> [div table td tr th tbody]]
    [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r <span class="symbol">:refer</span> [defsc-router]]
    [book.elements <span class="symbol">:as</span> ele]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [taoensso.timbre <span class="symbol">:as</span> log]))

(<span class="keyword">defn</span> <span class="function">person?</span> [props] (<span class="keyword">contains?</span> props <span class="symbol">:person/id</span>))
(<span class="keyword">defn</span> <span class="function">place?</span> [props] (<span class="keyword">contains?</span> props <span class="symbol">:place/id</span>))
(<span class="keyword">defn</span> <span class="function">thing?</span> [props] (<span class="keyword">contains?</span> props <span class="symbol">:thing/id</span>))

(<span class="keyword">defn</span> <span class="function">item-ident</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Generate an ident from a person, place, or thing.</span><span class="delimiter">&quot;</span></span>
  [props]
  (<span class="keyword">cond</span>
    (person? props) [<span class="symbol">:person/id</span> (<span class="symbol">:person/id</span> props)]
    (place? props) [<span class="symbol">:place/id</span> (<span class="symbol">:place/id</span> props)]
    (thing? props) [<span class="symbol">:thing/id</span> (<span class="symbol">:thing/id</span> props)]
    <span class="symbol">:else</span> (log/error <span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot generate a valid ident. Invalid props.</span><span class="delimiter">&quot;</span></span> props)))

(<span class="keyword">defn</span> <span class="function">item-key</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Generate a distinct react key for a person, place, or thing</span><span class="delimiter">&quot;</span></span>
  [props] (<span class="keyword">str</span> (item-ident props)))

(<span class="keyword">defn</span> <span class="function">make-person</span> [id n] {<span class="symbol">:person/id</span> id <span class="symbol">:person/name</span> n})
(<span class="keyword">defn</span> <span class="function">make-place</span> [id n] {<span class="symbol">:place/id</span> id <span class="symbol">:place/name</span> n})
(<span class="keyword">defn</span> <span class="function">make-thing</span> [id n] {<span class="symbol">:thing/id</span> id <span class="symbol">:thing/label</span> n})

(defsc PersonDetail [this {<span class="symbol">:person/keys</span> [id <span class="keyword">name</span>] <span class="symbol">:as</span> props}]
  <span class="comment">; defsc-router expects there to be an initial state for each possible target. We'll cause this to be a &quot;no selection&quot;</span>
  <span class="comment">; state so that the detail screen that starts out will show &quot;Nothing selected&quot;. We initialize all three in case</span>
  <span class="comment">; we later re-order them in the defsc-router.</span>
  {<span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:query</span>         [<span class="symbol">:person/id</span> <span class="symbol">:person/name</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:person/id</span> <span class="symbol">:no-selection</span>}}
  (dom/div
    (<span class="keyword">if</span> (<span class="keyword">=</span> id <span class="symbol">:no-selection</span>)
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Nothing selected</span><span class="delimiter">&quot;</span></span>
      (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Details about person </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))))

(defsc PlaceDetail [this {<span class="symbol">:place/keys</span> [id <span class="keyword">name</span>] <span class="symbol">:as</span> props}]
  {<span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:query</span>         [<span class="symbol">:place/id</span> <span class="symbol">:place/name</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:place/id</span> <span class="symbol">:no-selection</span>}}
  (dom/div
    (<span class="keyword">if</span> (<span class="keyword">=</span> id <span class="symbol">:no-selection</span>)
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Nothing selected</span><span class="delimiter">&quot;</span></span>
      (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Details about place </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))))

(defsc ThingDetail [this {<span class="symbol">:thing/keys</span> [id label] <span class="symbol">:as</span> props}]
  {<span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:query</span>         [<span class="symbol">:thing/id</span> <span class="symbol">:thing/label</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:thing/id</span> <span class="symbol">:no-selection</span>}}
  (dom/div
    (<span class="keyword">if</span> (<span class="keyword">=</span> id <span class="symbol">:no-selection</span>)
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Nothing selected</span><span class="delimiter">&quot;</span></span>
      (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Details about thing </span><span class="delimiter">&quot;</span></span> label))))

(defsc PersonListItem [this
                       {<span class="symbol">:person/keys</span> [id <span class="keyword">name</span>] <span class="symbol">:as</span> props}
                       {<span class="symbol">:keys</span> [onSelect] <span class="symbol">:as</span> computed}]
  {<span class="symbol">:ident</span> (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:query</span> [<span class="symbol">:person/id</span> <span class="symbol">:person/name</span>]}
  (dom/li {<span class="symbol">:onClick</span> #(onSelect (item-ident props))}
    (dom/a {} (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Person </span><span class="delimiter">&quot;</span></span> id <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))))

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory PersonListItem {<span class="symbol">:keyfn</span> item-key}))

(defsc PlaceListItem [this {<span class="symbol">:place/keys</span> [id <span class="keyword">name</span>] <span class="symbol">:as</span> props} {<span class="symbol">:keys</span> [onSelect] <span class="symbol">:as</span> computed}]
  {<span class="symbol">:ident</span> (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:query</span> [<span class="symbol">:place/id</span> <span class="symbol">:place/name</span>]}
  (dom/li {<span class="symbol">:onClick</span> #(onSelect (item-ident props))}
    (dom/a {} (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Place </span><span class="delimiter">&quot;</span></span> id <span class="string"><span class="delimiter">&quot;</span><span class="content"> : </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))))

(<span class="keyword">def</span> <span class="function">ui-place</span> (comp/factory PlaceListItem {<span class="symbol">:keyfn</span> item-key}))

(defsc ThingListItem [this {<span class="symbol">:thing/keys</span> [id label] <span class="symbol">:as</span> props} {<span class="symbol">:keys</span> [onSelect] <span class="symbol">:as</span> computed}]
  {<span class="symbol">:ident</span> (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:query</span> [<span class="symbol">:thing/id</span> <span class="symbol">:thing/label</span>]}
  (dom/li {<span class="symbol">:onClick</span> #(onSelect (item-ident props))}
    (dom/a {} (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Thing </span><span class="delimiter">&quot;</span></span> id <span class="string"><span class="delimiter">&quot;</span><span class="content"> : </span><span class="delimiter">&quot;</span></span> label))))

(<span class="keyword">def</span> <span class="function">ui-thing</span> (comp/factory ThingListItem item-key))

(defsc-router ItemDetail [this props]
  {<span class="symbol">:router-id</span>      <span class="symbol">:detail-router</span>
   <span class="symbol">:ident</span>          (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:default-route</span>  PersonDetail
   <span class="symbol">:router-targets</span> {<span class="symbol">:person/id</span> PersonDetail
                    <span class="symbol">:place/id</span>  PlaceDetail
                    <span class="symbol">:thing/id</span>  ThingDetail}}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">No route</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">def</span> <span class="function">ui-item-detail</span> (comp/factory ItemDetail))

(defsc ItemUnion [this props]
  {<span class="symbol">:ident</span> (<span class="keyword">fn</span> [] (item-ident props))
   <span class="symbol">:query</span> (<span class="keyword">fn</span> [] {<span class="symbol">:person/id</span> (comp/get-query PersonListItem)
                  <span class="symbol">:place/id</span>  (comp/get-query PlaceListItem)
                  <span class="symbol">:thing/id</span>  (comp/get-query ThingListItem)})}
  (<span class="keyword">cond</span>
    (person? props) (ui-person props)
    (place? props) (ui-place props)
    (thing? props) (ui-thing props)
    <span class="symbol">:else</span> (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Invalid ident used in app state.</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-item-union</span> (comp/factory ItemUnion {<span class="symbol">:keyfn</span> item-key}))

(defsc ItemList [this {<span class="symbol">:keys</span> [items]} {<span class="symbol">:keys</span> [onSelect]}]
  {
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p]
                    <span class="comment">; These would normally be loaded...but for demo purposes we just hand code a few</span>
                    {<span class="symbol">:items</span> [(make-person <span class="integer">1</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Tony</span><span class="delimiter">&quot;</span></span>)
                             (make-thing <span class="integer">2</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Toaster</span><span class="delimiter">&quot;</span></span>)
                             (make-place <span class="integer">3</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">New York</span><span class="delimiter">&quot;</span></span>)
                             (make-person <span class="integer">4</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>)
                             (make-thing <span class="integer">5</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Pillow</span><span class="delimiter">&quot;</span></span>)
                             (make-place <span class="integer">6</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Canada</span><span class="delimiter">&quot;</span></span>)]})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:lists/id</span> <span class="symbol">:singleton</span>])
   <span class="symbol">:query</span>         [{<span class="symbol">:items</span> (comp/get-query ItemUnion)}]}
  (dom/ul <span class="symbol">:.</span>ui.list
    (<span class="keyword">map</span> (<span class="keyword">fn</span> [i] (ui-item-union (comp/computed i {<span class="symbol">:onSelect</span> onSelect}))) items)))

(<span class="keyword">def</span> <span class="function">ui-item-list</span> (comp/factory ItemList))

(defsc Root [this {<span class="symbol">:keys</span> [item-list item-detail]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:item-list</span> (comp/get-query ItemList)}
                   {<span class="symbol">:item-detail</span> (comp/get-query ItemDetail)}]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] (<span class="keyword">merge</span>
                            (r/routing-tree
                              (r/make-route <span class="symbol">:detail</span> [(r/router-instruction <span class="symbol">:detail-router</span> [<span class="symbol">:param/kind</span> <span class="symbol">:param/id</span>])]))
                            {<span class="symbol">:item-list</span>   (comp/get-initial-state ItemList <span class="predefined-constant">nil</span>)
                             <span class="symbol">:item-detail</span> (comp/get-initial-state ItemDetail <span class="predefined-constant">nil</span>)}))}
  (<span class="keyword">let</span> [<span class="comment">; This is the only thing to do: Route the to the detail screen with the given route params!</span>
        showDetail (<span class="keyword">fn</span> [[kind id]]
                     (comp/transact! this `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:detail</span> <span class="symbol">:route-params</span> {<span class="symbol">:kind</span> ~kind <span class="symbol">:id</span> ~id}})]))]
    <span class="comment">; devcards, embed in iframe so we can use bootstrap css easily</span>
    (div {<span class="symbol">:key</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">example-frame-key</span><span class="delimiter">&quot;</span></span>}
      (dom/style <span class="string"><span class="delimiter">&quot;</span><span class="content">.boxed {border: 1px solid black}</span><span class="delimiter">&quot;</span></span>)
      (table <span class="symbol">:.</span>ui.table {}
        (tbody
          (tr
            (th <span class="string"><span class="delimiter">&quot;</span><span class="content">Items</span><span class="delimiter">&quot;</span></span>)
            (th <span class="string"><span class="delimiter">&quot;</span><span class="content">Detail</span><span class="delimiter">&quot;</span></span>))
          (tr
            (td (ui-item-list (comp/computed item-list {<span class="symbol">:onSelect</span> showDetail})))
            (td (ui-item-detail item-detail))))))))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Mutations"><a class="anchor" href="#Mutations"></a><a class="link" href="#Mutations">5.4. Mutations</a></h3>
<div class="paragraph">
<p>Mutations are also just data, as we mentioned earlier. However, they are intended to <strong>look like</strong> single-
argument function calls where the single argument is a map of parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[(do-something)]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main concern is that this expression, in normal Clojure, will be evaluated because it contains a raw list.
In order to keep it data, one must quote expressions with mutations. Of course you may use syntax quoting
or literal quoting. Usually we recommend namespacing your mutations (with <code>defmutation</code>) and then using
syntax quoting to get reasonably short expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.mutations</span>)

(defmutation do-something [params] <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span> [app.mutations <span class="symbol">:as</span> am]))

<span class="keyword">..</span><span class="keyword">.</span>
   (comp/transact! this `[(am/do-something {})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>We talked about <a href="#Transactions">syntax quoting transactions</a> in the Getting Started chapter. You may want to
review that or just read more online about Clojure syntax quoting.</p>
</div>
<div class="paragraph">
<p>The parameter map on mutations is optional, but recommended, if you&#8217;re using IDE support since the IDE will always
see mutations as if they were function calls with an arity of one.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters"><a class="anchor" href="#_parameters"></a><a class="link" href="#_parameters">5.5. Parameters</a></h3>
<div class="paragraph">
<p>Most of the query elements also support a parameter map. In Fulcro these are mainly useful when sending a query
to the server, and it is rare you will write such a query "by hand". However, for completeness you should know
what these look like. Basically, you just surround the property or join with parentheses, and add a map as
parameters. This is just like mutations, except instead of a symbol as the first element of the list it is either
a keyword (prop) or a map (join).</p>
</div>
<div class="paragraph">
<p>Thus a property can be parameterized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[(<span class="symbol">:prop</span> {<span class="symbol">:x</span> <span class="integer">1</span>})]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would cause, for example, a server&#8217;s query processing to see <code>{:x 1}</code> in the <code>params</code> when handling the read
for <code>:prop</code>.</p>
</div>
<div class="paragraph">
<p>A join is similarly parameterized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[({<span class="symbol">:child</span> (comp/get-query Child)} {<span class="symbol">:x</span> <span class="integer">1</span>})]</code></pre>
</div>
</div>
<div class="paragraph">
<p>with the same kind of effect.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The plain list has the same requirement as for mutations: quoting. Generally syntax quoting is again the best
choice, since you&#8217;ll often need unquoting. For example, the join example above would actually be written in code as:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">  <span class="keyword">..</span><span class="keyword">.</span>
  (query [this] `[({<span class="symbol">:child</span> ~(comp/get-query Child)} {<span class="symbol">:x</span> <span class="integer">1</span>})])
  <span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>to avoid trying to use the map as a function for execution, yet allowing the nested <code>get-query</code> to run and embed
the proper subquery.</p>
</div>
</div>
<div class="sect2">
<h3 id="_queries_on_idents"><a class="anchor" href="#_queries_on_idents"></a><a class="link" href="#_queries_on_idents">5.6. Queries on Idents</a></h3>
<div class="paragraph">
<p>Idents are valid in queries as a plain prop or a join. When used alone (not in a join) this will pull a table
entry from the database <strong>without normalizing it or following any subquery</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[ [<span class="symbol">:person/id</span> <span class="integer">1</span>] ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>results in something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Phone [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:id</span> <span class="symbol">:phone/number</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:phone/id</span> <span class="symbol">:id</span>]}
  <span class="keyword">..</span><span class="keyword">.</span>)

(defsc Person [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:id</span> {<span class="symbol">:person/phone</span> (comp/get-query Phone)}]
   <span class="symbol">:ident</span> [<span class="symbol">:person/id</span> <span class="symbol">:id</span>]}
  <span class="keyword">..</span><span class="keyword">.</span>)

(defsc X [this props]
  {<span class="symbol">:query</span> [ [<span class="symbol">:person/id</span> <span class="integer">1</span>] ] } <span class="comment">; query just for the ident</span>
  (<span class="keyword">let</span> [person (<span class="keyword">get</span> props [<span class="symbol">:person/id</span> <span class="integer">1</span>]) <span class="comment">; NOT get-in. The key of the result is an ident</span>
        <span class="keyword">..</span><span class="keyword">.</span>
        <span class="comment">; person contains {:id 1 :person/phone [:phone/id 4]}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is not typically what you want because you&#8217;d typically want it to follow the graph links (resolving phone number).</p>
</div>
<div class="paragraph">
<p>Therefore these kinds of queries are normally done via a join:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc X [this props]
  {<span class="symbol">:query</span> [{[<span class="symbol">:person/id</span> <span class="integer">1</span>] (comp/get-query Person)}]}
  (<span class="keyword">let</span> [person (<span class="keyword">get</span> props [<span class="symbol">:person/id</span> <span class="integer">1</span>])
        <span class="keyword">..</span><span class="keyword">.</span>
        <span class="comment">; person contains {:id 1 :person/phone {:phone/id 4 :phone/number &quot;555-1212&quot;}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This has the effect of "re-rooting" the graph walk at that ident&#8217;s table entry and continuing from there for the
rest of the subtree. In fact this is how Fulcro&#8217;s <a href="#RenderingOptimizations">ident-based rendering optimization</a> works.</p>
</div>
</div>
<div class="sect2">
<h3 id="_link_queries"><a class="anchor" href="#_link_queries"></a><a class="link" href="#_link_queries">5.7. Link Queries</a></h3>
<div class="paragraph">
<p>There are times when you want to start "back at the root" node. This is useful for pulling data that has
a singleton representation in the root node itself. For example, the current UI locale or currently logged-in
user. There is a special notation for this the looks like an ident without an ID:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[ [<span class="symbol">:ui/locale</span> '_] ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This component query would result in <code>:ui/locale</code> in your props (not an ident) with a value that came from the
overall root node of the database. Of course, denormalization just requires you use a join:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[ {[<span class="symbol">:current-user</span> '_] (comp/get-query Person)} ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>would pull <code>:current-user</code> into the component&#8217;s props with a continued walk of the graph. In other words this is
just like the ident join, except the special symbol <code>_</code> indicates there is only one of them and it is in the root
node.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_warning_about_ident_and_link_queries"><a class="anchor" href="#_a_warning_about_ident_and_link_queries"></a><a class="link" href="#_a_warning_about_ident_and_link_queries">5.8. A Warning About Ident and Link Queries</a></h3>
<div class="paragraph">
<p>Components can query for whatever they want, and sometimes it is useful to write components that <strong>only</strong> query
for things "elsewhere" in the database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc LocaleSwitcher [this {<span class="symbol">:keys</span> [ui/locale]}]
  {<span class="symbol">:query</span> [[<span class="symbol">:ui/locale</span> '_]]}
  (dom/div <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the database is constructed for such components they will have no state of their own.</p>
</div>
<div class="paragraph">
<p>Sadly, even if you compose it into your UI properly it may not receive any data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Root [this {<span class="symbol">:keys</span> [locale-switcher]}]
  {<span class="symbol">:query</span> [{<span class="symbol">:locale-switcher</span> (comp/get-query LocaleSwitcher)}]}
  (ui-locale-switcher locale-switcher)) <span class="comment">; data comes back nil!!!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is that the query engine walks the database and query in tandem. When it sees a join
(<code>:locale-switcher</code> in this case) it goes looking for an entry in the database <strong>at the current location</strong>
(root node in this case) to process the subquery against. If it finds an ident it follows it and processes
the subquery. If it is a map it uses that to fulfill the subquery. If it is a vector then it processes the
subquery against every entry. But if it is <em>missing</em> <strong>then it stops</strong>.</p>
</div>
<div class="paragraph">
<p>The fix is simple: make sure the component has a presence in the database, even if empty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc LocaleSwitcher [this {<span class="symbol">:keys</span> [ui/locale]}]
  {<span class="symbol">:query</span> [[<span class="symbol">:ui/locale</span> '_]]
   <span class="symbol">:initial-state</span> {}} <span class="comment">; empty map</span>
  (dom/div <span class="keyword">..</span><span class="keyword">.</span>))

(defsc Root [this {<span class="symbol">:keys</span> [locale-switcher]}]
  {<span class="symbol">:query</span> [{<span class="symbol">:locale-switcher</span> (comp/get-query LocaleSwitcher)}]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:locale-switcher</span> (comp/get-initial-state LocaleSwitcher)})} <span class="comment">; empty map from child</span>
  (ui-locale-switcher locale-switcher)) <span class="comment">; link query data is found/passed</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="SharedState"><a class="anchor" href="#SharedState"></a><a class="link" href="#SharedState">5.8.1. Using Shared State</a></h4>
<div class="paragraph">
<p>An alternative to ident and link queries is shared state. The first thing to note is that it is <strong>not</strong>
a complete replacement for link queries. It is a low-level feature that is meant for two basic scenarios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Data that needs to be visible to all components, but never changes once the app is mounted.</p>
</li>
<li>
<p>Data that is derived from the UI props (from root) or globals, but only updates on root-level renders (not component-local updates).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first use-case might be handy if you pass some data to your mount through the HTML page itself. The
latter is useful for data that affects everything in your application, such as the current user.</p>
</div>
<div class="paragraph">
<p>The primary thing to remember is that components that look at shared state will not see updates unless a
root render occurs with those updates. This typically means calling <code>comp/force-root-render!</code>.</p>
</div>
<div class="paragraph">
<p>Say we wanted all components to be able to see <code>:pi</code> (a constant) and <code>:current-user</code> (a value from
the database). We could declare this as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fc/make-fulcro-client
  {<span class="symbol">:reconciler-options</span> {<span class="symbol">:shared</span> {<span class="symbol">:pi</span> <span class="float">3.14</span>} <span class="comment">; never changes</span>
                        <span class="symbol">:shared-fn</span> #(<span class="keyword">select-keys</span> % <span class="symbol">:current-user</span>)}}) <span class="comment">; updates on root render</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now <strong>any</strong> component can access these as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc C [this props]
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [pi current-user]} (comp/shared this)]
    <span class="comment">; current-user will be DEnormalized...it comes from the root props (Root must query for it still)</span>
    <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Remember that this is <strong>not</strong> equivalent to a link query for <code>[:current-user '_]</code>. There are two differences.
The first is that pulling <code>:current-user</code> still requires that your root component query for it (or it
won&#8217;t even be in the props). Second, the shared value will not visibly change until a root render happens, where
link queries <strong>can</strong> refresh locally with a component. The final difference is that <strong>if</strong> you use data in
your shared-fn that is derived from anything other than the state database then it will not work correctly
in the history support viewer.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_recursive_queries"><a class="anchor" href="#_recursive_queries"></a><a class="link" href="#_recursive_queries">5.9. Recursive Queries</a></h3>
<div class="paragraph">
<p>EQL includes support for recursive queries. Recursion is <strong>always</strong> expressed on a join,
and it <strong>always</strong> means that the recursive item has the same type as the component you&#8217;re on.
There are two notations for this: <code>&#8230;&#8203;</code> and a number. The former means "recurse until there are no more links
(circular detection is included to prevent infinite loops)", and the other is the recursion limit:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
At the time of this writing you must use the lamba mode of <code>defsc</code> for queries that include recursion.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following demo (with source) demonstrates the core basics of recursion:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. <a id="RecursiveDemo1"></a><a href="#RecursiveDemo1">Recursive Demo 1</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('recursive-demo-1')">Focus Inspector</button>
<div class="short narrow example" id="recursive-demo-1"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.queries.recursive-demo-1</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
            [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

(<span class="keyword">defn</span> <span class="function">make-person</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Make a person data map with optional children.</span><span class="delimiter">&quot;</span></span>
  [id <span class="keyword">name</span> children]
  (cond-&gt; {<span class="symbol">:db/id</span> id <span class="symbol">:person/name</span> <span class="keyword">name</span>}
    children (<span class="keyword">assoc</span> <span class="symbol">:person/children</span> children)))

(<span class="keyword">declare</span> <span class="function">ui-person</span>)

<span class="comment">; The ... in the query means there will be children of the same type, of arbitrary depth</span>
<span class="comment">; it is equivalent to (comp/get-query Person), but calling get query on yourself would</span>
<span class="comment">; lead to infinite compiler recursion.</span>
(defsc Person [this {<span class="symbol">:keys</span> [<span class="symbol">:person/name</span> <span class="symbol">:person/children</span>]}]
  {<span class="symbol">:query</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:db/id</span> <span class="symbol">:person/name</span> {<span class="symbol">:person/children</span> '<span class="keyword">..</span><span class="keyword">.</span>}])
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p]
                    (make-person <span class="integer">1</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>
                      [(make-person <span class="integer">2</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Suzy</span><span class="delimiter">&quot;</span></span> [])
                       (make-person <span class="integer">3</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Billy</span><span class="delimiter">&quot;</span></span> [])
                       (make-person <span class="integer">4</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Rae</span><span class="delimiter">&quot;</span></span>
                         [(make-person <span class="integer">5</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Ian</span><span class="delimiter">&quot;</span></span>
                            [(make-person <span class="integer">6</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Zoe</span><span class="delimiter">&quot;</span></span> [])])])]))
   <span class="symbol">:ident</span>         [<span class="symbol">:person/id</span> <span class="symbol">:db/id</span>]}
  (dom/div
    (dom/h4 <span class="keyword">name</span>)
    (<span class="keyword">when</span> (<span class="keyword">seq</span> children)
      (dom/div
        (dom/ul
          (<span class="keyword">map</span> (<span class="keyword">fn</span> [p]
                 (ui-person p))
            children))))))

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [person-of-interest]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:person-of-interest</span> {}}
   <span class="symbol">:query</span>         [{<span class="symbol">:person-of-interest</span> (comp/get-query Person)}]}
  (dom/div
    (ui-person person-of-interest)))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_circular_recursion"><a class="anchor" href="#_circular_recursion"></a><a class="link" href="#_circular_recursion">5.9.1. Circular Recursion</a></h4>
<div class="paragraph">
<p>It is perfectly legal to include recursion in your graph, and it is equally fine to
query for it. The query engine will automatically stop if a loop is detected.</p>
</div>
<div class="paragraph">
<p>However, this is not the whole story. You see, components can be updated in a relative
fasion when all optimizations are enabled. This means that a refresh could happen anywhere
in the (recursive) UI, and the query would run until it detects the loop again. This can
lead to funny-looking results.</p>
</div>
<div class="paragraph">
<p>The demo below lets you modify people and their spouse (a circular relation). Try it out
and you&#8217;ll see that something isn&#8217;t quite right (try making Sally older):</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. <a id="RecursiveDemo2"></a><a href="#RecursiveDemo2">Recursive Demo 2</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('recursive-demo-2')">Focus Inspector</button>
<div class="short narrow example" id="recursive-demo-2"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.queries.recursive-demo-2</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
            [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]]
            [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

(<span class="keyword">declare</span> <span class="function">ui-person</span>)

(defmutation make-older [{<span class="symbol">:keys</span> [id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state <span class="keyword">update-in</span> [<span class="symbol">:person/id</span> id <span class="symbol">:person/age</span>] <span class="keyword">inc</span>)))

(defsc Person [this {<span class="symbol">:keys</span> [db/id person/name person/spouse person/age]}]
  {<span class="symbol">:query</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:db/id</span> <span class="symbol">:person/name</span> <span class="symbol">:person/age</span> {<span class="symbol">:person/spouse</span> <span class="integer">1</span>}]) <span class="comment">; force limit the depth</span>
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p]
                    <span class="comment">; this does look screwy...you can nest the same map in the recursive position,</span>
                    <span class="comment">; and it'll just merge into the one that was previously normalized during normalization.</span>
                    <span class="comment">; You need to do this or you won't get the loop in the database.</span>
                    {<span class="symbol">:db/id</span>         <span class="integer">1</span>
                     <span class="symbol">:person/name</span>   <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>
                     <span class="symbol">:person/age</span>    <span class="integer">20</span>
                     <span class="symbol">:person/spouse</span> {<span class="symbol">:db/id</span>         <span class="integer">2</span>
                                     <span class="symbol">:person/name</span>   <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>
                                     <span class="symbol">:person/age</span>    <span class="integer">22</span>
                                     <span class="symbol">:person/spouse</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>}}})
   <span class="symbol">:ident</span>         [<span class="symbol">:person/id</span> <span class="symbol">:db/id</span>]}
  (dom/div
    (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Name:</span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>)
    (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Age:</span><span class="delimiter">&quot;</span></span> age
      (dom/button {<span class="symbol">:onClick</span>
                   #(comp/transact! this `[(make-older {<span class="symbol">:id</span> ~id})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Make Older</span><span class="delimiter">&quot;</span></span>))
    (<span class="keyword">when</span> spouse
      (dom/ul
        (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Spouse:</span><span class="delimiter">&quot;</span></span> (ui-person spouse))))))

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [person-of-interest]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:person-of-interest</span> {}}
   <span class="symbol">:query</span>         [{<span class="symbol">:person-of-interest</span> (comp/get-query Person)}]}
  (dom/div
    (ui-person person-of-interest)))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The problem is that when you touch Sally the UI refresh updates <strong>just</strong> that component; however,
that component has a recursive query of depth 1, so it ends up returning Joe as her spouse! This
is technically correct, but almost certainly isn&#8217;t what you want!</p>
</div>
<div class="paragraph">
<p>The fix is equally simple: calculate depth and pass it to the child. Use the calculated depth
to prevent the extra rendering when local refresh gives you data you don&#8217;t need. The
demo below has this fix.</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. <a id="RecursiveDemo3"></a><a href="#RecursiveDemo3">Recursive Demo 3</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('recursive-demo-3')">Focus Inspector</button>
<div class="short narrow example" id="recursive-demo-3"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.queries.recursive-demo-3</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
            [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]]
            [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]))

(<span class="keyword">declare</span> <span class="function">ui-person</span>)

(defmutation make-older [{<span class="symbol">:keys</span> [id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state <span class="keyword">update-in</span> [<span class="symbol">:person/id</span> id <span class="symbol">:person/age</span>] <span class="keyword">inc</span>)))

<span class="comment">; We use computed to track the depth. Targeted refreshes will retain the computed they got on</span>
<span class="comment">; the most recent render. This allows us to detect how deep we are.</span>
(defsc Person [this
               {<span class="symbol">:keys</span> [db/id person/name person/spouse person/age]} <span class="comment">; props</span>
               {<span class="symbol">:keys</span> [render-depth] <span class="symbol">:or</span> {render-depth <span class="integer">0</span>}}] <span class="comment">; computed</span>
  {<span class="symbol">:query</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:db/id</span> <span class="symbol">:person/name</span> <span class="symbol">:person/age</span> {<span class="symbol">:person/spouse</span> <span class="integer">1</span>}]) <span class="comment">; force limit the depth</span>
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p]
                    {<span class="symbol">:db/id</span>         <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">20</span>
                     <span class="symbol">:person/spouse</span> {<span class="symbol">:db/id</span>         <span class="integer">2</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>
                                     <span class="symbol">:person/age</span>    <span class="integer">22</span>
                                     <span class="symbol">:person/spouse</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>}}})
   <span class="symbol">:ident</span>         [<span class="symbol">:person/id</span> <span class="symbol">:db/id</span>]}
  (dom/div
    (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Name:</span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>)
    (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Age:</span><span class="delimiter">&quot;</span></span> age
      (dom/button {<span class="symbol">:onClick</span>
                   #(comp/transact! this `[(make-older {<span class="symbol">:id</span> ~id})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Make Older</span><span class="delimiter">&quot;</span></span>))
    (<span class="keyword">when</span> (<span class="keyword">and</span> (<span class="keyword">=</span> <span class="integer">0</span> render-depth) spouse)
      (dom/ul
        (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Spouse:</span><span class="delimiter">&quot;</span></span>
          <span class="comment">; recursively render, but increase the render depth so we can know when a</span>
          <span class="comment">; targeted UI refresh would accidentally push the UI deeper.</span>
          (ui-person (comp/computed spouse {<span class="symbol">:render-depth</span> (<span class="keyword">inc</span> render-depth)})))))))

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [person-of-interest]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:person-of-interest</span> {}}
   <span class="symbol">:query</span>         [{<span class="symbol">:person-of-interest</span> (comp/get-query Person)}]}
  (dom/div
    (ui-person person-of-interest)))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_duplicates_and_recursion"><a class="anchor" href="#_duplicates_and_recursion"></a><a class="link" href="#_duplicates_and_recursion">5.9.2. Duplicates and Recursion</a></h4>
<div class="paragraph">
<p>Of course it is perfectly fine for there to be multiple edges in your graph that point
to the same node. Below is a recursive bullet list example. We&#8217;ve intentionally nested
item <code>B.1</code> under B and D so you can see that it all works itself out.</p>
</div>
<div class="paragraph">
<p>Normalization of initial state (which must be a tree) is perfectly happy to see duplcate
entries. It simply merges the multiple copies into the same normalized entry in the table.</p>
</div>
<div class="paragraph">
<p>Since the two entries merge to the same entry, it also means the modifications will
be shared among them. Try checking item <code>B.1</code> in either location.</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. <a id="RecursiveDemo4"></a><a href="#RecursiveDemo4">Recursive Demo 4</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('recursive-demo-bullets')">Focus Inspector</button>
<div class="short narrow example" id="recursive-demo-bullets"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.queries.recursive-demo-bullets</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
            [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
            [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
            [clojure.string <span class="symbol">:as</span> <span class="keyword">str</span>]))

(<span class="keyword">declare</span> <span class="function">ui-item</span>)

(defsc Item [this {<span class="symbol">:keys</span> [ui/checked? item/label item/subitems]}]
  {<span class="symbol">:query</span> (<span class="keyword">fn</span> [] [<span class="symbol">:ui/checked?</span> <span class="symbol">:db/id</span> <span class="symbol">:item/label</span> {<span class="symbol">:item/subitems</span> '<span class="keyword">..</span><span class="keyword">.</span>}])
   <span class="symbol">:ident</span> [<span class="symbol">:item/by-id</span> <span class="symbol">:db/id</span>]}
  (dom/li
    (dom/input {<span class="symbol">:type</span>     <span class="string"><span class="delimiter">&quot;</span><span class="content">checkbox</span><span class="delimiter">&quot;</span></span>
                <span class="symbol">:checked</span>  (<span class="keyword">if</span> (boolean? checked?) checked? <span class="predefined-constant">false</span>)
                <span class="symbol">:onChange</span> #(m/toggle! this <span class="symbol">:ui/checked?</span>)})
    label
    (<span class="keyword">when</span> subitems
      (dom/ul
        (<span class="keyword">map</span> ui-item subitems)))))

(<span class="keyword">def</span> <span class="function">ui-item</span> (comp/factory Item {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc ItemList [this {<span class="symbol">:keys</span> [db/id list/items] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> {<span class="symbol">:list/items</span> (comp/get-query Item)}]
   <span class="symbol">:ident</span> [<span class="symbol">:list/by-id</span> <span class="symbol">:db/id</span>]}
  (dom/ul
    (<span class="keyword">map</span> ui-item items)))

(<span class="keyword">def</span> <span class="function">ui-item-list</span> (comp/factory ItemList {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [<span class="keyword">list</span>]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p]
                    {<span class="symbol">:list</span> {<span class="symbol">:db/id</span>      <span class="integer">1</span>
                            <span class="symbol">:list/items</span> [{<span class="symbol">:db/id</span> <span class="integer">2</span> <span class="symbol">:item/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>
                                          <span class="symbol">:item/subitems</span>
                                                 [{<span class="symbol">:db/id</span>      <span class="integer">7</span>
                                                   <span class="symbol">:item/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A.1</span><span class="delimiter">&quot;</span></span>
                                                   <span class="symbol">:item/subitems</span>
                                                               [{<span class="symbol">:db/id</span>         <span class="integer">8</span>
                                                                 <span class="symbol">:item/label</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">A.1.1</span><span class="delimiter">&quot;</span></span>
                                                                 <span class="symbol">:item/subitems</span> []}]}]}
                                         {<span class="symbol">:db/id</span>      <span class="integer">3</span>
                                          <span class="symbol">:item/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>
                                          <span class="symbol">:item/subitems</span>
                                                      [{<span class="symbol">:db/id</span> <span class="integer">6</span> <span class="symbol">:item/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B.1</span><span class="delimiter">&quot;</span></span>}]}
                                         {<span class="symbol">:db/id</span>         <span class="integer">4</span>
                                          <span class="symbol">:item/label</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span>
                                          <span class="symbol">:item/subitems</span> []}
                                         {<span class="symbol">:db/id</span>         <span class="integer">5</span>
                                          <span class="symbol">:item/label</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">D</span><span class="delimiter">&quot;</span></span>
                                          <span class="comment">; just for fun..nest a dupe under D</span>
                                          <span class="symbol">:item/subitems</span> [{<span class="symbol">:db/id</span> <span class="integer">6</span> <span class="symbol">:item/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B.1</span><span class="delimiter">&quot;</span></span>}]}]}})
   <span class="symbol">:query</span>         [{<span class="symbol">:list</span> (comp/get-query ItemList)}]}
  (dom/div
    (ui-item-list <span class="keyword">list</span>)))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_ast"><a class="anchor" href="#_the_ast"></a><a class="link" href="#_the_ast">5.10. The AST</a></h3>
<div class="paragraph">
<p>You can convert any expression of EQL into an AST (abstract syntax tree) and vice
versa. This lends itself to doing complex parsing of the query (typically on the server). The functions
of interest are <code>com.fulcrologic.fulcro.components/query&#8594;ast</code> and <code>ast&#8594;query</code>.</p>
</div>
<div class="paragraph">
<p>There are many uses for this. One such use might be to convert the graph expression into another form. For
example, say you wanted to run a query against an SQL database. You could write an algorithm that translates
the AST into a series of SQL queries to build the desired result. The AST is always available as one
of the parameters in the mutation/query <code>env</code> on the client and server.</p>
</div>
<div class="paragraph">
<p>Another use for the AST is in mutations targeted at a remote: it turns out you can morph a mutation before
sending it to the server.</p>
</div>
<div class="sect3">
<h4 id="_morphing_mutations"><a class="anchor" href="#_morphing_mutations"></a><a class="link" href="#_morphing_mutations">5.10.1. Morphing Mutations</a></h4>
<div class="paragraph">
<p>The most common use of the AST is probably adding parameters that the UI is unaware need to be sent to
a remote. When processing a mutation with <code>defmutation</code> (or just the raw defmethod) you will receive
the AST of the mutation in the <code>env</code>. It is legal to return <strong>any</strong> valid AST from the remote side of a
mutation. This has the effect of changing what will be sent to the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation do-thing [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [{<span class="symbol">:keys</span> [ast]}] ast)) <span class="comment">; same effect as `true`</span>

(defmutation do-thing [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [{<span class="symbol">:keys</span> [ast]}] (comp/query-&gt;ast `[(do-other-thing)])) <span class="comment">; completely change what gets sent to `remote`</span>

(defmutation do-thing [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [{<span class="symbol">:keys</span> [ast]}] (<span class="keyword">assoc</span> ast <span class="symbol">:params</span> {<span class="symbol">:y</span> <span class="integer">3</span>}))) <span class="comment">; change the parameters</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For more on mutations see the chapter on <a href="#MutationsChapter">Handling Mutations</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_initial_application_state"><a class="anchor" href="#_initial_application_state"></a><a class="link" href="#_initial_application_state">6. Initial Application State</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>When starting any application one thing has to be done before just about anything else: Establish a starting state. In Fulcro
this just means generating a client-side application database (normalized). Other parts of this guide have talked about
the <a href="#GraphDB">Graph Database</a>. You can well imagine that hand-coding one of these for a large application&#8217;s starting
state could be kind of a pain. Actually, even though coding it would be a pain, it turns out that the <strong>bigger</strong> pain
happens later when you want to refactor! That can become a real mess!</p>
</div>
<div class="paragraph">
<p>However, Fulcro already knows how to normalize a tree of data, and your UI is already the tree you&#8217;re interested in.
So, Fulcro encourages you to co-locate initial application state with the components that need the state and compose
it towards the root, just like you do for queries. This gives some nice results:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Your initial application state is reasoned about locally to each component, just like the queries.</p>
</li>
<li>
<p>Refactoring the UI just means modifying the <strong>local</strong> composition of queries and initial state from one place
to another in the UI.</p>
</li>
<li>
<p>Fulcro understands unions (you can only initialize one branch of a to-one relation), and can scan
for and initialize alternate branches.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_adding_initial_state_to_components"><a class="anchor" href="#_adding_initial_state_to_components"></a><a class="link" href="#_adding_initial_state_to_components">6.1. Adding Initial State to Components</a></h3>
<div class="paragraph">
<p>To add initial state, follow these steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>For each component that should appear initially: add the <code>:initial-state</code> option.</p>
</li>
<li>
<p>Compose the components in (1) all the way to your root.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>That&#8217;s it! Fulcro will automatically detect initial state on the root, and use it for the application!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Child [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:child/id</span> <span class="integer">1</span>})
   <span class="symbol">:ident</span> <span class="symbol">:child/id</span>
   <span class="symbol">:query</span> [<span class="symbol">:child/id</span>]}
  <span class="keyword">..</span><span class="keyword">.</span>)

(defsc Parent [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:parent/id</span> <span class="integer">1</span> {<span class="symbol">:parent/child</span> (comp/get-initial-state Child)}})
   <span class="symbol">:ident</span> <span class="symbol">:parent/id</span>
   <span class="symbol">:query</span> [<span class="symbol">:parent/id</span> {<span class="symbol">:parent/child</span> (comp/get-query Child)}]}
  <span class="keyword">..</span><span class="keyword">.</span>)

<span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the nice symmetry here. The initial state is (usually) a map that represents (recursively) the entity and
its children. The query is a vector that lists the "scalar" props, and joins as maps.  So, in <code>Child</code> we have
initial state and a query for its ID. In the parent we have a query for the parent&#8217;s data with a join to
the child, and initial state mirrors that with an identical structure pulling the child state.</p>
</div>
<div class="sect3">
<h4 id="_initial_state_and_alternate_branches_of_unions"><a class="anchor" href="#_initial_state_and_alternate_branches_of_unions"></a><a class="link" href="#_initial_state_and_alternate_branches_of_unions">6.1.1. Initial State and Alternate Branches of Unions</a></h4>
<div class="paragraph">
<p>The one "extra" feature that initial state support does for you is to initialize <strong>alternate branches</strong> of components that
have a to-one <a href="#Unions">union query</a>. Remember that a to-one relation from a union could be to any number of alternates.</p>
</div>
<div class="paragraph">
<p>Take this union query: <code>{:person (comp/get-query Person) :place (comp/get-query Place)}</code></p>
</div>
<div class="paragraph">
<p>It means "if you find an ident in the graph pointing to a <code>:person</code>, then query for the person. If you find one
for <code>:place</code>, then query for a place. The problem is: if it is a to-one relation then only <strong>one</strong> can be in the
initial state tree at startup!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{ <span class="symbol">:person-or-place</span> [<span class="symbol">:person</span> <span class="integer">2</span>]
  <span class="symbol">:person</span> {<span class="integer">2</span> {<span class="symbol">:id</span> <span class="integer">2</span> <span class="keyword">..</span><span class="keyword">.</span>}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you look at a proposed initial state, it will make the problem more clear:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Person [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [id <span class="keyword">name</span>]}] {<span class="symbol">:id</span> id <span class="symbol">:name</span> <span class="keyword">name</span> <span class="symbol">:type</span> <span class="symbol">:person</span>})
   <span class="keyword">..</span><span class="keyword">.</span>)

(defsc PersonPlaceUnion [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] (comp/get-initial-state Person {<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>})) <span class="comment">; I can only put in one of them!</span>
   <span class="symbol">:query</span> {<span class="symbol">:person</span> (comp/get-query Person) <span class="symbol">:place</span> (comp/get-query Place)})
  <span class="keyword">..</span><span class="keyword">.</span>)

(defsc Parent [this props]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {<span class="symbol">:person-or-place</span> (comp/get-initial-state PersonPlaceUnion)}))
   <span class="symbol">:query</span> [{<span class="symbol">:person-or-place</span> (comp/get-query PersonPlaceUnion)}]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would result in a person in the initial state, but not a place.</p>
</div>
<div class="paragraph">
<p>Fulcro solves this at startup in the following manner: It pulls the query from root and walks it. If it finds
a union component, then <strong>for each branch</strong> it sees if that component (via the query metadata) has initial state. If
it does, it places it in the correct table in app state. This does <strong>not</strong>, of course, join it to anything in the graph
since it isn&#8217;t the "default branch" that was explicitly listed.</p>
</div>
<div class="paragraph">
<p>This behavior is critical when using unions to handle UI routing, which is in turn essential for good application
performance.</p>
</div>
</div>
<div class="sect3">
<h4 id="_initial_state_demo"><a class="anchor" href="#_initial_state_demo"></a><a class="link" href="#_initial_state_demo">6.1.2. Initial State Demo</a></h4>
<div class="paragraph">
<p>The following demo shows all of this in action.</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. <a id="InitialState"></a><a href="#InitialState">Initial State</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('initial-app-state')">Focus Inspector</button>
<div class="short narrow example" id="initial-app-state"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.initial-app-state</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]))

(<span class="keyword">defmethod</span> <span class="function">m/mutate</span> 'nav/settings [{<span class="symbol">:keys</span> [state]} sym params]
  {<span class="symbol">:action</span> (<span class="keyword">fn</span> [] (<span class="keyword">swap!</span> state <span class="keyword">assoc</span> <span class="symbol">:panes</span> [<span class="symbol">:settings</span> <span class="symbol">:singleton</span>]))})

(<span class="keyword">defmethod</span> <span class="function">m/mutate</span> 'nav/main [{<span class="symbol">:keys</span> [state]} sym params]
  {<span class="symbol">:action</span> (<span class="keyword">fn</span> [] (<span class="keyword">swap!</span> state <span class="keyword">assoc</span> <span class="symbol">:panes</span> [<span class="symbol">:main</span> <span class="symbol">:singleton</span>]))})

(defsc ItemLabel [this {<span class="symbol">:keys</span> [value]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [value]}] {<span class="symbol">:value</span> value})
   <span class="symbol">:query</span>         [<span class="symbol">:value</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:labels/by-value</span> value])}
  (dom/p value))

(<span class="keyword">def</span> <span class="function">ui-label</span> (comp/factory ItemLabel {<span class="symbol">:keyfn</span> <span class="symbol">:value</span>}))

<span class="comment">;; Foo and Bar are elements of a mutli-type to-many union relation (each leaf can be a Foo or a Bar). We use params to</span>
<span class="comment">;; allow initial state to put more than one in place and have them be unique.</span>
(defsc Foo [this {<span class="symbol">:keys</span> [label]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:type</span> <span class="symbol">:id</span> {<span class="symbol">:label</span> (comp/get-query ItemLabel)}]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [id label]}] {<span class="symbol">:id</span> id <span class="symbol">:type</span> <span class="symbol">:foo</span> <span class="symbol">:label</span> (comp/get-initial-state ItemLabel {<span class="symbol">:value</span> label})})}
  (dom/div
    (dom/h2 <span class="string"><span class="delimiter">&quot;</span><span class="content">Foo</span><span class="delimiter">&quot;</span></span>)
    (ui-label label)))

(<span class="keyword">def</span> <span class="function">ui-foo</span> (comp/factory Foo {<span class="symbol">:keyfn</span> <span class="symbol">:id</span>}))

(defsc Bar [this {<span class="symbol">:keys</span> [label]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:type</span> <span class="symbol">:id</span> {<span class="symbol">:label</span> (comp/get-query ItemLabel)}]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [id label]}] {<span class="symbol">:id</span> id <span class="symbol">:type</span> <span class="symbol">:bar</span> <span class="symbol">:label</span> (comp/get-initial-state ItemLabel {<span class="symbol">:value</span> label})})}
  (dom/div
    (dom/h2 <span class="string"><span class="delimiter">&quot;</span><span class="content">Bar</span><span class="delimiter">&quot;</span></span>)
    (ui-label label)))

(<span class="keyword">def</span> <span class="function">ui-bar</span> (comp/factory Bar {<span class="symbol">:keyfn</span> <span class="symbol">:id</span>}))

<span class="comment">;; This is the to-many union component. It is the decision maker (it has no state or rendering of it's own)</span>
<span class="comment">;; The initial state of this component is the to-many (vector) value of various children</span>
<span class="comment">;; The render just determines which thing it is, and passes on the that renderer</span>
(defsc ListItem [this {<span class="symbol">:keys</span> [id <span class="keyword">type</span>] <span class="symbol">:as</span> props}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] [(comp/get-initial-state Bar {<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}) (comp/get-initial-state Foo {<span class="symbol">:id</span> <span class="integer">2</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>}) (comp/get-initial-state Bar {<span class="symbol">:id</span> <span class="integer">3</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span>})])
   <span class="symbol">:query</span>         (<span class="keyword">fn</span> [] {<span class="symbol">:foo</span> (comp/get-query Foo) <span class="symbol">:bar</span> (comp/get-query Bar)}) <span class="comment">; use lambda for unions</span>
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="keyword">type</span> id])}                        <span class="comment">; lambda for unions</span>
  (<span class="keyword">case</span> <span class="keyword">type</span>
    <span class="symbol">:foo</span> (ui-foo props)
    <span class="symbol">:bar</span> (ui-bar props)
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">No Item renderer!</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-list-item</span> (comp/factory ListItem {<span class="symbol">:keyfn</span> <span class="symbol">:id</span>}))

<span class="comment">;; Settings and Main are the target &quot;Panes&quot; of a to-one union (e.g. imagine tabs...we use buttons as the tab switching in</span>
<span class="comment">;; this example). The initial state looks very much like any other component, as does the rendering.</span>
(defsc Settings [this {<span class="symbol">:keys</span> [label]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:type</span> <span class="symbol">:settings</span> <span class="symbol">:id</span> <span class="symbol">:singleton</span> <span class="symbol">:label</span> (comp/get-initial-state ItemLabel {<span class="symbol">:value</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Settings</span><span class="delimiter">&quot;</span></span>})})
   <span class="symbol">:query</span>         [<span class="symbol">:type</span> <span class="symbol">:id</span> {<span class="symbol">:label</span> (comp/get-query ItemLabel)}]}
  (ui-label label))

(<span class="keyword">def</span> <span class="function">ui-settings</span> (comp/factory Settings {<span class="symbol">:keyfn</span> <span class="symbol">:type</span>}))

(defsc Main [this {<span class="symbol">:keys</span> [label]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:type</span> <span class="symbol">:main</span> <span class="symbol">:id</span> <span class="symbol">:singleton</span> <span class="symbol">:label</span> (comp/get-initial-state ItemLabel {<span class="symbol">:value</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Main</span><span class="delimiter">&quot;</span></span>})})
   <span class="symbol">:query</span>         [<span class="symbol">:type</span> <span class="symbol">:id</span> {<span class="symbol">:label</span> (comp/get-query ItemLabel)}]}
  (ui-label label))

(<span class="keyword">def</span> <span class="function">ui-main</span> (comp/factory Main {<span class="symbol">:keyfn</span> <span class="symbol">:type</span>}))

<span class="comment">;; This is a to-one union component. Again, it has no state of its own or rendering. The initial state is the single</span>
<span class="comment">;; child that should appear. Fulcro (during startup) will detect this component, and then use the query to figure out</span>
<span class="comment">;; what other children (the ones that have initial-state defined) should be placed into app state.</span>
(defsc PaneSwitcher [this {<span class="symbol">:keys</span> [id <span class="keyword">type</span>] <span class="symbol">:as</span> props}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] (comp/get-initial-state Main <span class="predefined-constant">nil</span>))
   <span class="symbol">:query</span>         (<span class="keyword">fn</span> [] {<span class="symbol">:settings</span> (comp/get-query Settings) <span class="symbol">:main</span> (comp/get-query Main)})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="keyword">type</span> id])}
  (<span class="keyword">case</span> <span class="keyword">type</span>
    <span class="symbol">:settings</span> (ui-settings props)
    <span class="symbol">:main</span> (ui-main props)
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">NO PANE!</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-panes</span> (comp/factory PaneSwitcher {<span class="symbol">:keyfn</span> <span class="symbol">:type</span>}))

<span class="comment">;; The root. Everything just composes to here (state and query)</span>
<span class="comment">;; Note, in core (where we create the app) there is no need to say anything about initial state!</span>
(defsc Root [this {<span class="symbol">:keys</span> [panes items]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:panes</span> (comp/get-initial-state PaneSwitcher <span class="predefined-constant">nil</span>)
                                <span class="symbol">:items</span> (comp/get-initial-state ListItem <span class="predefined-constant">nil</span>)})
   <span class="symbol">:query</span>         [{<span class="symbol">:items</span> (comp/get-query ListItem)}
                   {<span class="symbol">:panes</span> (comp/get-query PaneSwitcher)}]}
  (dom/div
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [evt] (comp/transact! this '[(nav/settings)]))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Go to settings</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [evt] (comp/transact! this '[(nav/main)]))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Go to main</span><span class="delimiter">&quot;</span></span>)

    (ui-panes panes)

    (dom/h1 <span class="string"><span class="delimiter">&quot;</span><span class="content">Heterogenous list:</span><span class="delimiter">&quot;</span></span>)

    (dom/ul
      (mapv ui-list-item items))))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_initial_state_and_state_progressions"><a class="anchor" href="#_initial_state_and_state_progressions"></a><a class="link" href="#_initial_state_and_state_progressions">6.2. Initial State and State Progressions</a></h3>
<div class="paragraph">
<p>Since our rendering via React is a pure function of state you think about your application as a sequence of states
that are rendered in time (like a movie), and the initial
state just generates the first state for that progression.</p>
</div>
<div class="paragraph">
<p>An interesting note is that this model also results in a really useful property: You can take the initial state,
run it though the implementation of one or more mutations, and end up with any other state. This means you can
easily reason about initializing your application <strong>into any</strong> state, which is useful for things like testing and server-side rendering.</p>
</div>
<div class="paragraph">
<p>There are all sorts of very useful features that fall out of this. For example, it is also possible to record a series
of "user interactions" (which can be recorded as a list of the mutations that ran) and replay those. This could be used
to send a tester a sequence of steps to show recent development work, run automated demos/tests, teleport your development
environment to a specific page, etc.</p>
</div>
<div class="paragraph">
<p>Writing tests against the state model and mutation implementations is a great way to <strong>unit test</strong> your application
without needing to involve the UI itself at all.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Normalization"><a class="anchor" href="#Normalization"></a><a class="link" href="#Normalization">7. Normalization</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Normalization is a central mechanism in Fulcro. It is the means by which your data
trees (which you receive from component queries against servers) can be placed into
your normalized graph database.</p>
</div>
<div class="sect2">
<h3 id="_internals"><a class="anchor" href="#_internals"></a><a class="link" href="#_internals">7.1. Internals</a></h3>
<div class="paragraph">
<p>The function <code>fnorm/tree&#8594;db</code> is the workhorse that turns an incoming tree of data into normalized data (which can then
be merged into the overall database).</p>
</div>
<div class="paragraph">
<p>Imagine an incoming tree of data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{ <span class="symbol">:people</span> [ {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="keyword">..</span><span class="keyword">.</span>} {<span class="symbol">:db/id</span> <span class="integer">2</span> <span class="keyword">..</span><span class="keyword">.</span>} <span class="keyword">..</span><span class="keyword">.</span> ] }</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:people</span> (comp/get-query Person)}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>which expands to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:people</span> [<span class="symbol">:db/id</span> <span class="symbol">:person/name</span>]}]
          ^ metadata {<span class="symbol">:component</span> Person}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>tree&#8594;db</code> recursively walks the data structure and query:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>At the root, it sees <code>:people</code> as a root key and property. It remembers it will be writing <code>:people</code> to the root.</p>
</li>
<li>
<p>It examines the value of <code>:people</code> and finds it to be a vector of maps. This indicates a to-many relationship.</p>
</li>
<li>
<p>It examines the metadata on the subquery of <code>:people</code> and discovers that the entries are represented by
the component <code>Person</code></p>
</li>
<li>
<p>For each map in the vector, it calls the <code>ident</code> function of <code>Person</code> (which it found in the metadata) to get a
database location. It then places the "person" values into the result via <code>assoc-in</code> on the ident.</p>
</li>
<li>
<p>It replaces the entries in the vector with the idents.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the metadata was missing then it would assume the person data did not need normalization. This is why it is
critical to compose queries correctly. The query and tree of data must have a parallel structure, as should the
UI. In template mode <code>defsc</code> will try to check some things for you, but you must ensure that you
compose the queries correctly.</p>
</div>
</div>
<div class="sect2">
<h3 id="_normalization_initial_state_server_interactions_and_mutations"><a class="anchor" href="#_normalization_initial_state_server_interactions_and_mutations"></a><a class="link" href="#_normalization_initial_state_server_interactions_and_mutations">7.2. Normalization: Initial State, Server Interactions, and Mutations</a></h3>
<div class="paragraph">
<p>The process described above is how most data interactions occur. At startup the <code>:initial-state</code> supplies data that
exactly matches the tree of the UI. This gives your UI some initial state to render. The normalization mechanism
described above is what happens to that initial tree when it is detected by Fulcro at startup (with the addition
of the alternate union merging, described earlier).</p>
</div>
<div class="paragraph">
<p>Network interactions send a UI-based query (which is annotated with the components). The query is
remembered and when a response tree of data is received (which must match the tree structure of the query), the
normalization process is applied and the resulting normalized data is merged with the database.</p>
</div>
<div class="paragraph">
<p>It is the same thing when using websockets: A server push gives you a tree of data. You could hand-normalize that data,
but actually if you know the structure of the incoming data you can easily generate a client-side query (using
<code>defsc</code>) that can be used in conjunction with <code>fnorm/tree&#8594;db</code> to normalize that incoming data.</p>
</div>
<div class="paragraph">
<p>Mutations can do the same thing. If a new instance of some entity is being generated by the UI as a tree of data, then
the query for that UI component can be used to turn it into normalized data that can be merged into the state
within the mutation.</p>
</div>
<div class="paragraph">
<p>Some useful functions to know about:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>merge/merge-component!</code> and <code>merge/merge-component</code> - merge new instances of a (possibly recursive) entity into
the normalized database.</p>
</li>
<li>
<p><code>merge/merge!</code> and <code>merge/merge*</code> - merge root-level out-of-band data into your application.</p>
</li>
<li>
<p><code>fnorm/tree&#8594;db</code> - General utility for normalizing data via a query and chunk of data.</p>
</li>
<li>
<p><code>merge/integrate-ident*</code> - A utility for adding an ident into existing to-one and to-many relations in your database.
Can be used within mutations.</p>
</li>
<li>
<p><code>misc/deep-merge</code> - A simple implementation of merge that is recursive.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The general merge operations all support the option <code>:remove-missing?</code>. This option defaults to false. When set
to true it will cause the merge algorithms to exhibit the Fulcro remote load cleanups: if something is in the query but
not the data then it will be removed from the state database. The deep merge used by the merge routines is not otherwise
meant to "write over" existing versions of your entities, since they may have ui-only attributes that the incoming trees
do not know about. See <a href="#ResultMerge">the section on remote result merging</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="FullStack"><a class="anchor" href="#FullStack"></a><a class="link" href="#FullStack">8. Full Stack Operation</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the most interesting and powerful things about Fulcro is that the model for server interaction is unified into
a clean data-driven structure. At first the new concepts can be challenging, but once you&#8217;ve seen the core primitive
(component-based queries/idents for normalization) we think you&#8217;ll find that it dramatically simplifies everything!</p>
</div>
<div class="paragraph">
<p>In fact, now that you&#8217;ve completed the materials of this guide on the graph database, queries, idents, and
normalization, it turns out that the server interactions become nearly trivial!</p>
</div>
<div class="paragraph">
<p>Not only is the <strong>structure</strong> of server interaction well-defined, Fulcro come with pre-written middleware
to handle plumbing for you.</p>
</div>
<div class="paragraph">
<p>However, there are a lot of possible pitfalls when writing distributed applications. People often underestimate just how hard
it is to get web applications right because they forget that.</p>
</div>
<div class="paragraph">
<p>So, while the <strong>API and mechanics</strong> of how you write Fulcro server interactions are as simple as possible there is no getting
around that there are some hairy things to navigate in distributed apps independent of your choice of tools.
Fulcro tries to make these things apparent, and it also tries hard to make sure you&#8217;re able to get it right without
pulling out your hair.</p>
</div>
<div class="paragraph">
<p>Here are some of the basics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Network protocol is included (and extensible))</p>
<div class="ulist">
<ul>
<li>
<p>The protocol is EDN on the wire (via transit), which means you just speak Clojure data on the wire, and can
easily extend it to encode/decode new types.</p>
</li>
</ul>
</div>
</li>
<li>
<p>All network requests (queries and mutations) are processed sequentially unless you specify otherwise. This allows you
to reason about optimistic updates (Starting more than one at a time via async calls could
lead to out-of-order execution, and impossible-to-reason-about recovery from errors).</p>
</li>
<li>
<p>You can provide error handling for remote problems at a global or mutation-local level.</p>
</li>
<li>
<p>You can interact directly with the network result or use default result processing.</p>
</li>
<li>
<p>Any <code>:ui/</code> namespaced query elements are automatically elided when generating a query from the UI to a server, allowing you
to easily mix UI concerns with server concerns in your component queries. You can also change the global rewrite
logic to elide other local props from remote queries.</p>
</li>
<li>
<p>Normalization of a remote query result is automatic when using <code>defmutation</code>, but customizable.</p>
<div class="ulist">
<ul>
<li>
<p>Query results use <a href="#ResultMerge">intelligent overwrite</a> for properties that are already present in the client database.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Any number of remotes can be defined</p>
</li>
<li>
<p>Protocol and communication is strictly constrained to the networking layer and away from your application&#8217;s core structure,
meaning you can actually speak whatever and however you want to a remote. In fact
the concept of a remote is just "something you can talk to via queries and mutations".
You can easily define a "remote" that reads and writes browser
local storage or a Datascript database in the browser. This is an extremely powerful generalization for isolating
side-effect code from your UI.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
To those of you with REST or GraphQL APIs: See the Pathom library for ways of converting those services
into custom client remotes that isolate those APIs to the networking layers of your client.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_general_theory_of_operation"><a class="anchor" href="#_general_theory_of_operation"></a><a class="link" href="#_general_theory_of_operation">8.1. General Theory of Operation</a></h3>
<div class="paragraph">
<p>There are only a few general kinds of interactions with a server:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initial loads when the application starts</p>
</li>
<li>
<p>Incremental loads of sub-graphs of something that was previously loaded.</p>
</li>
<li>
<p>Event-based loads (e.g. user or timed events)</p>
</li>
<li>
<p>Integrating data from other external sources (e.g. server push)</p>
</li>
<li>
<p>Run a remote operation, which can optionally return a graph of data as a response.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In standard Fulcro networking, <strong>all</strong> of the above have the following similarities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A component-based graph query needs to be involved to enable auto-normalization. This is true even for a server push
(though in that case the client needs to know what <strong>implied</strong> query the server is sending data about).</p>
</li>
<li>
<p>The data from the server will be a tree that has the same shape as the query.</p>
</li>
<li>
<p>The data needs to be normalized into the client database.</p>
</li>
<li>
<p>Optionally: after integrating new data there may be some need to transform the result to a form the UI needs
(e.g. perhaps you need to sort or paginate some list of items that came in).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>IMPORTANT</strong>: Remember what you learned about the graph database, queries, and idents. This section cannot possibly be understood
properly if you do not understand those topics!</p>
</div>
<div class="sect3">
<h4 id="_integration_of_all_new_external_data_is_just_a_query_based_merge"><a class="anchor" href="#_integration_of_all_new_external_data_is_just_a_query_based_merge"></a><a class="link" href="#_integration_of_all_new_external_data_is_just_a_query_based_merge">8.1.1. Integration of <strong>ALL</strong> new external data is just a Query-Based Merge</a></h4>
<div class="paragraph">
<p>So, here is the secret: When external data needs to go into your database it all uses the exact same mechanism: a
query-based merge. So, for a simple load: you send a UI-based query to the server, the server responds with a tree
of data that matches that graph query, and then the query itself (which is annotated with the components and ident functions)
can be used to normalize the result. Finally, the normalized result can be merged into your existing client database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">Query --&gt; Server --&gt; Response <span class="keyword">+</span> Original Query w/Idents --&gt; Normalized Data --&gt; Database Merge --&gt; New Database</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any other kind of external data integration just starts at the "Response" step by manually providing the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">New External Data <span class="keyword">+</span> Query w/Idents --&gt; Normalized Data --&gt; Database Merge --&gt; New Database</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a primitive function <code>merge/merge!</code> function that implements this, so that you can simplify the picture to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">Tree of Data <span class="keyword">+</span> Query --&gt; merge! --&gt; New Database</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_central_functions_transact_and_merge"><a class="anchor" href="#_the_central_functions_transact_and_merge"></a><a class="link" href="#_the_central_functions_transact_and_merge">8.1.2. The Central Functions: <code>transact!</code> and <code>merge!</code></a></h4>
<div class="paragraph">
<p>The two core functions that allow you to trigger abstract operations or data merges externally
(via your <code>app</code>) are:</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><code>comp/transact!</code></dt>
<dd>
<p>The central function for running abstract (possibly full-stack) changes in the application.
Can be run with a component <em>or</em> app. If run with the app, will typically cause a root re-render.</p>
</dd>
<dt><code>merge/merge!</code></dt>
<dd>
<p>A function that can be run against the app to merge a tree of data via a UI query.</p>
</dd>
<dt><code>merge/merge-component!</code></dt>
<dd>
<p>Like <code>merge!</code>, but can be passed a component instead of a query.</p>
</dd>
<dt><code>merge/merge*</code></dt>
<dd>
<p><code>merge!</code>, but in a mutation via <code>swap!</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>These (and related/derived helpers) are the primary tools used to put new data into your client&#8217;s database.</p>
</div>
</div>
<div class="sect3">
<h4 id="_query_mismatch"><a class="anchor" href="#_query_mismatch"></a><a class="link" href="#_query_mismatch">8.1.3. Query Mismatch</a></h4>
<div class="paragraph">
<p>We have all sorts of ways we&#8217;d like to view data. Perhaps we&#8217;d like to view "all the people who&#8217;ve ever had a particular
phone number". That is something we can very simply represent with a UI graph, but may not be trivial to pull from
our database.</p>
</div>
<div class="paragraph">
<p>In general, there are a few approaches to resolving our graph differences:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use a query parser on the server to piece together data based on the graph of the query (preferred).</p>
</li>
<li>
<p>Ask the server for exactly what you want, using an invented well-known "root" keyword, and hand-code the database
code to create the UI-centric view.</p>
</li>
<li>
<p>Ask the server for the data in a format it can provide and morph it on the client.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The first two have the advantage of making the client blissfully unaware of the server schema. It just asks for what
it needs, and someone on the server programming team makes it happen. Fortunately, pathom makes this approach
quite tractable and good.</p>
</div>
<div class="paragraph">
<p>In some cases, though, you&#8217;d like to morph it a bit on the client-side. We&#8217;ll show you an example of this
as we explore the data fetch options.</p>
</div>
</div>
<div class="sect3">
<h4 id="_server_interaction_order"><a class="anchor" href="#_server_interaction_order"></a><a class="link" href="#_server_interaction_order">8.1.4. Server Interaction Order</a></h4>
<div class="paragraph">
<p>Fulcro will serialize requests unless you mark queries as parallel (an option you can specify with <code>df/load!</code>). Two different
<strong>events</strong> that queue mutations or loads will be processed in the order of events. For example, if the user clicks on
something and you trigger two loads during <strong>that event</strong>, then both of those <strong>may</strong> be combined (if they don&#8217;t conflict)
and sent as one network request. If the user clicks on something else and that handler queues two more loads, then the
latter two loads will not start over the network until the first load sequence has completed.</p>
</div>
<div class="paragraph">
<p>This ensures that you don&#8217;t get out-of-order server execution. This is a distributed system, so it is possible for a
second request to hit a less congested server (or even thread) than the first and get processed out of order.
That would hurt your ability to reason about your program, so the default behavior in
Fulcro is to ensure that server interactions happen on the server in the same order as they do on the client.</p>
</div>
<div class="paragraph">
<p>Fulcro will also try to reorder writes that are submitted alongside reads so that the writes appear on the server first,
giving you the best possible chance that the reads get the most up-to-date versions of data.</p>
</div>
<div class="paragraph">
<p>In Summary:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Loads/transactions queued while "holding the UI thread" may be joined together in a single network request.</p>
</li>
<li>
<p>Remote writes go before reads (for a given processing event)</p>
</li>
<li>
<p>Loads/transactions queued at a later event (new UI thread event) are guaranteed to be processed after ones queued earlier.</p>
</li>
<li>
<p>You can override this behavior with the <code>parallel</code> option of <code>load!</code> or <code>transact!</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="ResultMerge"><a class="anchor" href="#ResultMerge"></a><a class="link" href="#ResultMerge">8.1.5. Server Result Query Merging</a></h4>
<div class="paragraph">
<p>There is a potential for a data-driven app to create a new class of problem related to merging data. The normalization
guarantees that the data for any number of <strong>views</strong> of the same thing are normalized to the same <strong>node</strong> in the graph
database.</p>
</div>
<div class="paragraph">
<p>Thus, your <code>PersonListRow</code> view and <code>PersonDetail</code> view should both normalize the same person data to
a location like <code>[:person/id id]</code>. Let&#8217;s say you have a quick list of people on the screen that is paginated and
demand-loaded, where each row is a <code>PersonListRow</code> with query <code>[:db/id :person/name {:person/image (comp/get-query Image)}]</code>.
Now say that you can click on one of these rows and a side-by-side view of that person&#8217;s <code>PersonDetail</code> is shown,
but the query for that is a whole bunch of stuff: name, age, address, phone numbers, etc. A <strong>much</strong> larger query.</p>
</div>
<div class="paragraph">
<p>A naive merge could cause you all sorts of nightmares. For example, Refreshing the list rows would load only name and image,
but if merge overwrote the entire table <strong>entry</strong> then the current detail would suddenly empty out!</p>
</div>
<div class="paragraph">
<p>Fulcro provides you with an advanced merging algorithm that ensures these kinds of cases don&#8217;t easily occur. It does an
intelligent merge with the following algorithm:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is a detailed deep merge. Thus, the target table entry is updated, not overwritten.</p>
</li>
<li>
<p>If the query <strong>asks</strong> for a value but the result <strong>does not</strong> contain it, then that value <strong>is removed</strong>.</p>
</li>
<li>
<p>If the query <strong>didn&#8217;t ask</strong> for a value, then the existing database value is untouched.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This reduces the problem to one of potential staleness. It is technically possible for an entity in the resulting client
database to be in a state that has never existed on the server because of such a partial update. This is considered
to be a better result than the arbitrary UI madness that a more naive approach would cause.</p>
</div>
<div class="paragraph">
<p>For example, in the example above a query for a list row will update the name and image. All of the other details (if already
loaded) would remain the same; however, it is possible that the server has run a mutation that also updated this person&#8217;s
phone number. The detail part of the UI will be showing an updated name and image, but the old phone number. Technically
this "state of Person" has never existed in the server&#8217;s timeline, but from a user&#8217;s perspective it looks better than
the phone number disappearing.</p>
</div>
<div class="paragraph">
<p>In practice this isn&#8217;t that big of a deal; however, if you are switching the UI to an edit mode it is generally a good practice to
on-demand (re)load the entity being edited to help prevent user confusion.</p>
</div>
</div>
<div class="sect3">
<h4 id="WhatIsAnError"><a class="anchor" href="#WhatIsAnError"></a><a class="link" href="#WhatIsAnError">8.1.6. Defining Error Conditions</a></h4>
<div class="paragraph">
<p>Both loads and mutations have a general concept of network errors that is customizable.
The default detection of error conditions looks at the <code>status-code</code> of the network result. If it
is 200, then it is considered "ok", and anything else is an error. You may want to customize this
behavior to also look for other bits of content in the result, which can be specific to the
remote and middleware definitions.</p>
</div>
<div class="paragraph">
<p>There is one global definition for error detection that is used for both loads and mutations.
It can be overridden with the <code>:remote-error?</code> option when creating the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">app</span> (app/fulcro-app {<span class="symbol">:remote-error?</span> (<span class="keyword">fn</span> [result] <span class="keyword">..</span><span class="keyword">.</span>)}))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_react_lifecycle_and_load"><a class="anchor" href="#_react_lifecycle_and_load"></a><a class="link" href="#_react_lifecycle_and_load">8.2. React Lifecycle and Load</a></h3>
<div class="paragraph">
<p>React lifecycle and load may not mix well. It is technically legal to issue transactions and loads from React Lifecycle
methods, but it is recommended that you carefully check the state of the system in said mutations before actually
queuing network traffic.
Perhaps you wish to ensure something is loaded. To do that: trigger a mutation that checks state and optionally
submits a load. This is also true for any sort of side-effecting against your application state since the
React lifecycle calls can be triggered for unexpected reasons (e.g. instability in a parent&#8217;s key can cause
all children to unmount/remount).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="MutationsChapter"><a class="anchor" href="#MutationsChapter"></a><a class="link" href="#MutationsChapter">9. Mutations</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mutations are the primary mechanism by which side effects happen in Fulcro. In fact, even the load API in
the <code>data-fetch</code> namespace is implemented via the mutation system. <strong>Mutations</strong> are data expressions
that represent a command to execute (locally and/or remotely). The remote operation of a mutation can
optionally return a graph tree to be merged into your application&#8217;s state.</p>
</div>
<div class="paragraph">
<p>Mutations are submitted to Fulcro&#8217;s <strong>transaction processing system</strong> via <code>comp/transact!</code>. Technically the
algorithm for processing transactions is pluggable, but this book will only cover the built-in version.</p>
</div>
<div class="paragraph">
<p>Mutations are known by their symbol and are dispatched to the internal multi-method
<code>com.fulcrologic.fulcro.mutations/mutate</code>. To handle a mutation you can do two basic things: use <code>defmethod</code>
to add a mutation, or use the macro <code>defmutation</code> to handle this for you.</p>
</div>
<div class="paragraph">
<p>The macro is <strong>highly recommended</strong> for all but the most advanced cases because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Your editor/IDE can treat it like <code>defn</code> for better navigation and support.</p>
</li>
<li>
<p>It is where the default remote response handling is "plugged in".</p>
</li>
<li>
<p>It prevents certain implementation errors.</p>
</li>
<li>
<p>It isolates you from any potential internal changes to Fulcro.</p>
</li>
<li>
<p>It auto-namespaces the mutation to the namespace of declaration without the need to quote.</p>
</li>
<li>
<p>It adds support to <strong>use</strong> the mutation in a transaction without syntax quoting.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You might use the internal multi-method directly for more advanced things like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You&#8217;re writing your own <code>defmutation</code> wrapper to change some global behavior for your application (note, though, that
the built-in <code>defmutation</code> has an extension point).</p>
</li>
<li>
<p>You want to dynamically affect a mutation in some complex way at runtime.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The internals of mutations changed drastically between version 2 and 3 of Fulcro. The low-level multimethod
requires a different format for the return value in version 3, and mutations directly handle network results in
3.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_stages_of_mutation"><a class="anchor" href="#_stages_of_mutation"></a><a class="link" href="#_stages_of_mutation">9.1. Stages of Mutation</a></h3>
<div class="paragraph">
<p>A mutation expresses the local effects, outgoing remote request(s), and network result processing for a given abstract
operation in a Fulcro application.</p>
</div>
<div class="paragraph">
<p>The local effects are applied first, the remote requests are queued, and the responses are processed as they
arrive.</p>
</div>
<div class="paragraph">
<p>The default behavior of the transaction processing system is to process <strong>all</strong> of the local effects of a given
transaction first, then submit all of the network requests later. This "optimistic" processing mode can be toggled
with an option to the top-level <code>transact!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this [(f) (g) (h)] {<span class="symbol">:optimistic?</span> <span class="predefined-constant">false</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would run the optimistic actions of <code>f</code>, wait for any network results, then run the optimistic actions of <code>g</code>, etc.</p>
</div>
<div class="paragraph">
<p>whereas</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this [(f) (g) (h)])</code></pre>
</div>
</div>
<div class="paragraph">
<p>will cause the optimistic actions of <code>f</code>, <code>g</code>, and <code>h</code> to all run, and then submit the network actions.</p>
</div>
<div class="paragraph">
<p>In Fulcro 3 each stage of the mutation is implemented as a lambda, and each stage receives an environment that
describes the state of the app (and even what the state looked like before the mutation started).</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_defmutation"><a class="anchor" href="#_using_defmutation"></a><a class="link" href="#_using_defmutation">9.2. Using <code>defmutation</code></a></h3>
<div class="paragraph">
<p>Using <code>defmutation</code> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation mutation-symbol
  <span class="string"><span class="delimiter">&quot;</span><span class="content">docstring</span><span class="delimiter">&quot;</span></span>
  [params]
  (action [{<span class="symbol">:keys</span> [state] <span class="symbol">:as</span> env}]
    (<span class="keyword">swap!</span> state <span class="keyword">..</span><span class="keyword">.</span>))
  (rest-api [env] <span class="predefined-constant">true</span>)
  (remote [env] <span class="predefined-constant">true</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>It intentionally looks a bit like a function definition so that IDE&#8217;s like Cursive can be told how to resolve
the macro (as <code>defn</code> in this case) and will then let you read the docstrings and navigate to the definition
from the usage sites. This makes development a lot easier.</p>
</div>
<div class="paragraph">
<p>The symbol itself does get interned into the local namespace as a function-like thing that will return
the call itself as data (i.e. running <code>(f {:x 1})</code> in a REPL returns the list <code>(the.ns/f {:x 1})</code>). This allows you
to use the mutation unquoted in most situations (except where there are circular references and you cannot require it):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app</span>
  (<span class="symbol">:require</span> [app.mutations <span class="symbol">:as</span> am]))

<span class="keyword">..</span><span class="keyword">.</span>
   (comp/transact! this [(am/mutation-symbol {})])</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You can get the "quoteless" feature <a href="#CircularRefs">using the <code>m/declare-mutation</code></a> function as well.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_the_env"><a class="anchor" href="#_the_env"></a><a class="link" href="#_the_env">9.2.1. The <code>env</code></a></h4>
<div class="paragraph">
<p>Each stage of the mutation will receive an environment parameter the has a number of things in it that can be
used to accomplish the real work of the mutation:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>:app</code></dt>
<dd>
<p>The application itself. Can be used to do things like call <code>transact!</code>, etc.</p>
</dd>
<dt class="hdlist1"><code>:component</code></dt>
<dd>
<p>Will be the component (if any) that ran the transaction</p>
</dd>
<dt class="hdlist1"><code>:ref</code></dt>
<dd>
<p>Will be the ident of the component (if any) that ran the transaction</p>
</dd>
<dt class="hdlist1"><code>:state</code></dt>
<dd>
<p>The atom holding the state database. Optimistic actions <code>swap!</code> on this.</p>
</dd>
<dt class="hdlist1"><code>:state-before-action</code></dt>
<dd>
<p>(in remotes) A map holding the value of the state database before the <code>:action</code> ran.</p>
</dd>
<dt class="hdlist1"><code>:ast</code></dt>
<dd>
<p>The AST of the mutation node that is running.</p>
</dd>
<dt class="hdlist1"><code>:com.fulcrologic.fulcro.algorithms.tx-processing/options</code></dt>
<dd>
<p>The map of options that was passed to <code>transact!</code> (if using
the default built-in transaction processing).</p>
</dd>
<dt class="hdlist1"><code>:result</code></dt>
<dd>
<p>(passed to <code>:result-action</code>, which may subsequently call <code>ok-action</code> or <code>error-action</code>).
The raw remote response. This raw result&#8217;s content will depend on the actual remote and middleware you&#8217;re
using for that remote, but it will typically include things like the raw response and the network result status code.</p>
</dd>
<dt class="hdlist1"><code>:dispatch</code></dt>
<dd>
<p>A map from section name to the lambdas that represent the other sections of the mutation (e.g. <code>:action</code>
in this map is the lambda representing the <code>action</code> section of the mutation). This can be used to cross-call
sections, usually to invent your own purpose-built sections of mutations via overriding the default <code>result-action</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_the_sections"><a class="anchor" href="#_the_sections"></a><a class="link" href="#_the_sections">9.2.2. The Sections</a></h4>
<div class="paragraph">
<p>The sections of a mutation include:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>action</code></dt>
<dd>
<p>The optimistic action. Run before any network traffic is submitted.</p>
</dd>
<dt class="hdlist1"><code>remote</code></dt>
<dd>
<p>Instructions for the remote side of the mutation. The names of these sections
are user-defined by the list of remotes you define when you create the application.
The return value of a remote determines what, if anything, is sent to that remote.</p>
</dd>
<dt class="hdlist1"><code>result-action</code></dt>
<dd>
<p>Optional. The default value of this can be overridden as an application parameter.
The <code>result-action</code> section receives network results as the arrive. The
default result action handles mutation return values and cross-calls <code>ok-action</code> or <code>error-action</code>.</p>
</dd>
<dt class="hdlist1"><code>ok-action</code></dt>
<dd>
<p>Optional. <strong>If</strong> you are using the default <code>result-action</code>, the <code>ok-action</code> is called when
the remote result received is free from errors.</p>
</dd>
<dt class="hdlist1"><code>error-action</code></dt>
<dd>
<p>Optional. <strong>If</strong> you are using the default <code>result-action</code>, the <code>error-action</code> is called
when the remote result was an error. See <a href="#WhatIsAnError">Defining Error Conditions</a>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_remote_mutations"><a class="anchor" href="#_remote_mutations"></a><a class="link" href="#_remote_mutations">9.3. Remote Mutations</a></h3>
<div class="paragraph">
<p>Mutations are already plain data, so Fulcro can pass them over the network as-is when the client invokes them. All you
need to do to indicate that a given mutation should affect a given remote is add that remote to the mutation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation add-friend [params]
  (action <span class="keyword">..</span><span class="keyword">.</span>) <span class="comment">; optimistic update of client state</span>
  (remote [env] <span class="predefined-constant">true</span>)) <span class="comment">; send the mutation to the remote known as :remote</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Take a moment to note that getting the "right" level of abstraction for these commands can give you
great leverage. These are the units of optimistic and full-stack operation.</p>
</div>
<div class="sect3">
<h4 id="_the_remote_sections"><a class="anchor" href="#_the_remote_sections"></a><a class="link" href="#_the_remote_sections">9.3.1. The <code>remote</code> Section(s)</a></h4>
<div class="paragraph">
<p>You can define any number of remotes for your Fulcro application.  The default remote is an HTTP remote that
talks to the server of the page at <code>/api</code> through HTTP POST requests. Additional remotes are created and named
by you.</p>
</div>
<div class="paragraph">
<p>The remote operation you want to run against any mutation just needs to share the name of that mutation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">app</span> (app/fulcro-application {<span class="symbol">:remotes</span> {<span class="symbol">:rest-api</span> <span class="keyword">..</span><span class="keyword">.</span>}}))

(defmutation some-thing [params]
  (rest-api [env] <span class="predefined-constant">true</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>A mutation is allowed to trigger itself against any number of simultaneous remotes.</p>
</div>
<div class="paragraph">
<p>The <strong>return</strong> value of a remote section must be one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>true</code>: Sends the exact expression that was sent via <code>transact!</code> to that remote.</p>
</li>
<li>
<p>An <code>env</code> containing an <code>:ast</code>: Sends the expression of the <code>:ast</code> key from that <code>env</code>. Useful with built-in helpers.</p>
</li>
<li>
<p>An EQL AST: Sends the expression of the AST node, which generally can be generated via <code>eql/query&#8594;ast1</code>.</p>
</li>
<li>
<p><code>false</code>: The same as not listing the section.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The remote section is treated as a lambda, and it is call <strong>after</strong> the optimistic action has run.
The <code>env</code> passed to it will include the <code>:state-before-action</code>
which is a snapshot (i.e. normalized database map) of the state before the optimistic change occurred.
This allows you to make the logic of your remote conditional on either the state as it is now (via <code>:state</code>) or before.</p>
</div>
<div class="paragraph">
<p>Therefore, you can alter a mutation simply by altering and returning the <code>ast</code> given in <code>env</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation do-thing [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  <span class="comment">; send (do-thing {:x 1}) even if params are different than that on the client</span>
  (remote [{<span class="symbol">:keys</span> [ast]}] (<span class="keyword">assoc</span> ast <span class="symbol">:params</span> {<span class="symbol">:x</span> <span class="integer">1</span>})) <span class="comment">; change the param list for the remote</span>

<span class="comment">; or using the with-params helper against `env`</span>
(defmutation do-thing [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  <span class="comment">; send (do-thing {:x 1}) even if params are different than that on the client</span>
  (remote [env] (m/with-params env {<span class="symbol">:x</span> <span class="integer">1</span>})) <span class="comment">; change the param list for the remote</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>or even change which mutation the server sees:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation some-mutation [ params]
  <span class="comment">;; Send a completely different mutation to the server</span>
  (remote [env] (eql/query-&gt;ast1 `[(some-other-thing {<span class="symbol">:x</span> <span class="integer">2</span>})])))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_result_action"><a class="anchor" href="#_result_action"></a><a class="link" href="#_result_action">9.3.2. Result Action</a></h4>
<div class="paragraph">
<p>A key part of <code>defmutation</code> is that it emits a "default" result action that does a number
of automatic operations for your mutation&#8217;s network results:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If there is an error, it calls your <code>error-action</code> section.</p>
</li>
<li>
<p>If there is not an error, it calls you <code>ok-action</code> section.</p>
</li>
<li>
<p>If it was configured with a global error handler, then that handler is called on errors (see the docstring
of <code>default-result-action</code>).</p>
</li>
<li>
<p>It merges and targets the mutation&#8217;s remote return value (if you indicated there was a return value).</p>
</li>
<li>
<p>It resolves tempids.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If you override the <code>result-action</code> section, then <strong>none</strong> of these default behaviors will happen unless you do them
yourself.  If you want to <strong>augment</strong> the default behavior, then you can manually call the <code>m/default-result-action</code>
function as part of your own <code>:result-action</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_plugging_in_a_new_global_result_action"><a class="anchor" href="#_plugging_in_a_new_global_result_action"></a><a class="link" href="#_plugging_in_a_new_global_result_action">9.3.3. Plugging in a New Global Result Action</a></h4>
<div class="paragraph">
<p>You can supply a lambda to use instead of <code>default-result-action</code> when you create your application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">app</span> (app/fulcro-app {<span class="symbol">:default-result-action</span> (<span class="keyword">fn</span> [env] <span class="keyword">..</span><span class="keyword">.</span>)}))</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
This setting will affect <strong>all</strong> mutations in your system, and should be used with care.  If you choose not
to call <code>m/default-result-action</code> within your custom function then mutation return values, tempid resolution,
and ok/error action handlers <strong>will not work</strong>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_optimistic_vs_pessimistic"><a class="anchor" href="#_optimistic_vs_pessimistic"></a><a class="link" href="#_optimistic_vs_pessimistic">9.3.4. Optimistic vs. Pessimistic</a></h4>
<div class="paragraph">
<p>The <code>action</code> portion of a mutation is run immediately on the client. When there is <em>also</em> a server interaction
then the client-side operation is known as an <strong>optimistic update</strong> because by default we assume that the server
will succeed in replicating the action. This gives the user immediate feedback and the ability to proceed quickly
even in the presence of a slow network.</p>
</div>
<div class="paragraph">
<p>You may, of course, decide not to do anything in the <code>action</code> section (don&#8217;t provide one). In this case you&#8217;re
operating in a pessimistic mode where the user won&#8217;t see a result until the network result has arrived and you
<code>:result-action</code> has processed it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_writing_the_server_mutations"><a class="anchor" href="#_writing_the_server_mutations"></a><a class="link" href="#_writing_the_server_mutations">9.3.5. Writing The Server Mutations</a></h4>
<div class="paragraph">
<p>Server-side mutations in Fulcro arrive as an EQL transaction, and must be interpreted as such. Typically you&#8217;ll use
an EQL parser built by Pathom. The <a href="https://wilkerlucio.github.io/pathom/#ConnectMutations">pathom <code>defmutation</code></a>
looks very similar to the Fulcro one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; CLIENT (Fulcro)</span>
<span class="comment">;; src/my_app/mutations.cljs</span>
(<span class="keyword">ns</span> <span class="namespace">my-app.mutations</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]]))

(defmutation do-something [{<span class="symbol">:keys</span> [p]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state <span class="keyword">assoc</span> <span class="symbol">:value</span> p))
  (remote [env] <span class="predefined-constant">true</span>))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; SERVER (Pathom)</span>
<span class="comment">;; src/my_app/mutations.clj</span>
(<span class="keyword">ns</span> <span class="namespace">my-app.mutations</span>
  (<span class="symbol">:require</span>
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;; `env` can be augmented in parser setup to include things like database connection, etc.</span>
(pc/defmutation do-something [env params]
  {}
  <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>or even a CLJC file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">my-app.mutations</span>
  (<span class="symbol">:require</span>
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]])))

<span class="error">#</span>?(<span class="symbol">:cljs</span>
    (defmutation do-something [{<span class="symbol">:keys</span> [p]}]
      (action [{<span class="symbol">:keys</span> [state]}]
        (<span class="keyword">swap!</span> state <span class="keyword">assoc</span> <span class="symbol">:value</span> p))
      (remote [env] <span class="predefined-constant">true</span>))

   <span class="symbol">:clj</span>
   (pc/defmutation do-something [env params]
     <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pathom lets you override the symbol on the server (via a <code>::pc/sym</code> options) but it is still a good idea to use the same actual namespace
(via clj/cljs pairs or just a CLJC file) to "co-locate" the mutations for easier code navigation. Your tools will likely
readily navigate you to just one of them, so having them side-by-side in CLJC is often the easiest to maintain,
even though it is a bit noisier to write.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="error">#</span>?(<span class="symbol">:clj</span> (pc/defmutation do-thing <span class="keyword">..</span><span class="keyword">.</span>)
   <span class="symbol">:cljs</span> (defmutation do-thing <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Fulcro&#8217;s mutations and Pathom&#8217;s mutations are both CLJC themselves.  This allows for things like using your UI
code (Fulcro&#8217;s <code>defmutation</code>) within the server for server-side rendering and building a client-layer EQL parser
(Pathom&#8217;s <code>defmutation</code>) to process EQL on simulated remotes in the client. Be careful that you don&#8217;t accidentally use
the wrong version of <code>defmutation</code> in a given context.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_new_item_creation_temporary_ids"><a class="anchor" href="#_new_item_creation_temporary_ids"></a><a class="link" href="#_new_item_creation_temporary_ids">9.3.6. New item creation – Temporary IDs</a></h4>
<div class="paragraph">
<p>Fulcro has a built in function <code>tempid/tempid</code> that will generate a unique temporary ID of a special type. This allows the normalization
and denormalization of the client side database to continue working while the server processes the new data and returns
the permanent identifier(s).</p>
</div>
<div class="paragraph">
<p>The idea is that these temporary IDs can be safely placed in your client database (and network queues), and will be
automatically rewritten to their real ID when the server has managed to create the real persistent entity. Of course, since
you have optimistic updates on the client it is important that things go in the correct sequence, and that queued operations
for the server don&#8217;t get confused about what ID is correct!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
It is generally considered a "best practice" to generate and pass tempids as parameters to a mutation from the
UI. This ensures that the same tempid flows through the local and all remotes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Fulcro&#8217;s implementation works as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Mutations always run in the order specified in the call to <code>transact!</code></p>
</li>
<li>
<p>Transmission of separate calls to <code>transact!</code> run in the order they were called.</p>
</li>
<li>
<p>If remote mutations are separated in time, then they go through a sequential networking queue, and are processed in order.</p>
</li>
<li>
<p>As mutations complete on the server, they can return tempid remappings. Those are applied to the application state <strong>and</strong> network
queue before the next network operation (load or mutation) is sent.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This set of rules helps ensure that you can reason about your program, even in the presence of optimistic updates that
could theoretically be somewhat ahead of the server.</p>
</div>
<div class="paragraph">
<p>For example, you could create an item, edit it, then delete it. The UI responds immediately, but the initial create might
still be running on the server. This means the server has not even given it a real ID before you&#8217;re queuing up a request
to delete it! With the above rules, it will just work! The network queue will have two backlogged operations (the edit
and the delete), each with the same tempid that you used from the start (since that&#8217;s what the ID is in app state).
When the create operation finally returns it will automatically rewrite all of the tempids in state and the network queues,
then send the next operation. Thus, the edit will apply to the correct server entity, as will the delete.</p>
</div>
<div class="paragraph">
<p>All the mutation has to do is return a map with the special key <code>:tempids</code>
whose value is a map of <code>tempid&#8594;realid</code>.
Here are the client-side and server-side implementations of the same mutation that create a new item:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; client</span>
<span class="comment">;; src/my_app/mutations.cljs</span>
(<span class="keyword">ns</span> <span class="namespace">my-app.mutations</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]]))

(defmutation new-item [{<span class="symbol">:keys</span> [tempid text]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state <span class="keyword">assoc-in</span> [<span class="symbol">:item/id</span> tempid] {<span class="symbol">:db/id</span> tempid <span class="symbol">:item/text</span> text}))
  (remote [env] <span class="predefined-constant">true</span>))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; server</span>
<span class="comment">;; src/my_app/mutations.clj</span>
(<span class="keyword">ns</span> <span class="namespace">my-app.mutations</span>
  (<span class="symbol">:require</span>
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

(pc/defmutation new-item [env {<span class="symbol">:keys</span> [tempid text]}]
  {}
  (<span class="keyword">let</span> [database-tempid (make-database-tempid)
        database-id (add-item-to-database database {<span class="symbol">:db/id</span> database-tempid <span class="symbol">:item/text</span> text})]
      {<span class="symbol">:tempids</span> {tempid database-id}})))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other mutation return values are covered in Mutation Return Values.</p>
</div>
<div class="sect4">
<h5 id="_avoiding_tempids"><a class="anchor" href="#_avoiding_tempids"></a><a class="link" href="#_avoiding_tempids">Avoiding Tempids</a></h5>
<div class="paragraph">
<p>It is also possible to avoid tempids altogether. For example, if you make a unique attribute (column) on your server-side entities (rows)
that holds a UUID. This has the following trade-offs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It consumes a bit more space in your database.</p>
</li>
<li>
<p>The client can generate new IDs for entities without needing a server connection.</p>
</li>
<li>
<p>If you use GUUIDs, then they are globally unique. They are all you might need in your data-store to find a given entity.</p>
</li>
<li>
<p>Transactions that use a UUID for creation are easier to make idempotent (can be applied more than once without breaking things).
Tempids are remapped by the server, so two creations in a row with the same tempid will create two different new rows.
This is a useful property for systems where you&#8217;d like to enable auto-retry at the network layer without worrying about correctness.</p>
</li>
<li>
<p>It is impossible to tell if an entity on the client is persisted without additional tracking. Tempids give you an
easy way to instantly "see" that something isn&#8217;t yet saved.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_actions_after_a_mutation"><a class="anchor" href="#_actions_after_a_mutation"></a><a class="link" href="#_actions_after_a_mutation">9.3.7. Actions After a Mutation</a></h4>
<div class="paragraph">
<p>Fulcro will automatically queue remote reads <strong>after</strong> writes when they are submitted in the same thread interaction. The
following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this `[(f)])
(df/load this <span class="symbol">:thing</span> Thing)
(comp/transact! this `[(g)])</code></pre>
</div>
</div>
<div class="paragraph">
<p>will result in two network interactions. The first will run <code>[(f) (g)]</code>, and the second will be a load of <code>:thing</code>. This
is a defined and official behavior.</p>
</div>
<div class="paragraph">
<p>Thus, one way you can implement a sequence of mutations followed by a read is to simply run a mutation and a load.</p>
</div>
<div class="paragraph">
<p>However, this is not sufficient in many cases because not only do you need to know what happened on the server, you
may also need to make some local changes to your application state <strong>based on</strong> that result. Common examples abound, but
include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You want to navigate away from a form after you know it is saved.</p>
</li>
<li>
<p>You want to close a payment modal after a charge is processed.</p>
</li>
<li>
<p>You want to route to a screen based upon a result.</p>
</li>
<li>
<p>You want to load <strong>something else</strong> based upon a prior result.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are several ways to accomplish these tasks in Fulcro 3: pessimistic transactions, and various approaches using
the <code>ok-action</code> and <code>error-action</code> of a mutation.</p>
</div>
</div>
<div class="sect3">
<h4 id="PTransact"><a class="anchor" href="#PTransact"></a><a class="link" href="#PTransact">9.3.8. Pessimistic Transactions</a></h4>
<div class="paragraph">
<p>A <strong>pessimistic transaction</strong> is a transaction processing semantic where each mutation in a transaction is processed
to completion (full stack) before the next mutation in <strong>that same transaction</strong> does <em>anything</em>. Pessimistic <em>transactions</em> have no
interaction with <strong>each other</strong> (other than guarantees of submission order).</p>
</div>
<div class="paragraph">
<p>This means that you can code a mutations whose optimistic action checks the result of the prior mutation to decide what
to do. This looks like this at the UI layer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this `[(charge-card) (route-after-charge)] {<span class="symbol">:optimistic?</span> <span class="predefined-constant">false</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>and will run the full-stack operations of <code>charge-card</code> <strong>before</strong> the optimistic action of <code>route-after-change</code>.</p>
</div>
<div class="paragraph">
<p>This mechanism has the advantage of keeping all transactions "top-level".  In other words this scheme makes the
sequence of transactions apparent right at the point of call to the initial <code>transact!</code> and you can follow
the sequence linearly right from there.  Unfortunately, you still have to analyze the nested logic in the mutations
to figure out what really happens. Fulcro 3 has some additional options for handling this.</p>
</div>
</div>
<div class="sect3">
<h4 id="_result_action_for_pessimism"><a class="anchor" href="#_result_action_for_pessimism"></a><a class="link" href="#_result_action_for_pessimism">9.3.9. Result Action for Pessimism</a></h4>
<div class="paragraph">
<p>You are allowed to submit new transactions (via <code>transact!</code> or <code>load!</code>) in the <code>ok-action</code> and <code>error-action</code> sections
of a mutation. Thus, instead of writing a top-level transaction you can simply queue the first action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this `[(charge-card)])</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then trigger the next step(s) in the mutation&#8217;s remote handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation charge-card [params]
  <span class="keyword">..</span><span class="keyword">.</span>
  (ok-action [{<span class="symbol">:keys</span> [app result] <span class="symbol">:as</span> env}]
    <span class="comment">;; you can `transact!`, `swap!`, etc.</span>
    (<span class="keyword">if</span> (charge-ok? result)
      (comp/transact! app [(show-ok-screen)])
      (comp/transact! app [(show-error-screen)]))))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_loads_as_mutations"><a class="anchor" href="#_using_loads_as_mutations"></a><a class="link" href="#_using_loads_as_mutations">9.3.10. Using Loads as Mutations</a></h4>
<div class="paragraph">
<p>There is technically nothing wrong with issuing a load that has side-effects on the server (though one could argue that
this is a bit sketchy from a design perspective). For example, one way to
implement login is to issue a load with the user&#8217;s credentials:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load <span class="symbol">:current-user</span> User {<span class="symbol">:params</span> {<span class="symbol">:username</span> u <span class="symbol">:password</span> p}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The server query response can validate the credentials, set a cookie, and return the user info all at once! Your UI can
simply base rendering on the values in <code>:current-user</code>. If they&#8217;re valid, you&#8217;re logged in.</p>
</div>
<div class="paragraph">
<p>If you remember from the General Operations section, you can modify the low-level Ring response by associating a lambda
with your return value. If you were using Ring Session, then this might be how the query would be implemented on the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">my-api</span>
  (<span class="symbol">:require</span> [fulcro.server <span class="symbol">:as</span> server <span class="symbol">:refer</span> [defmutation defquery-root]]))

(<span class="keyword">def</span> <span class="function">bad-user</span> {<span class="symbol">:db/id</span> <span class="integer">0</span>})

(pc/defresolver
  <span class="keyword">..</span><span class="keyword">.</span>
  (<span class="keyword">if-let</span> [{<span class="symbol">:keys</span> [db/id] <span class="symbol">:as</span> user} (authenticate params)] <span class="comment">; look up the user, return nil if bad</span>
    (server/augment-response user (<span class="keyword">fn</span> [resp] (<span class="keyword">assoc-in</span> resp [<span class="symbol">:session</span> <span class="symbol">:uid</span>] id)))
    bad-user)))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_running_mutations_in_the_context_of_an_entity"><a class="anchor" href="#_running_mutations_in_the_context_of_an_entity"></a><a class="link" href="#_running_mutations_in_the_context_of_an_entity">9.3.11. Running Mutations in the Context of an Entity</a></h4>
<div class="paragraph">
<p>If you submit a transaction and include an ident:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! app `[(f)] {<span class="symbol">:ref</span> [<span class="symbol">:person/id</span> <span class="integer">3</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>then the <code>env</code> of the mutation will include that explicit ref in the <code>env</code>. If you use <code>transact!</code> against a component
instance then <code>ref</code> is automatically set to the ident of that instance. This means that you can write mutations
that are "context sensitive" and can do things relative to the "invoking on-screen component instance". This is
how the mutation helper functions <code>m/set-string!</code> and <code>m/toggle!</code> work.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mutations_that_trigger_one_or_more_loads"><a class="anchor" href="#_mutations_that_trigger_one_or_more_loads"></a><a class="link" href="#_mutations_that_trigger_one_or_more_loads">9.3.12. Mutations that Trigger one or more Loads</a></h4>
<div class="paragraph">
<p>Mutations generally need not expose their full-stack nature to the UI. For
example a <code>next-page</code> mutation might trigger a load for the next page of
data or simply swap in some already cached data. The UI need not be
aware of the logic of this distinction (though typically the UI will
want to include loading markers, so it is common for there to be some
kind of knowledge about lazy loading).</p>
</div>
<div class="paragraph">
<p>Instead of coding complex "do I need to load that?" logic in the UI
(where it most certainly does <strong>not</strong> belong) one should instead write
mutations that abstract it into a nice concept.</p>
</div>
<div class="paragraph">
<p>The <code>df/load!</code> function simply runs a <code>transact!</code> on an internally-defined mutation
with a special <code>:result-action</code>.</p>
</div>
<div class="paragraph">
<p>If you&#8217;d like to compose one or more loads into a mutation you can simply call them from any part of your mutation
(even the remote sections, though technically it is probably better to use one of the <code>action</code> sections).</p>
</div>
<div class="paragraph">
<p>The basic pattern is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation next-page [params]
  (action [{<span class="symbol">:keys</span> [app state] <span class="symbol">:as</span> env}]
    (<span class="keyword">swap!</span> state <span class="keyword">..</span><span class="keyword">.</span>) <span class="comment">; local optimistic db updates</span>
    (df/load! app <span class="symbol">:prop</span> Component {<span class="symbol">:remote</span> <span class="symbol">:remote</span>}) <span class="comment">; same basic args as `load`, except state atom instead of `this`</span>
    (df/load! app <span class="symbol">:other</span> Other) {<span class="symbol">:remote</span> <span class="symbol">:other-remote</span>})) <span class="comment">; as many as you need...</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ReturnValues"><a class="anchor" href="#ReturnValues"></a><a class="link" href="#ReturnValues">9.4. Server Mutation Return Values</a></h3>
<div class="paragraph">
<p>We&#8217;ve talked a lot about the client-side perspective of mutations, what they send to the server, and where you can
place code to process the response of a mutation; however, we have not yet completely addressed the actual interaction
with the server.</p>
</div>
<div class="paragraph">
<p>A server mutation is always allowed to return a value. Normally the only value that makes sense is temporary ID
remappings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; server-side</span>
(defmutation new-thing [params]
  (action [env]
    <span class="keyword">..</span><span class="keyword">.</span>
    {<span class="symbol">:tempids</span> {old-id new-id}}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In some cases you&#8217;d like to return other details. However, remember that
any arbitrary data merge on the client needs a tree of data <strong>and</strong> a query. With a mutation <strong>there is no query</strong>!
As such, return values from mutations are <strong>ignored by default</strong> because there is no way to understand how to
merge the result into your database.</p>
</div>
<div class="paragraph">
<p>Of course, you can override <code>result-action</code> or <code>ok-action</code> and directly access the mutation return value
in <code>:result</code> of <code>env</code>, but this is Fulcro: we can do better!</p>
</div>
<div class="paragraph">
<p>If you want to make use of the returned values from the server then you need to add something to remedy the
lack of a query.</p>
</div>
<div class="sect3">
<h4 id="MutationJoins"><a class="anchor" href="#MutationJoins"></a><a class="link" href="#MutationJoins">9.4.1. Using Mutation Joins</a></h4>
<div class="paragraph">
<p>The solution might be obvious to you: include the query with the mutation! This is called a <strong>mutation join</strong>.
The explicit syntax in EQL for a mutation join looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">`[{(f) [<span class="symbol">:x</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>but you never write them this way because a manual query doesn&#8217;t have component metadata information and cannot
aid normalization. Instead, you write them just like you do when
grabbing queries for anything else:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{(f) (comp/get-query Item)}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running a mutation with this notation allows you to return a value from the server&#8217;s mutation that exactly matches the graph
of the item, and it will be automatically normalized and merged into your database. So, if the <code>Item</code> query ended up being
<code>[:item/id :item/value]</code> then the server mutation could just return a simple map like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; server-side.</span>
(pc/defmutation f [env params]
  {<span class="symbol">::pc/output</span> [<span class="symbol">:item/id</span>]}
   {<span class="symbol">:item/id</span> <span class="integer">1</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reason we&#8217;re only returning <code>:item/id</code> in this example is that Pathom resolvers understand how to resolve the
return value queries as if they were normal queries. This means that as long as there are resolvers that can
look up item details based on <code>:item/id</code> then the mutation need return nothing more, but the client can walk any
arbitrary graph from there!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
At the time of this writing the query must come from a UI component that <strong>has an ident</strong>. Thus, mutations joins
essentially normalize things into a specific table in your database (determined by the ID(s) of the return
value and the ident on the query&#8217;s component).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ASTMutationJoins"><a class="anchor" href="#ASTMutationJoins"></a><a class="link" href="#ASTMutationJoins">9.4.2. Mutation Joins: Simpler Notation</a></h4>
<div class="paragraph">
<p>Writing <code>transact!</code> using manual mutation joins in the UI is a quite visually noisy. It turns out there is a better way.
If you remember: the remote section of client mutations can modify the remote EQL. Fulcro comes with helper functions that can
rewrite the AST of the mutation to modify the parameters or convert it to a mutation join! This can simplify how the
mutations look in the UI.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the difference. With the manual syntactic technique we just described your UI and client mutation would look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; in the UI</span>
(transact! this `[{(f) ~(comp/get-query Item)}])

<span class="comment">; in your mutation definition (client-side)</span>
(defmutation f [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [env] <span class="predefined-constant">true</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, using the helpers you can instead write it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; in the UI</span>
(transact! this `[(f)])

<span class="comment">; in your mutation definition (client-side)</span>
(defmutation f [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [{<span class="symbol">:keys</span> [ast state]}] (returning env Item))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes the mutation join an artifact of the <strong>network interaction</strong>, and less for you to manually code (and read) in the UI.</p>
</div>
<div class="paragraph">
<p>The server-side code is the same for both: just return a proper graph value!</p>
</div>
</div>
<div class="sect3">
<h4 id="_targeting_return_values_from_mutation_joins"><a class="anchor" href="#_targeting_return_values_from_mutation_joins"></a><a class="link" href="#_targeting_return_values_from_mutation_joins">9.4.3. Targeting Return Values From Mutation Joins</a></h4>
<div class="paragraph">
<p>If you deal with return type at the mutation then Fulcro gives you some additional bonus features: <code>m/with-params</code> and
<code>m/with-target</code>. These can be used together to fully customize the outgoing request.
Remember that <code>m/returning</code> just sets the return type. By default, you&#8217;re just returning some entity tree. The data gets
normalized, but there is no further linkage into your app state.</p>
</div>
<div class="paragraph">
<p>You will sometimes need to change outgoing parameters on the mutation, and also to pepper idents around your app state
to point at the return value.</p>
</div>
<div class="paragraph">
<p>These helpers all work on <code>env</code> and return <code>env</code>, and the remote sections accept <code>env</code> as a return value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation f [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [env]
    (<span class="keyword">-&gt;</span> env
      (m/with-params (<span class="keyword">merge</span> params {<span class="symbol">:api-token</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">cygnus x-1</span><span class="delimiter">&quot;</span></span>}))
      (m/returning Item)
      (m/with-target (targeting/append-to [<span class="symbol">:path</span> <span class="symbol">:to</span> <span class="symbol">:field</span>])))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>All special targets are supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation f [params]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [{<span class="symbol">:keys</span> [ast state]}]
    (<span class="keyword">-&gt;</span> ast
      (m/returning state Item)
      (m/with-target
        (targeting/multiple-targets
          (targeting/append-to [<span class="symbol">:table</span> <span class="integer">3</span> <span class="symbol">:field</span>])
          (targeting/prepend-to [<span class="symbol">:table-2</span> <span class="integer">4</span> <span class="symbol">:field</span>]))))))</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_demo_of_mutation_joins"><a class="anchor" href="#_demo_of_mutation_joins"></a><a class="link" href="#_demo_of_mutation_joins">Demo of Mutation Joins</a></h5>
<div class="paragraph">
<p>The demo below cover the basics of using mutation joins.
It demonstrates:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Targeting Raw Values</p>
<div class="paragraph">
<p>If you don&#8217;t specify a component with <code>returning</code>, then your returned data can be targeted, but of course it
won&#8217;t normalize:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation trigger-error
  <span class="string"><span class="delimiter">&quot;</span><span class="content">This mutation causes an unstructured error on the server (just a map), but targets that value
   to the field `:error-message` on the component that invoked it.</span><span class="delimiter">&quot;</span></span>
  [_]
  (remote [{<span class="symbol">:keys</span> [<span class="keyword">ref</span>] <span class="symbol">:as</span> env}]
    (m/with-target env (<span class="keyword">conj</span> <span class="keyword">ref</span> <span class="symbol">:error-message</span>))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the server simply returns a raw value (map is recommended)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defmutation trigger-error [_ _]
  (action [env]
    {<span class="symbol">:error</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">something bad</span><span class="delimiter">&quot;</span></span>}))</code></pre>
</div>
</div>
</li>
<li>
<p>Targeting Graph Results</p>
<div class="paragraph">
<p>In the demo The bulk of the work is done in the <code>create-entity</code> mutation.
which is targeting to-many so we can demo more features.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation  create-entity
  <span class="string"><span class="delimiter">&quot;</span><span class="content">This mutation simply creates a new entity, but targets it to a specific location
  (in this case the `:child` field of the invoking component).</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [where?] <span class="symbol">:as</span> params}]
  (remote [{<span class="symbol">:keys</span> [ast <span class="keyword">ref</span> state]}]
    (<span class="keyword">let</span> [path-to-target (<span class="keyword">conj</span> <span class="keyword">ref</span> <span class="symbol">:children</span>)
          <span class="comment">; replacement cannot succeed if there is nothing present...turn those into appends</span>
          no-items?      (<span class="keyword">empty?</span> (<span class="keyword">get-in</span> @state path-to-target))
          where?         (<span class="keyword">if</span> (<span class="keyword">and</span> no-items? (<span class="keyword">=</span> <span class="symbol">:replace-first</span> where?))
                           <span class="symbol">:append</span>
                           where?)]
      (cond-&gt; (<span class="keyword">-&gt;</span> ast
                <span class="comment">; always set what kind of thing is coming back</span>
                (m/returning state Entity)
                <span class="comment">; strip the where?...it is for local use only (not server)</span>
                (m/with-params (<span class="keyword">dissoc</span> params <span class="symbol">:where?</span>)))
        <span class="comment">; Add the targeting...based on where?</span>
        (<span class="keyword">=</span> <span class="symbol">:append</span> where?) (m/with-target (targeting/append-to path-to-target)) <span class="comment">; where to put it</span>
        (<span class="keyword">=</span> <span class="symbol">:prepend</span> where?) (m/with-target (targeting/prepend-to path-to-target))
        (<span class="keyword">=</span> <span class="symbol">:replace-first</span> where?) (m/with-target (targeting/replace-at (<span class="keyword">conj</span> path-to-target <span class="integer">0</span>)))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The server mutation just returns the entity.</p>
</div>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 14. <a id="TargetingMutationReturnValues"></a><a href="#TargetingMutationReturnValues">Targeting Mutation Return Values</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('server-targeting-return-values-into-app-state')">Focus Inspector</button>
<div class="short narrow example" id="server-targeting-return-values-into-app-state"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.server-targeting-return-values-into-app-state</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.algorithms.data-targeting <span class="symbol">:as</span> targeting]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="error">#</span>_#_#_(<span class="keyword">def</span> <span class="function">ids</span> (<span class="keyword">atom</span> <span class="integer">1</span>))

    (server/defmutation trigger-error [_]
      (action [env]
        {<span class="symbol">:error</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">something bad</span><span class="delimiter">&quot;</span></span>}))

    (server/defmutation create-entity [{<span class="symbol">:keys</span> [db/id]}]
      (action [env]
        (<span class="keyword">let</span> [real-id (<span class="keyword">swap!</span> ids <span class="keyword">inc</span>)]
          {<span class="symbol">:db/id</span>        real-id
           <span class="symbol">:entity/label</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Entity </span><span class="delimiter">&quot;</span></span> real-id)
           <span class="symbol">:tempids</span>      {id real-id}})))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
(<span class="keyword">declare</span> <span class="function">Item</span> Entity)

(defmutation trigger-error
  <span class="string"><span class="delimiter">&quot;</span><span class="content">This mutation causes an unstructured error (just a map), but targets that value
   to the field `:error-message` on the component that invokes it.</span><span class="delimiter">&quot;</span></span>
  [_]
  (remote [{<span class="symbol">:keys</span> [ast <span class="keyword">ref</span>]}]
    (m/with-target ast (<span class="keyword">conj</span> <span class="keyword">ref</span> <span class="symbol">:error-message</span>))))

(defmutation create-entity
  <span class="string"><span class="delimiter">&quot;</span><span class="content">This mutation simply creates a new entity, but targets it to a specific location
  (in this case the `:child` field of the invoking component).</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [where?] <span class="symbol">:as</span> params}]
  (remote [{<span class="symbol">:keys</span> [ast <span class="keyword">ref</span> state]}]
    (<span class="keyword">let</span> [path-to-target (<span class="keyword">conj</span> <span class="keyword">ref</span> <span class="symbol">:children</span>)
          <span class="comment">; replacement cannot succeed if there is nothing present...turn those into appends</span>
          no-items?      (<span class="keyword">empty?</span> (<span class="keyword">get-in</span> @state path-to-target))
          where?         (<span class="keyword">if</span> (<span class="keyword">and</span> no-items? (<span class="keyword">=</span> <span class="symbol">:replace-first</span> where?))
                           <span class="symbol">:append</span>
                           where?)]
      (cond-&gt; (<span class="keyword">-&gt;</span> ast
                <span class="comment">; always set what kind of thing is coming back</span>
                (m/returning state Entity)
                <span class="comment">; strip the where?...it is for local use only (not server)</span>
                (m/with-params (<span class="keyword">dissoc</span> params <span class="symbol">:where?</span>)))
        <span class="comment">; Add the targeting...based on where?</span>
        (<span class="keyword">=</span> <span class="symbol">:append</span> where?) (m/with-target (targeting/append-to path-to-target)) <span class="comment">; where to put it</span>
        (<span class="keyword">=</span> <span class="symbol">:prepend</span> where?) (m/with-target (targeting/prepend-to path-to-target))
        (<span class="keyword">=</span> <span class="symbol">:replace-first</span> where?) (m/with-target (targeting/replace-at (<span class="keyword">conj</span> path-to-target <span class="integer">0</span>)))))))

(defsc Entity [this {<span class="symbol">:keys</span> [entity/label]}]
  {<span class="symbol">:ident</span> [<span class="symbol">:entity/by-id</span> <span class="symbol">:db/id</span>]
   <span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:entity/label</span>]}
  (dom/div label))

(<span class="keyword">def</span> <span class="function">ui-entity</span> (comp/factory Entity {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc Item [this {<span class="symbol">:keys</span> [db/id error-message children]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span> <span class="symbol">:error-message</span> {<span class="symbol">:children</span> (comp/get-query Entity)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="symbol">:param/id</span> <span class="symbol">:children</span> []}
   <span class="symbol">:ident</span>         [<span class="symbol">:item/by-id</span> <span class="symbol">:db/id</span>]}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:float</span>  <span class="string"><span class="delimiter">&quot;</span><span class="content">left</span><span class="delimiter">&quot;</span></span>
                    <span class="symbol">:width</span>  <span class="string"><span class="delimiter">&quot;</span><span class="content">200px</span><span class="delimiter">&quot;</span></span>
                    <span class="symbol">:margin</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">5px</span><span class="delimiter">&quot;</span></span>
                    <span class="symbol">:border</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1px solid black</span><span class="delimiter">&quot;</span></span>}}
    (dom/h4 (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Item </span><span class="delimiter">&quot;</span></span> id))
    (<span class="keyword">when</span> error-message
      (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">The generated error was: </span><span class="delimiter">&quot;</span></span> (<span class="keyword">pr-str</span> error-message)))
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [evt] (comp/transact! this `[(trigger-error {})]))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Trigger Error</span><span class="delimiter">&quot;</span></span>)
    (dom/h6 <span class="string"><span class="delimiter">&quot;</span><span class="content">Children</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">map</span> ui-entity children)
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [evt] (comp/transact! this `[(create-entity {<span class="symbol">:where?</span> <span class="symbol">:prepend</span> <span class="symbol">:db/id</span> ~(comp/tempid)})]))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Prepend one!</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [evt] (comp/transact! this `[(create-entity {<span class="symbol">:where?</span> <span class="symbol">:append</span> <span class="symbol">:db/id</span> ~(comp/tempid)})]))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Append one!</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [evt] (comp/transact! this `[(create-entity {<span class="symbol">:where?</span> <span class="symbol">:replace-first</span> <span class="symbol">:db/id</span> ~(comp/tempid)})]))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Replace first one!</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-item</span> (comp/factory Item {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [root/items]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:root/items</span> (comp/get-query Item)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:root/items</span> [{<span class="symbol">:id</span> <span class="integer">1</span>} {<span class="symbol">:id</span> <span class="integer">2</span>} {<span class="symbol">:id</span> <span class="integer">3</span>}]}}
  (dom/div
    (mapv ui-item items)
    (dom/br {<span class="symbol">:style</span> {<span class="symbol">:clear</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">both</span><span class="delimiter">&quot;</span></span>}})))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_augmenting_the_ring_response"><a class="anchor" href="#_augmenting_the_ring_response"></a><a class="link" href="#_augmenting_the_ring_response">9.4.4. Augmenting the Ring Response</a></h4>
<div class="paragraph">
<p>The middleware that comes with Fulcro can modify the outgoing response in arbitrary ways. By default it sets the content
type to transit and the body to the EDN your mutation(s) have returned (as a map keyed by mutation symbol).
However, there are times when you need to modify something about the low-level response itself (such
as adding a cookie).</p>
</div>
<div class="paragraph">
<p>You can ask Fulcro&#8217;s middleware to do additional changes to the Ring response by adding metadata to your mutation
response. The built-in function <code>api-middleware/augment-response</code> can be used to easily accomplish this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defmutation f [env params]
  {}
  (api-middleware/augment-response
    {<span class="symbol">:normal</span> <span class="symbol">:response</span>}
    (<span class="keyword">fn</span> [ring-response] modified-ring-response)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, if you are using the <code>api-middleware/wrap-api</code> and Ring Session middleware you could cause user
information to be stored in a server session store simply by returning this from a query on user:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="keyword">..</span><span class="keyword">.</span>
(<span class="keyword">let</span> [user (find-user <span class="keyword">..</span><span class="keyword">.</span>)]
   (server/augment-response user (<span class="keyword">fn</span> [resp] (update resp <span class="symbol">:session</span> <span class="keyword">merge</span> {<span class="symbol">:uid</span> real-uid}))))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_additional_mutation_topics"><a class="anchor" href="#_additional_mutation_topics"></a><a class="link" href="#_additional_mutation_topics">9.5. Additional Mutation Topics</a></h3>
<div class="sect3">
<h4 id="_ownership_and_mutations"><a class="anchor" href="#_ownership_and_mutations"></a><a class="link" href="#_ownership_and_mutations">9.5.1. Ownership and Mutations</a></h4>
<div class="paragraph">
<p>A common case that causes some confusion is working with mutations that affect the ownership of some child in the UI.
In these cases, the parent can
be seen as a UI component in control of the children (it is responsible for telling them to render). In such cases it is
usually better to reason about the <strong>management</strong> logic (i.e. deleting, reordering, etc) from the parent; however,
it is commonly the case the you want the <strong>child</strong> to render some controls, such as a delete button. Thus, the control
that wants to modify the state (the delete button on the item) is not local to the component that will need to refresh
(the parent&#8217;s list).</p>
</div>
<div class="paragraph">
<p>The solution is simple: create a callback in the parent that can run the delete transaction and pass it through
as a computed value.</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. <a id="Parent-ChildOwnership"></a><a href="#Parent-ChildOwnership">Parent-Child Ownership</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('parent-child-ownership-relations')">Focus Inspector</button>
<div class="short narrow example" id="parent-child-ownership-relations"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.parent-child-ownership-relations</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.algorithms.merge <span class="symbol">:as</span> <span class="keyword">merge</span>]
    [taoensso.timbre <span class="symbol">:as</span> log]))

<span class="comment">; Not using an atom, so use a tree for app state (will auto-normalize via ident functions)</span>
(<span class="keyword">def</span> <span class="function">initial-state</span> {<span class="symbol">:ui/react-key</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">abc</span><span class="delimiter">&quot;</span></span>
                    <span class="symbol">:main-list</span>    {<span class="symbol">:list/id</span>    <span class="integer">1</span>
                                   <span class="symbol">:list/name</span>  <span class="string"><span class="delimiter">&quot;</span><span class="content">My List</span><span class="delimiter">&quot;</span></span>
                                   <span class="symbol">:list/items</span> [{<span class="symbol">:item/id</span> <span class="integer">1</span> <span class="symbol">:item/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}
                                                {<span class="symbol">:item/id</span> <span class="integer">2</span> <span class="symbol">:item/label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>}]}})

(m/defmutation delete-item
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Mutation: Delete an item from a list</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [list-id id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Deleting item</span><span class="delimiter">&quot;</span></span> id <span class="string"><span class="delimiter">&quot;</span><span class="content">from list</span><span class="delimiter">&quot;</span></span> list-id)
    (<span class="keyword">swap!</span> state
      (<span class="keyword">fn</span> [s]
        (<span class="keyword">-&gt;</span> s
          (update <span class="symbol">:items</span> <span class="keyword">dissoc</span> id)
          (merge/remove-ident* [<span class="symbol">:items</span> id] [<span class="symbol">:lists</span> list-id <span class="symbol">:list/items</span>]))))))

(defsc Item [this
             {<span class="symbol">:keys</span> [item/id item/label] <span class="symbol">:as</span> props}
             {<span class="symbol">:keys</span> [on-delete] <span class="symbol">:as</span> computed}]              ;; <b class="conum">(1)</b>
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [id label]}] {<span class="symbol">:item/id</span> id <span class="symbol">:item/label</span> label})
   <span class="symbol">:query</span>         [<span class="symbol">:item/id</span> <span class="symbol">:item/label</span>]
   <span class="symbol">:ident</span>         [<span class="symbol">:items</span> <span class="symbol">:item/id</span>]}
  (dom/li label (dom/button {<span class="symbol">:onClick</span> #(on-delete id)} <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-list-item</span> (comp/factory Item {<span class="symbol">:keyfn</span> <span class="symbol">:item/id</span>}))

(defsc ItemList [this {<span class="symbol">:list/keys</span> [id <span class="keyword">name</span> items]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {<span class="symbol">:list/id</span>    <span class="integer">1</span>
                           <span class="symbol">:list/name</span>  <span class="string"><span class="delimiter">&quot;</span><span class="content">List 1</span><span class="delimiter">&quot;</span></span>
                           <span class="symbol">:list/items</span> [(comp/get-initial-state Item {<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>})
                                        (comp/get-initial-state Item {<span class="symbol">:id</span> <span class="integer">2</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>})]})
   <span class="symbol">:query</span>         [<span class="symbol">:list/id</span> <span class="symbol">:list/name</span> {<span class="symbol">:list/items</span> (comp/get-query Item)}]
   <span class="symbol">:ident</span>         [<span class="symbol">:lists</span> <span class="symbol">:list/id</span>]}
  (<span class="keyword">let</span> [delete-item (<span class="keyword">fn</span> [item-id] (comp/transact! this [(delete-item {<span class="symbol">:list-id</span> id <span class="symbol">:id</span> item-id})])) ;; <b class="conum">(2)</b>
        item-props  (<span class="keyword">fn</span> [i] (comp/computed i {<span class="symbol">:on-delete</span> delete-item}))]
    (dom/div
      (dom/h4 <span class="keyword">name</span>)
      (dom/ul
        (<span class="keyword">map</span> #(ui-list-item (item-props %)) items)))))

(<span class="keyword">def</span> <span class="function">ui-list</span> (comp/factory ItemList))

(defsc Root [this {<span class="symbol">:keys</span> [main-list]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {<span class="symbol">:main-list</span> (comp/get-initial-state ItemList {})})
   <span class="symbol">:query</span>         [{<span class="symbol">:main-list</span> (comp/get-query ItemList)}]}
  (dom/div (ui-list main-list)))</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The item uses the computed callback</p>
</li>
<li>
<p>The list creates a lambda that closes over the list id</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="CircularRefs"><a class="anchor" href="#CircularRefs"></a><a class="link" href="#CircularRefs">9.5.2. Mutations Without Quoting or Circular References</a></h4>
<div class="paragraph">
<p>There are times when  you need to use a component in a mutation (for a merge, for example), but the component is also
using mutations. You can easily end up with circular references in your code which Clojure does not allow.
Of course since mutations are just data you can just quote the fully-qualified mutation name in
the UI, but that is inconvenient because the names get rather long.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this '[(some.namespace.that.is.long/f params)])</code></pre>
</div>
</div>
<div class="paragraph">
<p>and it also leads to another problem:  Did you notice the error in that last expression?  <code>params</code> wasn&#8217;t <strong>un</strong>-quoted!:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this '[(some.namespace.that.is.long/f ~params)])</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_declare_your_mutations_elsewhere"><a class="anchor" href="#_declare_your_mutations_elsewhere"></a><a class="link" href="#_declare_your_mutations_elsewhere">Declare Your Mutations Elsewhere</a></h5>
<div class="paragraph">
<p>The <code>defmutation</code> macro creates a version of itself that is actually a mutation declaration. You can use that same
feature to put <strong>delcarations</strong> of your mutations in a namespace <strong>different from</strong> the mutation itself. Thus, you can
code up a mutation "interface" namespace that won&#8217;t generate circular references with the UI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">my-mutations</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [declare-mutation]])

(declare-mutation boo 'real-ns.of.mutations/boo)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and now you can use this new <code>boo</code> in place of the real one without quoting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">real-ui</span>
  (<span class="symbol">:require</span>
    [my-mutations <span class="symbol">:refer</span> [boo]]
    <span class="keyword">..</span><span class="keyword">.</span>))

<span class="keyword">..</span><span class="keyword">.</span>

   (comp/transact! this [(boo {<span class="symbol">:a</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span> <span class="symbol">:b</span> <span class="integer">22</span>})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s really not much to the magic.  <code>boo</code> becomes a function-like thing that just returns a list with the proper
symbols and data in it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(boo {<span class="symbol">:a</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>}) =&gt; '(real-ns.of.mutations/boo {<span class="symbol">:a</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, since your real mutation is in a
whole different namespace that is never required by the UI or the interface you are now free to
require the UI in the mutation namespace if you need it for merges and other component-centric mutations concerns
without causing circular references.</p>
</div>
<div class="paragraph">
<p>This requires an extra namespace and a little extra declaration work, but cleans up the UI and ns requires quite well.</p>
</div>
</div>
<div class="sect4">
<h5 id="_use_the_component_registry"><a class="anchor" href="#_use_the_component_registry"></a><a class="link" href="#_use_the_component_registry">Use the Component Registry</a></h5>
<div class="paragraph">
<p>There is also a global component registry that can help with this problem. Any component that is (transitively) required
in your application will appear in the registry. This makes it possible to track component classes in app state
(since the name is serializable) and also look up a component class for merges from within mutations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation f [params]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">let</span> [todo-list-class (comp/registry-key-&gt;class <span class="symbol">:com.company.app/TodoList</span>)]
      (<span class="keyword">swap!</span> comp/merge-component todo-list-class {<span class="symbol">:list/id</span> <span class="keyword">..</span><span class="keyword">.</span>}))))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ide_integration"><a class="anchor" href="#_ide_integration"></a><a class="link" href="#_ide_integration">9.5.3. IDE Integration</a></h4>
<div class="paragraph">
<p>The syntax of <code>defmutation</code> and <code>declare-mutation</code> are both intentionally "shaped" like <code>defn</code> and <code>def</code> so that you
can tell your IDE how to resolve them.  In IntelliJ, you can do this by clicking on the macro name (e.g. <code>defmutation</code>)
and waiting for the light bulb.  Then select "Resolve as" and then <code>defn</code> for <code>defmutation</code> and <code>def</code> for <code>delcare-mutation</code>.</p>
</div>
<div class="paragraph">
<p>You may not need to do this for <code>defmutation</code>, as IntelliJ does have some predefined resolutions for Fulcro built-in.</p>
</div>
</div>
<div class="sect3">
<h4 id="_recommendations_about_writing_mutations"><a class="anchor" href="#_recommendations_about_writing_mutations"></a><a class="link" href="#_recommendations_about_writing_mutations">9.5.4. Recommendations About Writing Mutations</a></h4>
<div class="paragraph">
<p>Mutations themselves are meant to be abstractions across the entire stack; however, the optimistic side of them are
really just functions on your application state. Components have nice clean abstractions,
and you will often benefit from writing low-level functions that represent the general operations on a component&#8217;s data. As
you move towards higher-level abstractions you&#8217;ll want to compose those lower-level functions. As such, it pays
to think a little about how this will look over time.</p>
</div>
<div class="paragraph">
<p>If you write the <strong>actual logic</strong> of a mutation into a <code>defmutation</code>, then composition is difficult because mutations
are not functions, and wont' compose as functions.</p>
</div>
<div class="paragraph">
<p>To maximize code reuse, local reasoning, and general readability it pays to think about your mutations in the following manner:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A mutation is a function that changes the state of the application: <code>state &#8594; state'</code></p>
</li>
<li>
<p>Within a mutation, you are essentially doing operations to a graph, which means you have operations that
work on some node in the graph: <code>node &#8594; node'</code>. These operations may modifiy a scalar or an edge to another node.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_mutation_helpers"><a class="anchor" href="#_mutation_helpers"></a><a class="link" href="#_mutation_helpers">Mutation "Helpers"</a></h5>
<div class="paragraph">
<p>Fulcro adopts the general notation of suffixing functions with <code>*</code> when they operate on a normalized state map (not atom).
These functions are referred to as "mutation helpers" because they can easily be used with <code>swap!</code> against the mutation
atom:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">swap!</span> state merge/integrate-ident* <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and composed together as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">create-person*</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Create a person entity and add it to the normalized database in state-map.</span><span class="delimiter">&quot;</span></span>
  [state-map id <span class="keyword">name</span>]
  (<span class="keyword">assoc-in</span> state-map [<span class="symbol">:person/id</span> id] {<span class="symbol">:person/id</span> id <span class="symbol">:person/name</span> <span class="keyword">name</span>}))

(defmutation create-friend
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Mutation: create a new person and add them to the friends list</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:person/keys</span> [id <span class="keyword">name</span>]}]
  (action [{<span class="symbol">:keys</span> [state]}]
      (<span class="keyword">swap!</span> state
        (<span class="keyword">fn</span> [s]
          (<span class="keyword">-&gt;</span> s
            (create-person* id <span class="keyword">name</span>)
            (merge/integrate-ident* [<span class="symbol">:person/id</span> id] <span class="symbol">:append</span> [<span class="symbol">:list/id</span> <span class="symbol">:friends</span> <span class="symbol">:list/people</span>])))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and your mutations become a thing of beauty!</p>
</div>
<div class="paragraph">
<p>Of course, this can also be overkill. It is true that it is often handy to be able to compose many db operations together
into one abstract mutation, but don&#8217;t forget that more that one mutation can be triggered by a single call
to <code>transact!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this `[(route-to {<span class="symbol">:handler</span> <span class="symbol">:show-friend</span> <span class="symbol">:route-params</span> {<span class="symbol">:person-id</span> ~target-id}})
                       (add-friend {<span class="symbol">:source-person-id</span> ~my-id <span class="symbol">:target-id</span> ~target-id})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll want to balance your mutations just like you do any other library of code: so that
reuse and clarity are maximized. In the case of mutations the deciding factor is often
how you want to deal with remote mutations.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_mutation_topics"><a class="anchor" href="#_advanced_mutation_topics"></a><a class="link" href="#_advanced_mutation_topics">9.6. Advanced Mutation Topics</a></h3>
<div class="paragraph">
<p>This section covers a number of additional mutation techniques that arise in more advanced situations.</p>
</div>
<div class="paragraph">
<p>A lot of these things are handled for you with normal <a href="#FullStack">full-stack operations</a>, so you might want to skip this
section until you&#8217;re comfortable with that material.</p>
</div>
<div class="sect3">
<h4 id="MutationMultimethod"><a class="anchor" href="#MutationMultimethod"></a><a class="link" href="#MutationMultimethod">9.6.1. Using the Multimethod Directly</a></h4>
<div class="paragraph">
<p>The multi-method approach just requires you to return a map containing all of the things that should be done.
This looks somewhat similar to <code>defmutation</code> in structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defmethod</span> <span class="function">com.fulcrologic.fulcro.mutations/mutate</span> `mutation-symbol [params]
   {<span class="symbol">:action</span> (<span class="keyword">fn</span> [env] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:result-action</span> (<span class="keyword">fn</span> [env] <span class="keyword">..</span><span class="keyword">.</span>)
    <span class="symbol">:remote</span> (<span class="keyword">fn</span> [env] <span class="predefined-constant">true</span>)})</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Reminder</div>
<div class="paragraph">
<p>The example above uses syntax quoting on the symbol which will add the current
namespace to it. In any case the symbol is just that: a symbol (data) that acts as the dispatch
key for the multimethod. If you use a plain quote (<code>'</code>) then you should manually namespace the symbol.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The biggest trick to this technique is the <code>:result-action</code> key. Any remote results will be passed, unprocessed, to this
handler <strong>and only this handler</strong>.  The <code>defmutation</code> macro uses a default implementation of this action
that merges results, checks for errors, calls other handlers, etc. If you make a multimethod, then you will not
get <strong>any</strong> of that built-in behavior. If all you want to do is change the result
action, then look into setting the <code>:default-result-action</code> option when you create your application.</p>
</div>
<div class="paragraph">
<p>If you would like your multimethod mutation to work like <code>defmutation</code> then you should do the following in your
<code>:result-action</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defmethod</span> <span class="function">m/mutate</span> `mutation-symbol [params]
   {<span class="keyword">..</span><span class="keyword">.</span>
    <span class="symbol">:result-action</span> (<span class="keyword">fn</span> [env]
                     (<span class="keyword">when-let</span> [default-action (lookup/app-algorithm (<span class="symbol">:app</span> env) <span class="symbol">:default-result-action</span>)]
                       (default-action env)))
    <span class="keyword">..</span><span class="keyword">.</span>
    })</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_app_directly"><a class="anchor" href="#_using_app_directly"></a><a class="link" href="#_using_app_directly">9.6.2. Using <code>app</code> Directly</a></h4>
<div class="paragraph">
<p>When you set up your application it is best to save it in a global place so that you can use it outside of the normal
flow of things (e.g. a websocket push notification):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! app <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_swapping_on_the_state_atom"><a class="anchor" href="#_swapping_on_the_state_atom"></a><a class="link" href="#_swapping_on_the_state_atom">9.6.3. Swapping on the State Atom?</a></h4>
<div class="paragraph">
<p>You can technically tweak the database atom in the application directly, but that side-steps all of the internals
of Fulcro including UI refresh. It can be handy in limited cases, but generally we recommend you use
<code>transact!</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Fulcro 3 does <strong>not</strong> watch the state atom (though Inspect does).
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [{<span class="symbol">::app/keys</span> [state-atom]} app]
  (<span class="keyword">swap!</span> state-atom <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do such a change then you are responsible for triggering a UI refresh (if you want one).  You can schedule a
render by calling <code>(app/schedule-render! app)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_leveraging_treedb_and_dbtree"><a class="anchor" href="#_leveraging_treedb_and_dbtree"></a><a class="link" href="#_leveraging_treedb_and_dbtree">9.6.4. Leveraging <code>tree&#8594;db</code> and <code>db&#8594;tree</code></a></h4>
<div class="paragraph">
<p>It is sometimes useful to convert a bit of the database to a tree for manipulation in a mutation, or the other
way around. Remember that these utility functions exist as part of the toolbox.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_integrate_ident"><a class="anchor" href="#_using_integrate_ident"></a><a class="link" href="#_using_integrate_ident">9.6.5. Using <code>integrate-ident</code></a></h4>
<div class="paragraph">
<p>When in a mutation you very often need to place an ident in various spots in your graph database. The helper
function <code>merge/integrate-ident*</code> can by used from within mutations to help you do this. It accepts
any number of named parameters that specify operations to do with a given ident:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">swap!</span> state
  (<span class="keyword">fn</span> [s]
    (<span class="keyword">-&gt;</span> s
       (do-some-op)
       (integrate-ident* the-ident
         <span class="symbol">:append</span> [<span class="symbol">:table</span> id <span class="symbol">:field</span>]
         <span class="symbol">:prepend</span> [<span class="symbol">:other</span> id <span class="symbol">:field</span>]))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function checks for the existence of the given ident in the target list, and will refuse to add it if it is
already there. The <code>:replace</code> option can be used on a to-one or to-many relation. When replacing on a to-many, you
use an index in the target path (e.g. <code>[:table id :field 2]</code> would replace the third element in a to-many <code>:field</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_components_just_for_their_queries"><a class="anchor" href="#_creating_components_just_for_their_queries"></a><a class="link" href="#_creating_components_just_for_their_queries">9.6.6. Creating Components <strong>Just</strong> For Their Queries</a></h4>
<div class="paragraph">
<p>If your UI doesn&#8217;t have a query that is convenient for sending to the server (or for working on tree data like this),
then it is considered perfectly fine to generate components just for their queries (no render). This is often quite
useful, especially in the context of pre-loading data that gets placed on the UI in a completely different form (e.g. the
UI queries don&#8217;t match what you&#8217;d like to ask the server).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc SubQuery [t p]
  {<span class="symbol">:ident</span> [<span class="symbol">:sub/id</span> <span class="symbol">:id</span>]
   <span class="symbol">:query</span> [<span class="symbol">:id</span> <span class="symbol">:data</span>]})

(defsc TopQuery [t p]
  {<span class="symbol">:ident</span> [<span class="symbol">:top/id</span> <span class="symbol">:id</span>]
   <span class="symbol">:query</span> [<span class="symbol">:id</span> {<span class="symbol">:subs</span> (comp/get-query SubQuery)}]})</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 16. <a id="TreetoDBwithQueries"></a><a href="#TreetoDBwithQueries">Tree to DB with Queries</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('tree-to-db')">Focus Inspector</button>
<div class="short narrow example" id="tree-to-db"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.tree-to-db</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [devcards.util.edn-renderer <span class="symbol">:refer</span> [html-edn]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.algorithms.normalize <span class="symbol">:as</span> fnorm]))

(defsc SubQuery [t p]
  {<span class="symbol">:ident</span> [<span class="symbol">:sub/by-id</span> <span class="symbol">:id</span>]
   <span class="symbol">:query</span> [<span class="symbol">:id</span> <span class="symbol">:data</span>]})

(defsc TopQuery [t p]
  {<span class="symbol">:ident</span> [<span class="symbol">:top/by-id</span> <span class="symbol">:id</span>]
   <span class="symbol">:query</span> [<span class="symbol">:id</span> {<span class="symbol">:subs</span> (comp/get-query SubQuery)}]})

(defmutation normalize-from-to-result [ignored-params]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">let</span> [result (fnorm/tree-&gt;db TopQuery (<span class="symbol">:from</span> @state) <span class="predefined-constant">true</span>)]
      (<span class="keyword">swap!</span> state <span class="keyword">assoc</span> <span class="symbol">:result</span> result))))

(defmutation reset [ignored-params] (action [{<span class="symbol">:keys</span> [state]}] (<span class="keyword">swap!</span> state <span class="keyword">dissoc</span> <span class="symbol">:result</span>)))

(defsc Root [this {<span class="symbol">:keys</span> [from result]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:from</span> <span class="symbol">:result</span>]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params]
                    <span class="comment">; some data we're just shoving into the database from root...***not normalized***</span>
                    {<span class="symbol">:from</span> {<span class="symbol">:id</span> <span class="symbol">:top-1</span> <span class="symbol">:subs</span> [{<span class="symbol">:id</span> <span class="symbol">:sub-1</span> <span class="symbol">:data</span> <span class="integer">1</span>} {<span class="symbol">:id</span> <span class="symbol">:sub-2</span> <span class="symbol">:data</span> <span class="integer">2</span>}]}})}
  (dom/div
    (dom/div
      (dom/h4 <span class="string"><span class="delimiter">&quot;</span><span class="content">Pretend Incoming Tree</span><span class="delimiter">&quot;</span></span>)
      (html-edn from))
    (dom/div
      (dom/h4 <span class="string"><span class="delimiter">&quot;</span><span class="content">Normalized Result (click below to normalize)</span><span class="delimiter">&quot;</span></span>)
      (<span class="keyword">when</span> result
        (html-edn result)))
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [] (comp/transact! this `[(normalize-from-to-result {})]))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Normalized (Run tree-&gt;db)</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [] (comp/transact! this `[(reset {})]))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Clear Result</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>of course, you can see that you&#8217;re still going to need to merge the database table contents into your main app state
and carefully integrate the other bits as well.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Reminder</div>
<div class="paragraph">
<p>The <strong><code>ident</code></strong> part of the component is the magic here. This is why you <strong>need</strong> component queries for
this to work right. The <code>ident</code> functions are used to determine the table locations and idents to place into
the normalized database!</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_com_fulcrologic_fulcro_componentsmerge"><a class="anchor" href="#_using_com_fulcrologic_fulcro_componentsmerge"></a><a class="link" href="#_using_com_fulcrologic_fulcro_componentsmerge">9.6.7. Using <code>com.fulcrologic.fulcro.components/merge!</code></a></h4>
<div class="paragraph">
<p>Fulcro includes a function that takes care of the rest of these bits for you. It requires the reconciler (which
as we mentioned earlier can be obtained from the Fulcro App). The arguments are similar to <code>tree&#8594;db</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(merge/merge! (<span class="symbol">:reconciler</span> @app) ROOT-data ROOT-query)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same things apply as <code>tree&#8594;db</code> (idents especially), however, the result of the transform will make it&#8217;s way into
the app state (which is owned by the reconciler).</p>
</div>
<div class="paragraph">
<p><strong>IMPORTANT</strong>: The biggest challenge with using this function is that it requires the data and query to be structured
from the ROOT of the database! That is sometimes perfectly fine, but our next section talks about a helper that
might be easier to use.")</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_mergemerge_component"><a class="anchor" href="#_using_mergemerge_component"></a><a class="link" href="#_using_mergemerge_component">9.6.8. Using <code>merge/merge-component!</code></a></h4>
<div class="paragraph">
<p>There is a common special case that comes up often: You want to merge something that is in the context of some particular UI component.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(merge/merge-component! app ComponentClass ComponentData)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Think of this case as: I have some data for a given component (which MUST have an ident). I want to merge into that
component&#8217;s entry in a table, but I want to make sure the recursive tree of data also gets normalized
properly.</p>
</div>
<div class="paragraph">
<p><code>merge-component!</code> also integrates the functionality of <code>integrate-ident*</code> to pepper the ident of the merged entity throughout
your app database, and can often serve as a total one-stop
shop for merging data that is coming from some external source.</p>
</div>
<div class="paragraph">
<p>This first argument can be an application or reconciler.</p>
</div>
<div class="sect4">
<h5 id="_merge_component_demo"><a class="anchor" href="#_merge_component_demo"></a><a class="link" href="#_merge_component_demo">Merge-component! Demo</a></h5>
<div class="paragraph">
<p>In the card below the button simulates some external event that has brought in data that
we&#8217;d like to merge (a newly arrived counter entity):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{ <span class="symbol">:counter/id</span> <span class="integer">5</span> <span class="symbol">:counter/n</span> <span class="integer">66</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll want to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add the counter to the counter&#8217;s table (which is not even present because we have none in our initial app state)</p>
</li>
<li>
<p>Add the ident of the counter to the UI panel so its UI shows up</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Counter [this {<span class="symbol">:keys</span> [counter/id counter/n] <span class="symbol">:as</span> props} {<span class="symbol">:keys</span> [onClick] <span class="symbol">:as</span> computed}]
  {<span class="symbol">:query</span> [<span class="symbol">:counter/id</span> <span class="symbol">:counter/n</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:counter/id</span> <span class="symbol">:counter/id</span>]}
   <span class="keyword">..</span><span class="keyword">.</span>

(<span class="keyword">defn</span> <span class="function">add-counter</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Merge the given counter data into app state and append it to our list of counters</span><span class="delimiter">&quot;</span></span>
  [app counter]
  (comp/merge-component! app Counter counter
    <span class="symbol">:append</span> [<span class="symbol">:panels/by-kw</span> <span class="symbol">:counter</span> <span class="symbol">:counters</span>]))

<span class="keyword">..</span><span class="keyword">.</span>
(defsc Root <span class="keyword">..</span><span class="keyword">.</span>
  (<span class="keyword">let</span> [app (comp/any-&gt;app this)]  <span class="comment">; another way to get to the app</span>
    (dom/button {<span class="symbol">:onClick</span> #(add-counter app {<span class="symbol">:counter/id</span> <span class="integer">4</span> <span class="symbol">:counter/n</span> <span class="integer">22</span>})} <span class="string"><span class="delimiter">&quot;</span><span class="content">Simulate Data Import</span><span class="delimiter">&quot;</span></span>)
   <span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the full running example with source:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. <a id="MergingwithaComponent"></a><a href="#MergingwithaComponent">Merging with a Component</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('merge-component')">Focus Inspector</button>
<div class="short narrow example" id="merge-component"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.merge-component</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.fulcrologic.fulcro.algorithms.merge <span class="symbol">:as</span> <span class="keyword">merge</span>]))

(defsc Counter [this {<span class="symbol">:keys</span> [counter/id counter/n] <span class="symbol">:as</span> props} {<span class="symbol">:keys</span> [onClick] <span class="symbol">:as</span> computed}]
  {<span class="symbol">:query</span> [<span class="symbol">:counter/id</span> <span class="symbol">:counter/n</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:counter/by-id</span> <span class="symbol">:counter/id</span>]}
  (dom/div <span class="symbol">:.</span>counter
    (dom/span <span class="symbol">:.</span>counter-label
      (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Current count for counter </span><span class="delimiter">&quot;</span></span> id <span class="string"><span class="delimiter">&quot;</span><span class="content">:  </span><span class="delimiter">&quot;</span></span>))
    (dom/span <span class="symbol">:.</span>counter-value n)
    (dom/button {<span class="symbol">:onClick</span> #(onClick id)} <span class="string"><span class="delimiter">&quot;</span><span class="content">Increment</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-counter</span> (comp/factory Counter {<span class="symbol">:keyfn</span> <span class="symbol">:counter/id</span>}))

<span class="comment">; the * suffix is just a notation to indicate an implementation of something..in this case the guts of a mutation</span>
(<span class="keyword">defn</span> <span class="function">increment-counter*</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Increment a counter with ID counter-id in a Fulcro database.</span><span class="delimiter">&quot;</span></span>
  [database counter-id]
  (<span class="keyword">update-in</span> database [<span class="symbol">:counter/by-id</span> counter-id <span class="symbol">:counter/n</span>] <span class="keyword">inc</span>))

(defmutation increment-counter [{<span class="symbol">:keys</span> [id] <span class="symbol">:as</span> params}]
  <span class="comment">; The local thing to do</span>
  (action [{<span class="symbol">:keys</span> [state] <span class="symbol">:as</span> env}]
    (<span class="keyword">swap!</span> state increment-counter* id))
  <span class="comment">; The remote thing to do. True means &quot;the same (abstract) thing&quot;. False (or omitting it) means &quot;nothing&quot;</span>
  (remote [env] <span class="predefined-constant">true</span>))

(defsc CounterPanel [this {<span class="symbol">:keys</span> [counters]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:counters</span> []})
   <span class="symbol">:query</span>         [{<span class="symbol">:counters</span> (comp/get-query Counter)}]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:panels/by-kw</span> <span class="symbol">:counter</span>])}
  (<span class="keyword">let</span> [click-callback (<span class="keyword">fn</span> [id] (comp/transact! this
                                  `[(increment-counter {<span class="symbol">:id</span> ~id}) <span class="symbol">:counter/by-id</span>]))]
    (dom/div
      <span class="comment">; embedded style: kind of silly in a real app, but doable</span>
      (dom/style <span class="string"><span class="delimiter">&quot;</span><span class="content">.counter { width: 400px; padding-bottom: 20px; }
                  button { margin-left: 10px; }</span><span class="delimiter">&quot;</span></span>)
      <span class="comment">; computed lets us pass calculated data to our component's 3rd argument. It has to be</span>
      <span class="comment">; combined into a single argument or the factory would not be React-compatible (not would it be able to handle</span>
      <span class="comment">; children).</span>
      (<span class="keyword">map</span> #(ui-counter (comp/computed % {<span class="symbol">:onClick</span> click-callback})) counters))))

(<span class="keyword">def</span> <span class="function">ui-counter-panel</span> (comp/factory CounterPanel))

(<span class="keyword">defonce</span> <span class="function">timer-id</span> (<span class="keyword">atom</span> <span class="integer">0</span>))
(<span class="keyword">declare</span> <span class="function">sample-of-counter-app-with-merge-component-fulcro-app</span>)

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; The code of interest...</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
(<span class="keyword">defn</span> <span class="function">add-counter</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">NOTE: A function callable from anywhere as long as you have a reconciler...</span><span class="delimiter">&quot;</span></span>
  [app counter]
  (merge/merge-component! app Counter counter
    <span class="symbol">:append</span> [<span class="symbol">:panels/by-kw</span> <span class="symbol">:counter</span> <span class="symbol">:counters</span>]))

(defsc Root [this {<span class="symbol">:keys</span> [panel]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:panel</span> (comp/get-query CounterPanel)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:panel</span> {}}}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:border</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1px solid black</span><span class="delimiter">&quot;</span></span>}}
    <span class="comment">; NOTE: A plain function...pretend this is happening outside of the UI...we're doing it here so we can embed it in the book...</span>
    (dom/button {<span class="symbol">:onClick</span> #(add-counter (comp/any-&gt;app this) {<span class="symbol">:counter/id</span> <span class="integer">4</span> <span class="symbol">:counter/n</span> <span class="integer">22</span>})} <span class="string"><span class="delimiter">&quot;</span><span class="content">Simulate Data Import</span><span class="delimiter">&quot;</span></span>)
    (dom/hr)
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters:</span><span class="delimiter">&quot;</span></span>
    (ui-counter-panel panel)))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_loads"><a class="anchor" href="#_loads"></a><a class="link" href="#_loads">10. Loads</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most of your server API should be written with something like <a href="https://wilkerlucio.github.io/pathom/#Connect">Pathom Connect</a>.
There are also ways to adapt to GraphQL servers, REST APIs, etc.  This chapter will be strictly using a Pathom parser
to supply data from the servers according to the following database schema and data:</p>
</div>
<div class="sect2">
<h3 id="_load_demo_database"><a class="anchor" href="#_load_demo_database"></a><a class="link" href="#_load_demo_database">10.1. Load Demo Database</a></h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.database</span>
  (<span class="symbol">:require</span>
    [cljs.spec.alpha <span class="symbol">:as</span> s]
    [datascript.core <span class="symbol">:as</span> d]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [cljs.core.async <span class="symbol">:as</span> async]
    clojure.pprint
    [taoensso.timbre <span class="symbol">:as</span> log]))

(<span class="keyword">def</span> <span class="function">schema</span> {<span class="symbol">:person/id</span>            {<span class="symbol">:db/unique</span> <span class="symbol">:db.unique/identity</span>}
             <span class="symbol">:person/spouse</span>        {<span class="symbol">:db/cardinality</span> <span class="symbol">:db.cardinality/one</span>}
             <span class="symbol">:person/children</span>      {<span class="symbol">:db/cardinality</span> <span class="symbol">:db.cardinality/many</span>}
             <span class="symbol">:person/addresses</span>     {<span class="symbol">:db/cardinality</span> <span class="symbol">:db.cardinality/many</span>}
             <span class="symbol">:person/phone-numbers</span> {<span class="symbol">:db/cardinality</span> <span class="symbol">:db.cardinality/many</span>}})

(<span class="keyword">defonce</span> <span class="function">connection</span> (d/create-conn schema))

(<span class="keyword">defn</span> <span class="function">db</span> [connection] (<span class="keyword">deref</span> connection))

(<span class="keyword">defn</span> <span class="function">seed-database</span> []
  (d/transact! connection [{<span class="symbol">:db/id</span>                <span class="integer">1</span>
                            <span class="symbol">:person/id</span>            <span class="integer">1</span>
                            <span class="symbol">:person/age</span>           <span class="integer">45</span>
                            <span class="symbol">:person/name</span>          <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>
                            <span class="symbol">:person/spouse</span>        <span class="integer">2</span>
                            <span class="symbol">:person/addresses</span>     #{<span class="integer">100</span>}
                            <span class="symbol">:person/phone-numbers</span> #{<span class="integer">10</span> <span class="integer">11</span>}
                            <span class="symbol">:person/children</span>      #{<span class="integer">4</span> <span class="integer">3</span>}}

                           {<span class="symbol">:db/id</span>        <span class="integer">10</span>
                            <span class="symbol">:phone/id</span>     <span class="integer">10</span>
                            <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">812-555-1212</span><span class="delimiter">&quot;</span></span>
                            <span class="symbol">:phone/type</span>   <span class="symbol">:work</span>}

                           {<span class="symbol">:db/id</span>        <span class="integer">11</span>
                            <span class="symbol">:phone/id</span>     <span class="integer">11</span>
                            <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">502-555-1212</span><span class="delimiter">&quot;</span></span>
                            <span class="symbol">:phone/type</span>   <span class="symbol">:home</span>}

                           {<span class="symbol">:db/id</span>        <span class="integer">12</span>
                            <span class="symbol">:phone/id</span>     <span class="integer">12</span>
                            <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">503-555-1212</span><span class="delimiter">&quot;</span></span>
                            <span class="symbol">:phone/type</span>   <span class="symbol">:work</span>}

                           {<span class="symbol">:db/id</span>                <span class="integer">2</span>
                            <span class="symbol">:person/id</span>            <span class="integer">2</span>
                            <span class="symbol">:person/name</span>          <span class="string"><span class="delimiter">&quot;</span><span class="content">Tom</span><span class="delimiter">&quot;</span></span>
                            <span class="symbol">:person/age</span>           <span class="integer">48</span>
                            <span class="symbol">:person/phone-numbers</span> #{<span class="integer">11</span> <span class="integer">12</span>}
                            <span class="symbol">:person/addresses</span>     #{<span class="integer">100</span>}
                            <span class="symbol">:person/spouse</span>        <span class="integer">1</span>
                            <span class="symbol">:person/children</span>      #{<span class="integer">3</span> <span class="integer">4</span>}}

                           {<span class="symbol">:db/id</span>            <span class="integer">3</span>
                            <span class="symbol">:person/id</span>        <span class="integer">3</span>
                            <span class="symbol">:person/age</span>       <span class="integer">17</span>
                            <span class="symbol">:person/addresses</span> #{<span class="integer">100</span>}
                            <span class="symbol">:person/name</span>      <span class="string"><span class="delimiter">&quot;</span><span class="content">Amy</span><span class="delimiter">&quot;</span></span>}

                           {<span class="symbol">:db/id</span>            <span class="integer">4</span>
                            <span class="symbol">:person/id</span>        <span class="integer">4</span>
                            <span class="symbol">:person/age</span>       <span class="integer">25</span>
                            <span class="symbol">:person/addresses</span> #{<span class="integer">100</span>}
                            <span class="symbol">:person/name</span>      <span class="string"><span class="delimiter">&quot;</span><span class="content">Billy</span><span class="delimiter">&quot;</span></span>
                            <span class="symbol">:person/children</span>  #{<span class="integer">5</span>}}

                           {<span class="symbol">:db/id</span>            <span class="integer">5</span>
                            <span class="symbol">:person/addresses</span> #{<span class="integer">100</span>}
                            <span class="symbol">:person/id</span>        <span class="integer">5</span>
                            <span class="symbol">:person/age</span>       <span class="integer">1</span>
                            <span class="symbol">:person/name</span>      <span class="string"><span class="delimiter">&quot;</span><span class="content">Billy Jr.</span><span class="delimiter">&quot;</span></span>}

                           {<span class="symbol">:db/id</span>               <span class="integer">100</span>
                            <span class="symbol">:address/id</span>          <span class="integer">100</span>
                            <span class="symbol">:address/street</span>      <span class="string"><span class="delimiter">&quot;</span><span class="content">101 Main St</span><span class="delimiter">&quot;</span></span>
                            <span class="symbol">:address/city</span>        <span class="string"><span class="delimiter">&quot;</span><span class="content">Nowhere</span><span class="delimiter">&quot;</span></span>
                            <span class="symbol">:address/state</span>       <span class="string"><span class="delimiter">&quot;</span><span class="content">GA</span><span class="delimiter">&quot;</span></span>
                            <span class="symbol">:address/postal-code</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">99999</span><span class="delimiter">&quot;</span></span>}]))

(pc/defresolver person-resolver [{<span class="symbol">:keys</span> [connection]} {<span class="symbol">:person/keys</span> [id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/name</span>
                <span class="symbol">:person/age</span>
                {<span class="symbol">:person/addresses</span> [<span class="symbol">:address/id</span>]}
                {<span class="symbol">:person/phone-numbers</span> [<span class="symbol">:phone/id</span>]}
                {<span class="symbol">:person/spouse</span> [<span class="symbol">:person/id</span>]}
                {<span class="symbol">:person/children</span> [<span class="symbol">:person/id</span>]}]}
  (d/pull (db connection)
    [<span class="symbol">:person/name</span>
     <span class="symbol">:person/age</span>
     {<span class="symbol">:person/addresses</span> [<span class="symbol">:address/id</span>]}
     {<span class="symbol">:person/phone-numbers</span> [<span class="symbol">:phone/id</span>]}
     {<span class="symbol">:person/spouse</span> [<span class="symbol">:person/id</span>]}
     {<span class="symbol">:person/children</span> [<span class="symbol">:person/id</span>]}]
    id))

(pc/defresolver all-people-resolver [{<span class="symbol">:keys</span> [connection]} _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:all-people</span> [<span class="symbol">:person/id</span>]}]}
  {<span class="symbol">:all-people</span> (mapv
                 (<span class="keyword">fn</span> [id] {<span class="symbol">:person/id</span> id})
                 (d/q '[<span class="symbol">:find</span> [?e <span class="keyword">..</span><span class="keyword">.</span>]
                        <span class="symbol">:where</span>
                        [?e <span class="symbol">:person/id</span>]]
                   (db connection)))})

(pc/defresolver address-resolver [{<span class="symbol">::p/keys</span> [parent-query]
                                   <span class="symbol">:keys</span>    [connection] <span class="symbol">:as</span> env} {<span class="symbol">:address/keys</span> [id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:address/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:address/street</span> <span class="symbol">:address/state</span> <span class="symbol">:address/city</span> <span class="symbol">:address/postal-code</span>]}
  (d/pull (db connection) parent-query id))

(pc/defresolver phone-resolver [{<span class="symbol">::p/keys</span> [parent-query]
                                 <span class="symbol">:keys</span>    [connection] <span class="symbol">:as</span> env} {<span class="symbol">:phone/keys</span> [id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:phone/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:phone/number</span> <span class="symbol">:phone/type</span>]}
  (d/pull (db connection) parent-query id))

<span class="comment">;; Allow a person ID to resolve to (any) one of their addresses</span>
(pc/defresolver default-address-resolver [{<span class="symbol">:keys</span> [connection]} {<span class="symbol">:person/keys</span> [id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:address/id</span>]}
  (<span class="keyword">let</span> [address-id (d/q '[<span class="symbol">:find</span> ?a <span class="keyword">.</span>
                          <span class="symbol">:in</span> $ ?pid
                          <span class="symbol">:where</span>
                          [?pid <span class="symbol">:person/addresses</span> ?addr]
                          [?addr <span class="symbol">:address/id</span> ?a]]
                     (db connection) id)]
    (<span class="keyword">when</span> address-id
      {<span class="symbol">:address/id</span> address-id})))

<span class="comment">;; Resolve :server/time-ms anywhere in a query. Allows us to timestamp a result.</span>
(pc/defresolver time-resolver [_ _]
  {<span class="symbol">::pc/output</span> [<span class="symbol">:server/time-ms</span>]}
  {<span class="symbol">:server/time-ms</span> (inst-ms (js/Date.))})

(<span class="keyword">def</span> <span class="function">general-resolvers</span> [phone-resolver address-resolver person-resolver
                        default-address-resolver
                        all-people-resolver time-resolver])</code></pre>
</div>
</div>
<div class="paragraph">
<p>This database and small set of resolvers can resolve quite complex queries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="clojure">(parse
  [{<span class="symbol">:all-people</span> [<span class="symbol">:person/name</span>
                 <span class="symbol">:person/age</span>
                 {<span class="symbol">:person/phone-numbers</span> [<span class="symbol">:phone/number</span> <span class="symbol">:phone/type</span>]}
                 {<span class="symbol">:person/spouse</span> [<span class="symbol">:person/name</span>]}
                 {<span class="symbol">:person/children</span> [<span class="symbol">:person/name</span> {<span class="symbol">:person/spouse</span> [<span class="symbol">:person/name</span>]}]}
                 {<span class="symbol">:person/addresses</span> [<span class="symbol">:address/street</span>]}
                 {<span class="symbol">:person/addresses</span> [<span class="symbol">:address/id</span> <span class="symbol">:address/street</span> <span class="symbol">:address/state</span>
                                     <span class="symbol">:address/city</span> <span class="symbol">:address/postal-code</span>]}]}])
<span class="comment">;; result</span>
{<span class="symbol">:all-people</span>
 [{<span class="symbol">:person/spouse</span> {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Tom</span><span class="delimiter">&quot;</span></span>},
   <span class="symbol">:person/age</span> <span class="integer">45</span>,
   <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>,
   <span class="symbol">:person/children</span> [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Amy</span><span class="delimiter">&quot;</span></span>} {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Billy</span><span class="delimiter">&quot;</span></span>}],
   <span class="symbol">:person/addresses</span> [{<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">101 Main St</span><span class="delimiter">&quot;</span></span>}],
   <span class="symbol">:person/phone-numbers</span>
   [{<span class="symbol">:phone/type</span> <span class="symbol">:work</span>, <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">812-555-1212</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:phone/type</span> <span class="symbol">:home</span>, <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">502-555-1212</span><span class="delimiter">&quot;</span></span>}]}
  {<span class="symbol">:person/spouse</span> {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sally</span><span class="delimiter">&quot;</span></span>},
   <span class="symbol">:person/age</span> <span class="integer">48</span>,
   <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Tom</span><span class="delimiter">&quot;</span></span>,
   <span class="symbol">:person/children</span> [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Amy</span><span class="delimiter">&quot;</span></span>} {<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Billy</span><span class="delimiter">&quot;</span></span>}],
   <span class="symbol">:person/addresses</span> [{<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">101 Main St</span><span class="delimiter">&quot;</span></span>}],
   <span class="symbol">:person/phone-numbers</span>
   [{<span class="symbol">:phone/type</span> <span class="symbol">:home</span>, <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">502-555-1212</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:phone/type</span> <span class="symbol">:work</span>, <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">503-555-1212</span><span class="delimiter">&quot;</span></span>}]}
  {<span class="symbol">:person/age</span> <span class="integer">17</span>,
   <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Amy</span><span class="delimiter">&quot;</span></span>,
   <span class="symbol">:person/addresses</span> [{<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">101 Main St</span><span class="delimiter">&quot;</span></span>}]}
  {<span class="symbol">:person/age</span> <span class="integer">25</span>,
   <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Billy</span><span class="delimiter">&quot;</span></span>,
   <span class="symbol">:person/children</span> [{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Billy Jr.</span><span class="delimiter">&quot;</span></span>}],
   <span class="symbol">:person/addresses</span> [{<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">101 Main St</span><span class="delimiter">&quot;</span></span>}]}
  {<span class="symbol">:person/age</span> <span class="integer">1</span>,
   <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Billy Jr.</span><span class="delimiter">&quot;</span></span>,
   <span class="symbol">:person/addresses</span> [{<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">101 Main St</span><span class="delimiter">&quot;</span></span>}]}]}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_playing_with_the_database"><a class="anchor" href="#_playing_with_the_database"></a><a class="link" href="#_playing_with_the_database">10.1.1. Playing with the Database</a></h4>
<div class="paragraph">
<p>If you&#8217;re running the live book with <a href="#_install_fulcro_inspect">Inspect installed</a> you can leverage a really nice feature
of that tool: When you use Pathom as your parser it is able to send an autocomplete index to your tools, which allows you
play with the parser on your server to see what it can do!</p>
</div>
<div class="paragraph">
<p>Try the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Go to the <a href="#LoadingDataBasics">Loading Data Basics</a> example.</p>
</li>
<li>
<p>Open Fulcro Inspect</p>
</li>
<li>
<p>Focus the inspector on that example (Use the "Focus Inspector" button).</p>
</li>
<li>
<p>In Inspect, choose the Query sub-tab.</p>
</li>
<li>
<p>In the while bar just below the tabs there is a round grey button and a "Run query". Button. <strong>Press the grey button</strong>. This
will load the indexes from the Pathom server. The button should turn green.</p>
</li>
<li>
<p>Place your cursor in the left half of the query tool. This is where you type in queries. Autocomplete should be
working (try typing <code>:</code> inside of the vector)!</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="title">Example 18. Server Query Autocomplete</div>
<div class="content">
<div class="imageblock">
<div class="content">
<img src="assets/img/query-autocomplete-1.png" alt="Server Query Autocomplete">
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you write a legal query and press "Run query", it will contact the server and give you the result.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. Server Query Result</div>
<div class="content">
<div class="imageblock">
<div class="content">
<img src="assets/img/query-autocomplete-2.png" alt="Server Query Autocomplete">
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Some quick keyboard shortcuts (OSX):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CMD-J</code>: Turn the keyword under the cursor into a query join (wrap it in a map with a subquery vector).</p>
</li>
<li>
<p><code>CMD-ENTER</code>: Run the query</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="DataFetch"><a class="anchor" href="#DataFetch"></a><a class="link" href="#DataFetch">10.2. The Data Fetch API: <code>load!</code></a></h3>
<div class="paragraph">
<p>Let&#8217;s say we want to load all of our friends from the server. A query has to be rooted somewhere, so we&#8217;ve invented
a root-level keyword, <code>:all-people</code> that can query the database for every entity that has a <code>:person/id</code>.  In Fulcro
component queries that would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:all-people</span> (comp/get-query Person)}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>What we&#8217;d like to see then from the server is a return value with the shape of the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{ <span class="symbol">:all-friends</span> [ {<span class="symbol">:person/id</span> <span class="integer">1</span> <span class="keyword">..</span><span class="keyword">.</span>} {<span class="symbol">:person/id</span> <span class="integer">2</span> <span class="keyword">..</span><span class="keyword">.</span>} <span class="keyword">..</span><span class="keyword">.</span>] }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we combined that query with the tree result and were to manually call <code>merge/merge!</code> then
we&#8217;d end up with this in our client database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{ <span class="symbol">:all-friends</span> [ [<span class="symbol">:person/id</span> <span class="integer">1</span>] [<span class="symbol">:person/id</span> <span class="integer">2</span>] <span class="keyword">..</span><span class="keyword">.</span>]
  <span class="symbol">:person/id</span> { <span class="integer">1</span> { <span class="symbol">:person/id</span> <span class="integer">1</span> <span class="keyword">..</span><span class="keyword">.</span>}
               <span class="integer">2</span> { <span class="symbol">:person/id</span> <span class="integer">2</span> <span class="keyword">..</span><span class="keyword">.</span>}
               <span class="keyword">..</span><span class="keyword">.</span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The data fetch API has a simple function for this that will do all of these together (query derivation, server
interaction, and merge):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">my-thing</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]))

<span class="keyword">..</span><span class="keyword">.</span>

  (df/load! comp-or-app <span class="symbol">:all-friends</span> Person)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first argument is the component (i.e. <code>this</code>) or the application. The next argument is a keyword or an
ident, and the next argument defines the type of thing (to-one or many) that will be the next "level" of the
query.</p>
</div>
<div class="paragraph">
<p>An important thing to notice is that <code>load!</code> can be thought of as a function that loads normalized data into the
root node of your graph (<code>:all-friends</code> in this scenario would appear in your root node).</p>
</div>
<div class="paragraph">
<p>This is sometimes what you want, but often you really want that data loaded at some <strong>other</strong> spot in your graph.</p>
</div>
<div class="sect3">
<h4 id="_basic_targeting"><a class="anchor" href="#_basic_targeting"></a><a class="link" href="#_basic_targeting">10.2.1. Basic Targeting</a></h4>
<div class="paragraph">
<p>When you want the data from load to appear at some other edge in your database you can simply tell load the
<strong>normalized</strong> path (which is rarely more than 3 elements) to the location you&#8217;d like to place the result.
For example, if you had list components with IDs, then this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">  (df/load! comp-or-app <span class="symbol">:all-friends</span> Person {<span class="symbol">:target</span> [<span class="symbol">:list/id</span> <span class="symbol">:people</span> <span class="symbol">:list/people</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>might load two people (with IDs 1 and 2) and would result in your database containing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/id</span> {<span class="integer">1</span> {<span class="keyword">..</span><span class="keyword">.</span>} <span class="integer">2</span> {<span class="keyword">..</span><span class="keyword">.</span>}} <span class="comment">; normalized people</span>
 <span class="symbol">:list/id</span>   {<span class="symbol">:people</span> {<span class="symbol">:list/people</span> [[<span class="symbol">:person/id</span> <span class="integer">1</span>] [<span class="symbol">:person/id</span> <span class="integer">2</span>]]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ident_based_loading"><a class="anchor" href="#_ident_based_loading"></a><a class="link" href="#_ident_based_loading">10.2.2. Ident-based Loading</a></h4>
<div class="paragraph">
<p>You can also simply load (and normalize the sub-tree) a given entity with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">  (df/load! this [<span class="symbol">:person/id</span> <span class="integer">1</span>] Person)</code></pre>
</div>
</div>
<div class="paragraph">
<p>which will simply update the entries in the tables, but won&#8217;t add any edges to the graph. You can use targeting
with these loads in order to that ident in the graph at arbitrary locations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">  (df/load! this [<span class="symbol">:person/id</span> <span class="integer">1</span>] Person {<span class="symbol">:target</span> [<span class="symbol">:current-user</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>which will result in something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/id</span> {<span class="integer">1</span> {<span class="symbol">:person/id</span> <span class="integer">1</span> <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>}}
 <span class="symbol">:current-user</span> [<span class="symbol">:person/id</span> <span class="integer">1</span>]}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_a_loading_example"><a class="anchor" href="#_a_loading_example"></a><a class="link" href="#_a_loading_example">10.2.3. A Loading Example</a></h4>
<div class="paragraph">
<p>The two general loading techniques are shown in the following example which uses our database described in
<a href="#_load_demo_database">Load Demo Database</a>. You should Focus the Inspect tool on this example&#8217;s database so you can see what
is happening (via the DB, Transaction, and Network sub-tabs).</p>
</div>
<div class="paragraph">
<p>Pressing the "Load People" button will load all of the people. Once they are loaded you can refresh any one
of them. A special resolver on the server for <code>:server/time-ms</code> allows us to timestamp the entities with the server&#8217;s
time so we can see the refresh taking effect.</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. <a id="LoadingDataBasics"></a><a href="#LoadingDataBasics">Loading Data Basics</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('loading-data-basics')">Focus Inspector</button>
<div class="short narrow example" id="loading-data-basics"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.loading-data-basics</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [book.demos.util <span class="symbol">:refer</span> [now]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]))

(defsc Person [this {<span class="symbol">:person/keys</span> [id <span class="keyword">name</span> age] <span class="symbol">:server/keys</span> [time-ms] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span> [<span class="symbol">:person/id</span> <span class="symbol">:person/name</span> <span class="symbol">:person/age</span> <span class="symbol">:server/time-ms</span>]
   <span class="symbol">:ident</span> <span class="symbol">:person/id</span>}
  (dom/li
    (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content"> (last queried at </span><span class="delimiter">&quot;</span></span> time-ms <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> []
                            <span class="comment">; Load relative to an ident (of this component).</span>
                            <span class="comment">; This will refresh the entity in the db. The helper function</span>
                            <span class="comment">; (df/refresh! this) is identical to this, but shorter to write.</span>
                            (df/load! this (comp/get-ident this) Person))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Update</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc People [this {<span class="symbol">:list/keys</span> [people]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:list/id</span> <span class="symbol">:param/id</span> <span class="symbol">:list/people</span> []}
   <span class="symbol">:query</span>         [<span class="symbol">:list/id</span> {<span class="symbol">:list/people</span> (comp/get-query Person)}]
   <span class="symbol">:ident</span>         <span class="symbol">:list/id</span>}
  (dom/ul
    (<span class="keyword">map</span> ui-person people)))

(<span class="keyword">def</span> <span class="function">ui-people</span> (comp/factory People {<span class="symbol">:keyfn</span> <span class="symbol">:people/kind</span>}))

(defsc Root [this {<span class="symbol">:root/keys</span> [<span class="keyword">list</span>]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {<span class="symbol">:root/list</span> (comp/get-initial-state People {<span class="symbol">:id</span> <span class="symbol">:people</span>})})
   <span class="symbol">:query</span>         [{<span class="symbol">:root/list</span> (comp/get-query People)}]}
  (dom/div
    (dom/button
      {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> []
                  (df/load! this <span class="symbol">:all-people</span> Person {<span class="symbol">:target</span> [<span class="symbol">:list/id</span> <span class="symbol">:people</span> <span class="symbol">:list/people</span>]}))}
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Load People</span><span class="delimiter">&quot;</span></span>)
    (dom/h4 <span class="string"><span class="delimiter">&quot;</span><span class="content">People in Database</span><span class="delimiter">&quot;</span></span>)
    (ui-people <span class="keyword">list</span>)))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_targeting_loads"><a class="anchor" href="#_targeting_loads"></a><a class="link" href="#_targeting_loads">10.2.4. Targeting Loads</a></h4>
<div class="paragraph">
<p>We covered a little bit about targeting in <a href="#_basic_targeting">Basic Targeting</a>. It turns out that the targeting system
gives you a bit more power than what we showed there. This section covers targeting in a bit more detail.</p>
</div>
<div class="sect4">
<h5 id="_simple_targeting"><a class="anchor" href="#_simple_targeting"></a><a class="link" href="#_simple_targeting">Simple Targeting</a></h5>
<div class="paragraph">
<p>The simplest targeting is to put a "root" result somewhere besides root, or to add an additional ident (edge) when
you&#8217;ve loaded something by ident:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load <span class="keyword">comp</span> <span class="symbol">:all-people</span> Person {<span class="symbol">:target</span> [<span class="symbol">:list/id</span> <span class="symbol">:people</span> <span class="symbol">:list/people</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, the server will still see the well-known query for <code>:all-friends</code>, but your local UI graph will end up seeing the
results in the list on the friends screen.</p>
</div>
<div class="paragraph">
<p>This is equivalent to the full replacement of the edge. Anything that existed at the target path will be overridden
by an ident (to-one) or a vector of idents (to-many). Remember that the cardinality is determined based on the
actual result (not some kind of client-side schema).</p>
</div>
</div>
<div class="sect4">
<h5 id="_advanced_targets"><a class="anchor" href="#_advanced_targets"></a><a class="link" href="#_advanced_targets">Advanced Targets</a></h5>
<div class="paragraph">
<p>You can also ask the target parameter to <strong>modify</strong> to-many edges instead of replacing them. For example, say you
were loading one new person, and wanted to append it to the current list:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load <span class="keyword">comp</span> [<span class="symbol">:person/id</span> <span class="integer">42</span>] Person {<span class="symbol">:target</span> (targeting/append-to [<span class="symbol">:list/id</span> <span class="symbol">:people</span> <span class="symbol">:list/people</span>])})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>append-to</code> function augments the target to indicate that the incoming items
(which will be normalized) should have their idents appended onto the to-many edge found at the given location.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>append-to</code> will not create duplicates in the list of idents.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There is also <code>prepend-to</code>.</p>
</div>
<div class="paragraph">
<p>You may also ask the targeting system to place the result(s) at more than one place in your graph. You do this
with the <code>multiple-targets</code> wrapper:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load <span class="keyword">comp</span> <span class="symbol">:best-friend</span> Person {<span class="symbol">:target</span> (targeting/multiple-targets
                                              (targeting/append-to [<span class="symbol">:screens/by-type</span> <span class="symbol">:friends</span> <span class="symbol">:friends/list</span>])})
                                              [<span class="symbol">:other-spot</span>]
                                              (targeting/prepend-to [<span class="symbol">:screens/by-type</span> <span class="symbol">:summary</span> <span class="symbol">:friends</span>]))})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>multiple-targets</code> can use plain target vectors (replacement) or any of the special wrappers.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="LoadOptions"><a class="anchor" href="#LoadOptions"></a><a class="link" href="#LoadOptions">10.2.5. Other Load Options</a></h4>
<div class="paragraph">
<p>Loads allow a number of additional arguments. Many of these are discussed in more detail in later sections:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>:post-mutation</code> and <code>:post-mutation-params</code>
</td>
<td class="hdlist2">
<p>A mutation to run once the load is complete, and the parameters to pass to it.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:remote</code>
</td>
<td class="hdlist2">
<p>The name of the remote you want to load from.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:parallel</code>
</td>
<td class="hdlist2">
<p>Boolean. Defaults to false. When true, bypasses the sequential network queue. Allows multiple loads to run at once, but causes you to lose any guarantees about ordering since the server might complete them out-of-order.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:fallback</code>
</td>
<td class="hdlist2">
<p>A mutation to run if your configured <code>remote-error?</code> returns true on the network result.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:focus</code>
</td>
<td class="hdlist2">
<p>A subquery to filter from your component query. Covered in Incremental Loading.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:without</code>
</td>
<td class="hdlist2">
<p>A set of keywords to elide from the query. Covered in Incremental Loading.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:update-query</code>
</td>
<td class="hdlist2">
<p>A function that will take the component original query and should return a query that will be sent to the remote</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:params</code>
</td>
<td class="hdlist2">
<p>A map. If supplied the params will appear as the params of the query on the server.</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See the docstring of the <code>load!</code> function for more.</p>
</div>
<div class="sect4">
<h5 id="_parallel_vs_sequential_loading"><a class="anchor" href="#_parallel_vs_sequential_loading"></a><a class="link" href="#_parallel_vs_sequential_loading">Parallel vs. Sequential Loading</a></h5>
<div class="paragraph">
<p>The <code>:parallel</code> option of <code>load</code> bypasses the normal network sequential queue. Below is a simple live
example that shows off the difference between regular loads and those marked parallel. In
order to see the effect increase your server latency to a large value.</p>
</div>
<div class="paragraph">
<p>Normally, Fulcro runs separate event-based loads in sequence, ensuring that your reasoning can be synchronous;
however, for loads that might take some time to complete, and for which you can guarantee order of
completion doesn&#8217;t matter, you can specify an option on load (<code>:parallel true</code>) that allows them to proceed in parallel.</p>
</div>
<div class="paragraph">
<p>Pressing the sequential buttons on all three (in any order) will take
at least 3x your server latency to complete from the time you click the first one (since each will run after the other is complete).
If you rapidly click the parallel buttons, then the loads will not be sequenced and you will see them all complete in roughly
1x your server latency (from the time you click the last one).</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. <a id="Parallelvs.SequentialLoading"></a><a href="#Parallelvs.SequentialLoading">Parallel vs. Sequential Loading</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('parallel-vs-sequential-loading')">Focus Inspector</button>
<div class="short narrow example" id="parallel-vs-sequential-loading"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.parallel-vs-sequential-loading</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [taoensso.timbre <span class="symbol">:as</span> log]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(pc/defresolver long-query-resolver [_ _]
  {<span class="symbol">::pc/output</span> [<span class="symbol">:background/long-query</span>]}
  {<span class="symbol">:background/long-query</span> <span class="integer">42</span>})

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
(defsc Child [this {<span class="symbol">:keys</span> [id <span class="keyword">name</span> background/long-query] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span> (<span class="keyword">fn</span> [] [<span class="symbol">:id</span> <span class="symbol">:name</span> <span class="symbol">:background/long-query</span> [df/marker-table '_]])
   <span class="symbol">:ident</span> [<span class="symbol">:background.child/by-id</span> <span class="symbol">:id</span>]}
  (<span class="keyword">let</span> [status (<span class="keyword">get-in</span> props [df/marker-table [<span class="symbol">:fetching</span> id]])]
    (dom/div {<span class="symbol">:style</span> {<span class="symbol">:display</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">inline</span><span class="delimiter">&quot;</span></span> <span class="symbol">:float</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">left</span><span class="delimiter">&quot;</span></span> <span class="symbol">:width</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">200px</span><span class="delimiter">&quot;</span></span>}}
      (dom/button {<span class="symbol">:onClick</span> #(df/load-field! this <span class="symbol">:background/long-query</span> {<span class="symbol">:parallel</span> <span class="predefined-constant">true</span>
                                                                          <span class="symbol">:marker</span>   [<span class="symbol">:fetching</span> id]})} <span class="string"><span class="delimiter">&quot;</span><span class="content">Load stuff parallel</span><span class="delimiter">&quot;</span></span>)
      (dom/button {<span class="symbol">:onClick</span> #(df/load-field! this <span class="symbol">:background/long-query</span> {<span class="symbol">:marker</span> [<span class="symbol">:fetching</span> id]})} <span class="string"><span class="delimiter">&quot;</span><span class="content">Load stuff sequential</span><span class="delimiter">&quot;</span></span>)
      (dom/div
        <span class="keyword">name</span>
        (<span class="keyword">if</span> (df/loading? status)
          (dom/span <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>)
          (dom/span long-query))))))

(<span class="keyword">def</span> <span class="function">ui-child</span> (comp/factory Child {<span class="symbol">:keyfn</span> <span class="symbol">:id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [children] <span class="symbol">:as</span> props}]
  <span class="comment">; cheating a little...raw props used for child, instead of embedding them there.</span>
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:children</span> [{<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>} {<span class="symbol">:id</span> <span class="integer">2</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>} {<span class="symbol">:id</span> <span class="integer">3</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span>}]})
   <span class="symbol">:query</span>         [{<span class="symbol">:children</span> (comp/get-query Child)}]}
  (dom/div
    (mapv ui-child children)
    (dom/br {<span class="symbol">:style</span> {<span class="symbol">:clear</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">both</span><span class="delimiter">&quot;</span></span>}}) (dom/br)))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tracking_specific_loads"><a class="anchor" href="#_tracking_specific_loads"></a><a class="link" href="#_tracking_specific_loads">10.3. Tracking Specific Loads</a></h3>
<div class="paragraph">
<p>It is very often the case that you might have a number of loads running to populate different
parts of your UI all at once. In this case it is quite useful to have some kind of load-specific marker that you
can use to show that activity. Fulcro provides a pre-built facility in the load API that can put markers into
a normalized table, allowing you to query for them in the components that need to show the activity of interest.</p>
</div>
<div class="paragraph">
<p>Load markers are normalized into a well-known table via an ID that you choose.
You can use just about any value (except a boolean) for the id. This has the following behavior:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Load markers are placed the top-level table (the var <code>com.fulcrologic.fulcro.data-fetch/marker-table</code> holds the table name),
using your marker value as their ID.</p>
</li>
<li>
<p>You can explicitly query for them using an ident-based join.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_working_with_normalized_load_markers"><a class="anchor" href="#_working_with_normalized_load_markers"></a><a class="link" href="#_working_with_normalized_load_markers">10.3.1. Working with Normalized Load Markers</a></h4>
<div class="paragraph">
<p>The steps are rather simple: Include the <code>:marker</code> parameter with load, and add a query for the load marker
on a UI component.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc SomeComponent [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:data</span> <span class="symbol">:prop2</span> <span class="symbol">:other</span> [df/marker-table <span class="symbol">:marker-id</span>]]} <span class="comment">; an ident in queries pulls in an entire entity</span>
  <span class="comment">;; important: `get`, NOT `get-in`.</span>
  (<span class="keyword">let</span> [marker (<span class="keyword">get</span> props [df/marker-table <span class="symbol">:marker-id</span>])]
    <span class="keyword">..</span><span class="keyword">.</span>)))

<span class="keyword">..</span><span class="keyword">.</span>

(df/load this <span class="symbol">:key</span> Item {<span class="symbol">:marker</span> <span class="symbol">:marker-id</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The data fetch load marker will be missing if no loading is in progress. You can use the following functions
to detect what state the load is in:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(df/loading? marker)</code> - Returns true if the item is still in progress (of any kind)</p>
</li>
<li>
<p><code>(df/failed? marker)</code> - Returns true if the item failed, according to your definition of an error.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The marker will disappear from the table when network activity completes successfully, but will remain in place
on failures.</p>
</div>
<div class="paragraph">
<p>The rendering is up to you, but that is really all there is to it.</p>
</div>
<div class="sect4">
<h5 id="_notes_on_marker_ids"><a class="anchor" href="#_notes_on_marker_ids"></a><a class="link" href="#_notes_on_marker_ids">Notes on Marker IDs</a></h5>
<div class="paragraph">
<p>Marker IDs can be any value that supports equivalence, including data structures. You can also pull the entire
load marker table into a component with a link query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Component [_ props]
  {<span class="symbol">:query</span> [<span class="keyword">..</span><span class="keyword">.</span> [df/marker-table '_] <span class="keyword">..</span><span class="keyword">.</span>]}
  (<span class="keyword">let</span> [table (<span class="keyword">get</span> props df/marker-table)
        marker (<span class="keyword">get</span> table id-of-marker)]
    <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Beware, though, that querying for the entire marker table will tend to "over render" the given component (every time any
load marker changes).</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_initializing_loaded_items"><a class="anchor" href="#_initializing_loaded_items"></a><a class="link" href="#_initializing_loaded_items">10.4. Initializing Loaded Items</a></h3>
<div class="paragraph">
<p>There are two main ways to augment the items you load. One is using post-mutations, and the
other is <a href="#PreMerge">Pre-merge</a>.</p>
</div>
<div class="sect3">
<h4 id="_post_mutations_morphing_loaded_data"><a class="anchor" href="#_post_mutations_morphing_loaded_data"></a><a class="link" href="#_post_mutations_morphing_loaded_data">10.4.1. Post Mutations – Morphing Loaded Data</a></h4>
<div class="paragraph">
<p>The targeting system that we discussed in the prior section is great for cases where your data-driven query gets you
exactly what you need for the UI. In fact, since you can process the query on the server it is entirely possible that
load with targeting is all you&#8217;ll ever need; however, from a practical perspective it may turn out that you&#8217;ve got a
server that can easily understand certain shapes of data-driven queries, but not others.</p>
</div>
<div class="paragraph">
<p>For example, say you were pulling a list of items from a database. It might be trivial to pull that graph of data
from the server from the perspective of a list of items, but let&#8217;s say that each item had a category. Perhaps you&#8217;d like to
group the items by category in the UI.</p>
</div>
<div class="paragraph">
<p>The data-driven way to handle that is to make the server understand the UI query that has them grouped by category; however,
that may not be possible if you&#8217;re using something less powerful than Pathom.</p>
</div>
<div class="paragraph">
<p>Another way of handling this is to let the client morph the incoming data into a shape that makes more sense to the
UI.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/server-interactions.png" alt="server interactions" width="350" height="378">
</div>
</div>
<div class="paragraph">
<p>We all understand doing these kinds of transforms. It&#8217;s just data manipulation. So, you may find this has some
distinct advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple query to the server (only have to write one query handler) that is a natural fit for the database there.</p>
</li>
<li>
<p>Simple layout in resulting UI database (normalized into tables and a graph)</p>
</li>
<li>
<p>Straightforward data transform into what we want to show</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_using_defsc_for_server_queries"><a class="anchor" href="#_using_defsc_for_server_queries"></a><a class="link" href="#_using_defsc_for_server_queries">Using <code>defsc</code> For Server Queries</a></h5>
<div class="paragraph">
<p>If you are taking the approach we&#8217;ve described then you have a problem: None of your UI matches the query that we
need for the <strong>server</strong>! It turns out that
it is perfectly legal (and recommended) to use <code>defsc</code> to define a graph query (and normalization) for something like
this that doesn&#8217;t exactly exist on your UI.</p>
</div>
<div class="paragraph">
<p>Simply code your (nested) queries using <code>defsc</code>, and skip writing the body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc ItemQuery [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:item/name</span> {<span class="symbol">:item/category</span> (comp/get-query CategoryQuery)}]
   <span class="symbol">:ident</span> [<span class="symbol">:items/id</span> <span class="symbol">:db/id</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>and now you can load (and normalize) the data that the server knows how to provide, and then use a post-mutation
to re-shape it to suit your needs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load! this <span class="symbol">:all-items</span> ItemQuery {<span class="symbol">:post-mutation</span> `group-items})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_live_demo_of_post_mutations"><a class="anchor" href="#_live_demo_of_post_mutations"></a><a class="link" href="#_live_demo_of_post_mutations">Live Demo of Post Mutations</a></h5>
<div class="paragraph">
<p>The example below simulates post mutations to show how a load of simple data could be morphed into something
that the UI wants to display. In  this case we&#8217;re pretending that the load has brought in a number of items
(as a collection) and normalized it, but we&#8217;d prefer to show the items organized by category.</p>
</div>
<div class="paragraph">
<p>You should interact with it and <a href="#_install_fulcro_inspect">view the database in Inspect</a> to A/B compare the before/after state.</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. <a id="MorphingExample"></a><a href="#MorphingExample">Morphing Example</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('morphing-example')">Focus Inspector</button>
<div class="short narrow example" id="morphing-example"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.server.morphing-example</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [book.macros <span class="symbol">:refer</span> [defexample]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.algorithms.normalize <span class="symbol">:as</span> fnorm]
    [com.fulcrologic.fulcro.algorithms.merge <span class="symbol">:as</span> <span class="keyword">merge</span>]))

(defsc CategoryQuery [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:category/name</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:categories/by-id</span> <span class="symbol">:db/id</span>]})

(defsc ItemQuery [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:item/name</span> {<span class="symbol">:item/category</span> (comp/get-query CategoryQuery)}]
   <span class="symbol">:ident</span> [<span class="symbol">:items/by-id</span> <span class="symbol">:db/id</span>]})

(<span class="keyword">def</span> <span class="function">sample-server-response</span>
  {<span class="symbol">:all-items</span> [{<span class="symbol">:db/id</span> <span class="integer">5</span> <span class="symbol">:item/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">item-42</span><span class="delimiter">&quot;</span></span> <span class="symbol">:item/category</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:category/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}}
               {<span class="symbol">:db/id</span> <span class="integer">6</span> <span class="symbol">:item/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">item-92</span><span class="delimiter">&quot;</span></span> <span class="symbol">:item/category</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:category/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}}
               {<span class="symbol">:db/id</span> <span class="integer">7</span> <span class="symbol">:item/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">item-32</span><span class="delimiter">&quot;</span></span> <span class="symbol">:item/category</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:category/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}}
               {<span class="symbol">:db/id</span> <span class="integer">8</span> <span class="symbol">:item/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">item-52</span><span class="delimiter">&quot;</span></span> <span class="symbol">:item/category</span> {<span class="symbol">:db/id</span> <span class="integer">2</span> <span class="symbol">:category/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>}}]})

(<span class="keyword">def</span> <span class="function">component-query</span> [{<span class="symbol">:all-items</span> (comp/get-query ItemQuery)}])

(<span class="keyword">def</span> <span class="function">hand-written-query</span> [{<span class="symbol">:all-items</span> [<span class="symbol">:db/id</span> <span class="symbol">:item/name</span>
                                      {<span class="symbol">:item/category</span> [<span class="symbol">:db/id</span> <span class="symbol">:category/name</span>]}]}])

(defsc ToolbarItem [this {<span class="symbol">:keys</span> [item/name]}]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:item/name</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:items/by-id</span> <span class="symbol">:db/id</span>]}
  (dom/li <span class="keyword">name</span>))

(<span class="keyword">def</span> <span class="function">ui-toolbar-item</span> (comp/factory ToolbarItem {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc ToolbarCategory [this {<span class="symbol">:keys</span> [category/name category/items]}]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:category/name</span> {<span class="symbol">:category/items</span> (comp/get-query ToolbarItem)}]
   <span class="symbol">:ident</span> [<span class="symbol">:categories/by-id</span> <span class="symbol">:db/id</span>]}
  (dom/li
    <span class="keyword">name</span>
    (dom/ul
      (<span class="keyword">map</span> ui-toolbar-item items))))

(<span class="keyword">def</span> <span class="function">ui-toolbar-category</span> (comp/factory ToolbarCategory {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defmutation group-items-reset [params]
  (action [{<span class="symbol">:keys</span> [app state]}]
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                   (<span class="keyword">-&gt;</span> s
                     (<span class="keyword">dissoc</span> <span class="symbol">:categories/by-id</span> <span class="symbol">:toolbar/categories</span>)
                     (merge/merge* component-query sample-server-response))))))

(<span class="keyword">defn</span> <span class="function">add-to-category</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Returns a new db with the given item added into that item's category.</span><span class="delimiter">&quot;</span></span>
  [db item]
  (<span class="keyword">let</span> [category-ident (<span class="symbol">:item/category</span> item)
        item-location  (<span class="keyword">conj</span> category-ident <span class="symbol">:category/items</span>)]
    (<span class="keyword">update-in</span> db item-location (fnil <span class="keyword">conj</span> []) (comp/ident ItemQuery item))))

(<span class="keyword">defn</span> <span class="function">group-items*</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Returns a new db with all of the items sorted by name and grouped into their categories.</span><span class="delimiter">&quot;</span></span>
  [db]
  (<span class="keyword">let</span> [sorted-items   (<span class="keyword">-&gt;&gt;</span> db <span class="symbol">:items/by-id</span> <span class="keyword">vals</span> (<span class="keyword">sort-by</span> <span class="symbol">:item/name</span>))
        category-ids   (<span class="keyword">-&gt;</span> db (<span class="symbol">:categories/by-id</span>) <span class="keyword">keys</span>)
        clear-items    (<span class="keyword">fn</span> [db id] (<span class="keyword">assoc-in</span> db [<span class="symbol">:categories/by-id</span> id <span class="symbol">:category/items</span>] []))
        db             (<span class="keyword">reduce</span> clear-items db category-ids)
        db             (<span class="keyword">reduce</span> add-to-category db sorted-items)
        all-categories (<span class="keyword">-&gt;&gt;</span> db <span class="symbol">:categories/by-id</span> <span class="keyword">vals</span> (mapv #(comp/ident CategoryQuery %)))]
    (<span class="keyword">assoc</span> db <span class="symbol">:toolbar/categories</span> all-categories)))

(defmutation ^<span class="symbol">:intern</span> group-items [params]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state group-items*)))

(defsc Toolbar [this {<span class="symbol">:keys</span> [toolbar/categories]}]
  {<span class="symbol">:query</span> [{<span class="symbol">:toolbar/categories</span> (comp/get-query ToolbarCategory)}]}
  (dom/div
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(group-items {})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Trigger Post Mutation</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(group-items-reset {})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Reset</span><span class="delimiter">&quot;</span></span>)
    (dom/ul
      (<span class="keyword">map</span> ui-toolbar-category categories))))

(defexample <span class="string"><span class="delimiter">&quot;</span><span class="content">Morphing Data</span><span class="delimiter">&quot;</span></span> Toolbar <span class="string"><span class="delimiter">&quot;</span><span class="content">morphing-example</span><span class="delimiter">&quot;</span></span> <span class="symbol">:initial-db</span> (fnorm/tree-&gt;db component-query sample-server-response <span class="predefined-constant">true</span>))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="PreMerge"><a class="anchor" href="#PreMerge"></a><a class="link" href="#PreMerge">10.5. Pre-Merge</a></h3>
<div class="paragraph">
<p>Pre merge offers hook to manipulate data entering your Fulcro app at component level.</p>
</div>
<div class="paragraph">
<p>During the lifetime of a Fulcro application data will enter the system:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>During app initialization</p>
</li>
<li>
<p>When loaded from a remote</p>
</li>
<li>
<p>By being added via mutations</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the first case the data comes from the component initial state or user-provided initial state. Such pre-supplied
data usually includes both domain and ui-centric data.</p>
</div>
<div class="paragraph">
<p>In the second case the data comes from a remote and contains <strong>only</strong> domain data, however,
the UI might still need to do some type of initialization to add ui-centric props for this in the local database.</p>
</div>
<div class="paragraph">
<p>Post-mutations are a little limiting in this case because they are not component-centric: they are not co-located
with the components, and may have to deal with an entire sub-tree all at once.
Pre hooks decomposes this logic to the component level making things a bit simpler in many cases.</p>
</div>
<div class="paragraph">
<p>To illustrate these issues we are going to write a small app that has some countdown buttons, the idea
is that each counter will go down each time it is clicked until it reaches zero. The important detail will be how we
can handle the initial counter value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label]
                        <span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">:ui/count</span>]}
  (dom/div
    (dom/h4 counter-label)
    (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
      (dom/button {<span class="symbol">:disabled</span> done?
                   <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
        (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:ui/count</code> is a ui-only concern that must start with some value. We will arbitrarily
choose <code>5</code> as a start. Whatever it is we need to initialize it when a new instance of a <code>Countdown</code>
enters the system.</p>
</div>
<div class="paragraph">
<p>First, we&#8217;ll use this post-mutation to initialize this ui property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(m/defmutation initialize-counter [{<span class="symbol">::keys</span> [counter-id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state <span class="keyword">update-in</span> [<span class="symbol">::counter-id</span> counter-id] #(<span class="keyword">merge</span> {<span class="symbol">:ui/count</span> <span class="integer">5</span>} %))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>And use it via this call to load:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load this [<span class="symbol">::counter-id</span> <span class="integer">1</span>] Countdown
  {<span class="symbol">:target</span>               [<span class="symbol">:counter</span>]
   <span class="symbol">:post-mutation</span>        `initialize-counter
   <span class="symbol">:post-mutation-params</span> {<span class="symbol">::counter-id</span> <span class="integer">1</span>}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a running demo:</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. <a id="Premerge-usingpostmutations"></a><a href="#Premerge-usingpostmutations">Pre merge - using post mutations</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('pre-merge-postmutations')">Focus Inspector</button>
<div class="short narrow example" id="pre-merge-postmutations"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.pre-merge.post-mutation-countdown</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [book.demos.util <span class="symbol">:refer</span> [now]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">all-counters</span>
  [{<span class="symbol">::counter-id</span> <span class="integer">1</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}])

(pc/defresolver counter-resolver [env {<span class="symbol">::keys</span> [counter-id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">::counter-id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span>]}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [id]} (<span class="keyword">-&gt;</span> env <span class="symbol">:ast</span> <span class="symbol">:params</span>)]
    (<span class="keyword">first</span> (<span class="keyword">filter</span> #(<span class="keyword">=</span> id (<span class="symbol">::counter-id</span> %)) all-counters))))

(<span class="keyword">def</span> <span class="function">resolvers</span> [counter-resolver])

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(m/defmutation initialize-counter [{<span class="symbol">::keys</span> [counter-id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state <span class="keyword">update-in</span> [<span class="symbol">::counter-id</span> counter-id] #(<span class="keyword">merge</span> {<span class="symbol">:ui/count</span> <span class="integer">5</span>} %))))

(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label]
                        <span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">:ui/count</span>]}
  (dom/div
    (dom/h4 counter-label)
    (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
      (dom/button {<span class="symbol">:disabled</span> done?
                   <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
        (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>))))))

(<span class="keyword">def</span> <span class="function">ui-countdown</span> (comp/factory Countdown {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [counter]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {})
   <span class="symbol">:query</span>         [{<span class="symbol">:counter</span> (comp/get-query Countdown)}]}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">if</span> (<span class="keyword">seq</span> counter)
      (ui-countdown counter)
      (dom/button {<span class="symbol">:onClick</span> #(df/load! this [<span class="symbol">::counter-id</span> <span class="integer">1</span>] Countdown
                               {<span class="symbol">:target</span>               [<span class="symbol">:counter</span>]
                                <span class="symbol">:post-mutation</span>        `initialize-counter
                                <span class="symbol">:post-mutation-params</span> {<span class="symbol">::counter-id</span> <span class="integer">1</span>}})}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Load one counter</span><span class="delimiter">&quot;</span></span>))))

(<span class="keyword">defn</span> <span class="function">initialize</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">To be used in :started-callback to pre-load things.</span><span class="delimiter">&quot;</span></span>
  [app])</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s see in case of a to-many, this is what our new mutation looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(m/defmutation initialize-counters [_]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state
      (<span class="keyword">fn</span> [state]
        (<span class="keyword">reduce</span>
          (<span class="keyword">fn</span> [state <span class="keyword">ref</span>]
            (<span class="keyword">update-in</span> state <span class="keyword">ref</span> #(<span class="keyword">merge</span> {<span class="symbol">:ui/count</span> <span class="integer">5</span>} %)))
          state
          (<span class="keyword">get</span> state <span class="symbol">::all-counters</span>))))))</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 24. <a id="Premerge-usingpostmutationstomany"></a><a href="#Premerge-usingpostmutationstomany">Pre merge - using post mutations to many</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('pre-merge-postmutations-many')">Focus Inspector</button>
<div class="short narrow example" id="pre-merge-postmutations-many"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.pre-merge.post-mutation-countdown-many</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [book.demos.util <span class="symbol">:refer</span> [now]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">all-counters</span>
  [{<span class="symbol">::counter-id</span> <span class="integer">1</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">::counter-id</span> <span class="integer">2</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">::counter-id</span> <span class="integer">3</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">::counter-id</span> <span class="integer">4</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">D</span><span class="delimiter">&quot;</span></span>}])

(pc/defresolver counter-resolver [env _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">::all-counters</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span>]}]}
  {<span class="symbol">::all-counters</span> all-counters})

(<span class="keyword">def</span> <span class="function">resolvers</span> [counter-resolver])

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(m/defmutation initialize-counters [_]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state
      (<span class="keyword">fn</span> [state]
        (<span class="keyword">reduce</span>
          (<span class="keyword">fn</span> [state <span class="keyword">ref</span>]
            (<span class="keyword">update-in</span> state <span class="keyword">ref</span> #(<span class="keyword">merge</span> {<span class="symbol">:ui/count</span> <span class="integer">5</span>} %)))
          state
          (<span class="keyword">get</span> state <span class="symbol">::all-counters</span>))))))

(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label]
                        <span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">:ui/count</span>]}
  (dom/div
    (dom/h4 counter-label)
    (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
      (dom/button {<span class="symbol">:disabled</span> done?
                   <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
        (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>))))))

(<span class="keyword">def</span> <span class="function">ui-countdown</span> (comp/factory Countdown {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Root [this {<span class="symbol">::keys</span> [all-counters]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {})
   <span class="symbol">:query</span>         [{<span class="symbol">::all-counters</span> (comp/get-query Countdown)}]}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">if</span> (<span class="keyword">seq</span> all-counters)
      (dom/div {<span class="symbol">:style</span> {<span class="symbol">:display</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">flex</span><span class="delimiter">&quot;</span></span> <span class="symbol">:alignItems</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">center</span><span class="delimiter">&quot;</span></span> <span class="symbol">:justifyContent</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">space-between</span><span class="delimiter">&quot;</span></span>}}
        (mapv ui-countdown all-counters))
      (dom/button {<span class="symbol">:onClick</span> #(df/load! this <span class="symbol">::all-counters</span> Countdown
                               {<span class="symbol">:post-mutation</span> `initialize-counters})}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Load many counters</span><span class="delimiter">&quot;</span></span>))))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see, adding a single depth to the query can yield a fair amount of extra code to hook things up, and as
you app grows each join depth will add more post-mutation code to compose over. Solving this composition issue
is the main motivation behind pre-merge.</p>
</div>
<div class="sect3">
<h4 id="_pre_merge_basics"><a class="anchor" href="#_pre_merge_basics"></a><a class="link" href="#_pre_merge_basics">10.5.1. Pre-merge Basics</a></h4>
<div class="paragraph">
<p>Pre merge addresses these issues by providing a component level hook that allows the additional merge logic
to be localized to the component of interest.</p>
</div>
<div class="paragraph">
<p>This is how we would set up our <code>Countdown</code> component using <code>:pre-merge</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label]
                        <span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">:ui/count</span>]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                <span class="comment">; </span><b class="conum">(1)</b>
                (<span class="keyword">merge</span>
                  {<span class="symbol">:ui/count</span> <span class="integer">5</span>} <span class="comment">; </span><b class="conum">(2)</b>
                  current-normalized <span class="comment">; </span><b class="conum">(3)</b>
                  data-tree))} <span class="comment">; </span><b class="conum">(4)</b>
  (dom/div
    (dom/h4 counter-label)
    (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
      (dom/button {<span class="symbol">:disabled</span> done?
                   <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
        (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>))))))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This merge setup works for most of the cases</p>
</li>
<li>
<p>We start the merge with a map containing defaults</p>
</li>
<li>
<p>Then we merge with the data that is already there for this component (may be <code>nil</code> if component doesn&#8217;t have previous data)</p>
</li>
<li>
<p>Finally merge in the incoming data tree, since it&#8217;s the last it will win over any of the previous</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>:pre-merge</code> lambda receives a single map containing the following keys:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:data-tree</code> - the new data tree entering the database</p>
</li>
<li>
<p><code>:current-normalized</code> - the current entity value (if any), comes normalized from the db (as in <code>(get-in state ref)</code>)</p>
</li>
<li>
<p><code>:state-map</code> - the current app state map (you may use to lookup refs).</p>
</li>
<li>
<p><code>:query</code> - the query used to do this request (user may have modified the original using <code>:focus</code>, <code>:without</code> or <code>:update-query</code> during the load call</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With this setup we can get rid of the <code>post-mutation</code>. The cleaned up examples follow.</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. <a id="Premerge"></a><a href="#Premerge">Pre merge</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('countdown-single')">Focus Inspector</button>
<div class="short narrow example" id="countdown-single"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.pre-merge.countdown</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [book.demos.util <span class="symbol">:refer</span> [now]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">all-counters</span>
  [{<span class="symbol">::counter-id</span> <span class="integer">1</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}])

(pc/defresolver counter-resolver [env {<span class="symbol">::keys</span> [counter-id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">::counter-id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span>]}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [id]} (<span class="keyword">-&gt;</span> env <span class="symbol">:ast</span> <span class="symbol">:params</span>)]
    (<span class="keyword">first</span> (<span class="keyword">filter</span> #(<span class="keyword">=</span> id (<span class="symbol">::counter-id</span> %)) all-counters))))

(<span class="keyword">def</span> <span class="function">resolvers</span> [counter-resolver])

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label]
                        <span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">:ui/count</span>]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">merge</span>
                  {<span class="symbol">:ui/count</span> <span class="integer">5</span>}
                  current-normalized
                  data-tree))}
  (dom/div
    (dom/h4 counter-label)
    (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
      (dom/button {<span class="symbol">:disabled</span> done?
                   <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
        (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>))))))

(<span class="keyword">def</span> <span class="function">ui-countdown</span> (comp/factory Countdown {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [counter]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {})
   <span class="symbol">:query</span>         [{<span class="symbol">:counter</span> (comp/get-query Countdown)}]}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">if</span> (<span class="keyword">seq</span> counter)
      (ui-countdown counter)
      (dom/button {<span class="symbol">:onClick</span> #(df/load! this [<span class="symbol">::counter-id</span> <span class="integer">1</span>] Countdown {<span class="symbol">:target</span> [<span class="symbol">:counter</span>]})}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Load one counter</span><span class="delimiter">&quot;</span></span>))))

(<span class="keyword">defn</span> <span class="function">initialize</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">To be used in :started-callback to pre-load things.</span><span class="delimiter">&quot;</span></span>
  [app])</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 26. <a id="Premerge-tomany"></a><a href="#Premerge-tomany">Pre merge - to many</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('countdown-many')">Focus Inspector</button>
<div class="short narrow example" id="countdown-many"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.pre-merge.countdown-many</span>
  (<span class="symbol">:require</span>
    [book.demos.util <span class="symbol">:refer</span> [now]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">all-counters</span>
  [{<span class="symbol">::counter-id</span> <span class="integer">1</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">::counter-id</span> <span class="integer">2</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">::counter-id</span> <span class="integer">3</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">::counter-id</span> <span class="integer">4</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">D</span><span class="delimiter">&quot;</span></span>}])

(pc/defresolver counter-resolver [env _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">::all-counters</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span>]}]}
  {<span class="symbol">::all-counters</span> all-counters})

(<span class="keyword">def</span> <span class="function">resolvers</span> [counter-resolver])

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label]
                        <span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">:ui/count</span>]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">merge</span>
                  {<span class="symbol">:ui/count</span> <span class="integer">5</span>}
                  current-normalized
                  data-tree))}
  (dom/div
    (dom/h4 counter-label)
    (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
      (dom/button {<span class="symbol">:disabled</span> done?
                   <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
        (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>))))))

(<span class="keyword">def</span> <span class="function">ui-countdown</span> (comp/factory Countdown {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Root [this {<span class="symbol">::keys</span> [all-counters]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {})
   <span class="symbol">:query</span>         [{<span class="symbol">::all-counters</span> (comp/get-query Countdown)}]}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">if</span> (<span class="keyword">seq</span> all-counters)
      (dom/div {<span class="symbol">:style</span> {<span class="symbol">:display</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">flex</span><span class="delimiter">&quot;</span></span> <span class="symbol">:alignItems</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">center</span><span class="delimiter">&quot;</span></span> <span class="symbol">:justifyContent</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">space-between</span><span class="delimiter">&quot;</span></span>}}
        (mapv ui-countdown all-counters))
      (dom/button {<span class="symbol">:onClick</span> #(df/load! this <span class="symbol">::all-counters</span> Countdown)}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Load many counters</span><span class="delimiter">&quot;</span></span>))))

(<span class="keyword">defn</span> <span class="function">initialize</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">To be used in :started-callback to pre-load things.</span><span class="delimiter">&quot;</span></span>
  [app])</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pre_merge_with_server_data"><a class="anchor" href="#_pre_merge_with_server_data"></a><a class="link" href="#_pre_merge_with_server_data">10.5.2. Pre-merge with Server Data</a></h4>
<div class="paragraph">
<p>To make this example more interesting let&#8217;s make it possible, but optional, for the server to define an initial
counter value.</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. <a id="Premerge-withinitial"></a><a href="#Premerge-withinitial">Pre merge - with initial</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('countdown-with-initial')">Focus Inspector</button>
<div class="short narrow example" id="countdown-with-initial"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.pre-merge.countdown-with-initial</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [book.demos.util <span class="symbol">:refer</span> [now]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [com.fulcrologic.fulcro.algorithms.merge <span class="symbol">:as</span> <span class="keyword">merge</span>]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">all-counters</span>
  [{<span class="symbol">::counter-id</span> <span class="integer">1</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">::counter-id</span> <span class="integer">2</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span> <span class="symbol">::counter-initial</span> <span class="integer">10</span>}
   {<span class="symbol">::counter-id</span> <span class="integer">3</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span> <span class="symbol">::counter-initial</span> <span class="integer">2</span>}
   {<span class="symbol">::counter-id</span> <span class="integer">4</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">D</span><span class="delimiter">&quot;</span></span>}])

(pc/defresolver counter-resolver [env _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">::all-counters</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">::counter-initial</span>]}]}
  {<span class="symbol">::all-counters</span> all-counters})

(<span class="keyword">def</span> <span class="function">resolvers</span> [counter-resolver])

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">default-count</span> <span class="integer">5</span>)

(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label counter-initial]
                        <span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">::counter-initial</span> <span class="symbol">:ui/count</span>]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">merge</span>
                  <span class="comment">; </span><b class="conum">(1)</b>
                  {<span class="symbol">:ui/count</span> (<span class="keyword">or</span> (merge/nilify-not-found (<span class="symbol">::counter-initial</span> data-tree)) default-count)}
                  current-normalized
                  data-tree))}
  (dom/div
    (dom/h4 (<span class="keyword">str</span> counter-label <span class="string"><span class="delimiter">&quot;</span><span class="content"> [</span><span class="delimiter">&quot;</span></span> (<span class="keyword">or</span> counter-initial default-count) <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>))
    (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
      (dom/button {<span class="symbol">:disabled</span> done?
                   <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
        (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>))))))

(<span class="keyword">def</span> <span class="function">ui-countdown</span> (comp/factory Countdown {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Root [this {<span class="symbol">::keys</span> [all-counters]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {})
   <span class="symbol">:query</span>         [{<span class="symbol">::all-counters</span> (comp/get-query Countdown)}]}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">if</span> (<span class="keyword">seq</span> all-counters)
      (dom/div {<span class="symbol">:style</span> {<span class="symbol">:display</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">flex</span><span class="delimiter">&quot;</span></span> <span class="symbol">:alignItems</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">center</span><span class="delimiter">&quot;</span></span> <span class="symbol">:justifyContent</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">space-between</span><span class="delimiter">&quot;</span></span>}}
        (mapv ui-countdown all-counters))
      (dom/button {<span class="symbol">:onClick</span> #(df/load! this <span class="symbol">::all-counters</span> Countdown)}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Load many counters</span><span class="delimiter">&quot;</span></span>))))</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>During the normalization step of a load Fulcro will put <code>::merge/not-found</code> value on keys
that were not delivered by the server, this is used to do a <code>sweep-merge</code> later, the <code>merge/nilify-not-found</code>
will return the same input value (like <code>identity</code>) unless it&#8217;s a <code>::merge/not-found</code>, in which case
it returns <code>nil</code>, this way the <code>or</code> works in both cases.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_pre_merge_and_ui_children"><a class="anchor" href="#_pre_merge_and_ui_children"></a><a class="link" href="#_pre_merge_and_ui_children">10.5.3. Pre-merge and UI Children</a></h4>
<div class="paragraph">
<p>Next, we are going to extract the counter button into its own component to illustrate
how you can augment pure UI concerns with this feature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc CountdownButton [this {<span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">:ui/id</span> <span class="symbol">:ui/id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">:ui/id</span> <span class="symbol">:ui/count</span>]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">merge</span>
                  <span class="comment">; </span><b class="conum">(1)</b>
                  {<span class="symbol">:ui/id</span>    (random-uuid)
                   <span class="symbol">:ui/count</span> default-count}
                  current-normalized
                  data-tree))}
  (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
    (dom/button {<span class="symbol">:disabled</span> done?
                 <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
      (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>)))))

(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label counter-initial]
                        <span class="symbol">:ui/keys</span> [counter]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">::counter-initial</span>
               {<span class="symbol">:ui/counter</span> (comp/get-query CountdownButton)}]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">let</span> [initial (comp/nilify-not-found (<span class="symbol">::counter-initial</span> data-tree))]
                  (<span class="keyword">merge</span>
                    <span class="comment">; </span><b class="conum">(2)</b>
                    {<span class="symbol">:ui/counter</span> (cond-&gt; {} initial (<span class="keyword">assoc</span> <span class="symbol">:ui/count</span> initial))}
                    current-normalized
                    data-tree)))}
  (dom/div
    (dom/h4 (<span class="keyword">str</span> counter-label <span class="string"><span class="delimiter">&quot;</span><span class="content"> [</span><span class="delimiter">&quot;</span></span> (<span class="keyword">or</span> counter-initial default-count) <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>))
    (ui-countdown-button counter)))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>For the UI element we can also set the initial id using pre-merge, and now we moved the default there</p>
</li>
<li>
<p>Note we pass a blank map to the <code>:ui/counter</code>, this will reach the pre-merge from <code>CountdownButton</code> as the <code>data-tree</code> part</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Full demo:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. <a id="Premerge-extractedui"></a><a href="#Premerge-extractedui">Pre merge - extracted ui</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('countdown-extracted')">Focus Inspector</button>
<div class="short narrow example" id="countdown-extracted"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.pre-merge.countdown-extracted</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [book.demos.util <span class="symbol">:refer</span> [now]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.algorithms.merge <span class="symbol">:as</span> <span class="keyword">merge</span>]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">all-counters</span>
  [{<span class="symbol">::counter-id</span> <span class="integer">1</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">::counter-id</span> <span class="integer">2</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span> <span class="symbol">::counter-initial</span> <span class="integer">10</span>}
   {<span class="symbol">::counter-id</span> <span class="integer">3</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span> <span class="symbol">::counter-initial</span> <span class="integer">2</span>}
   {<span class="symbol">::counter-id</span> <span class="integer">4</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">D</span><span class="delimiter">&quot;</span></span>}])

(pc/defresolver counter-resolver [env _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">::all-counters</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span>]}]}
  {<span class="symbol">::all-counters</span> all-counters})

(<span class="keyword">def</span> <span class="function">resolvers</span> [counter-resolver])

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">default-count</span> <span class="integer">5</span>)

(defsc CountdownButton [this {<span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">:ui/id</span> <span class="symbol">:ui/id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">:ui/id</span> <span class="symbol">:ui/count</span>]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">merge</span>
                  <span class="comment">; </span><b class="conum">(1)</b>
                  {<span class="symbol">:ui/id</span>    (random-uuid)
                   <span class="symbol">:ui/count</span> default-count}
                  current-normalized
                  data-tree))}
  (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
    (dom/button {<span class="symbol">:disabled</span> done?
                 <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
      (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>)))))

(<span class="keyword">def</span> <span class="function">ui-countdown-button</span> (comp/factory CountdownButton {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label counter-initial]
                        <span class="symbol">:ui/keys</span> [counter]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">::counter-initial</span>
               {<span class="symbol">:ui/counter</span> (comp/get-query CountdownButton)}]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">let</span> [initial (merge/nilify-not-found (<span class="symbol">::counter-initial</span> data-tree))]
                  (<span class="keyword">merge</span>
                    <span class="comment">; </span><b class="conum">(2)</b>
                    {<span class="symbol">:ui/counter</span> (cond-&gt; {} initial (<span class="keyword">assoc</span> <span class="symbol">:ui/count</span> initial))}
                    current-normalized
                    data-tree)))}
  (dom/div
    (dom/h4 (<span class="keyword">str</span> counter-label <span class="string"><span class="delimiter">&quot;</span><span class="content"> [</span><span class="delimiter">&quot;</span></span> (<span class="keyword">or</span> counter-initial default-count) <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>))
    (ui-countdown-button counter)))

(<span class="keyword">def</span> <span class="function">ui-countdown</span> (comp/factory Countdown {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Root [this {<span class="symbol">::keys</span> [all-counters]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {})
   <span class="symbol">:query</span>         [{<span class="symbol">::all-counters</span> (comp/get-query Countdown)}]}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">if</span> (<span class="keyword">seq</span> all-counters)
      (dom/div {<span class="symbol">:style</span> {<span class="symbol">:display</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">flex</span><span class="delimiter">&quot;</span></span> <span class="symbol">:alignItems</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">center</span><span class="delimiter">&quot;</span></span> <span class="symbol">:justifyContent</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">space-between</span><span class="delimiter">&quot;</span></span>}}
        (mapv ui-countdown all-counters))
      (dom/button {<span class="symbol">:onClick</span> #(df/load! this <span class="symbol">::all-counters</span> Countdown)}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Load many counters</span><span class="delimiter">&quot;</span></span>))))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pre_merge_during_app_initialization"><a class="anchor" href="#_pre_merge_during_app_initialization"></a><a class="link" href="#_pre_merge_during_app_initialization">10.5.4. Pre-merge During App Initialization</a></h4>
<div class="paragraph">
<p>Another interesting property about pre-merge is that it also runs during normalization
of app initialization, this means you can provide the minimum amount of data as the initial
state and let the pre-merge fill the UI needs, to illustrate let&#8217;s add some initial state to our
demo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Root [this _]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {<span class="symbol">::all-counters</span>
                           [{<span class="symbol">::counter-id</span>    (comp/tempid)
                             <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>}
                            {<span class="symbol">::counter-id</span>    (comp/tempid)
                             <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Y</span><span class="delimiter">&quot;</span></span>}
                            {<span class="symbol">::counter-id</span>      (comp/tempid)
                             <span class="symbol">::counter-label</span>   <span class="string"><span class="delimiter">&quot;</span><span class="content">Z</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">::counter-initial</span> <span class="integer">9</span>}]})
   <span class="symbol">:query</span>         [{<span class="symbol">::all-counters</span> (comp/get-query Countdown)}]}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pre merge will be applied on top of that running the pre-merge on the respective data parts. Full demo:</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. <a id="Premerge-initial"></a><a href="#Premerge-initial">Pre merge - initial</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('countdown-initial-state')">Focus Inspector</button>
<div class="short narrow example" id="countdown-initial-state"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.pre-merge.countdown-initial-state</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [book.demos.util <span class="symbol">:refer</span> [now]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [com.fulcrologic.fulcro.algorithms.merge <span class="symbol">:as</span> <span class="keyword">merge</span>]
    [com.fulcrologic.fulcro.algorithms.tempid <span class="symbol">:as</span> tempid]
    [taoensso.timbre <span class="symbol">:as</span> log]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">all-counters</span>
  [{<span class="symbol">::counter-id</span> <span class="integer">1</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">::counter-id</span> <span class="integer">2</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span> <span class="symbol">::counter-initial</span> <span class="integer">10</span>}
   {<span class="symbol">::counter-id</span> <span class="integer">3</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span> <span class="symbol">::counter-initial</span> <span class="integer">2</span>}
   {<span class="symbol">::counter-id</span> <span class="integer">4</span> <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">D</span><span class="delimiter">&quot;</span></span>}])

(pc/defresolver counter-resolver [env _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">::all-counters</span> [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span>]}]}
  {<span class="symbol">::all-counters</span> all-counters})

(<span class="keyword">def</span> <span class="function">resolvers</span> [counter-resolver])

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">default-count</span> <span class="integer">5</span>)

(defsc CountdownButton [this {<span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">:ui/id</span> <span class="symbol">:ui/id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">:ui/id</span> <span class="symbol">:ui/count</span>]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">merge</span>
                  {<span class="symbol">:ui/id</span>    (random-uuid)
                   <span class="symbol">:ui/count</span> default-count}
                  current-normalized
                  data-tree))}
  (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
    (dom/button {<span class="symbol">:disabled</span> done?
                 <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
      (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>)))))

(<span class="keyword">def</span> <span class="function">ui-countdown-button</span> (comp/factory CountdownButton {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label counter-initial]
                        <span class="symbol">:ui/keys</span> [counter]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">::counter-initial</span>
               {<span class="symbol">:ui/counter</span> (comp/get-query CountdownButton)}]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">let</span> [initial (merge/nilify-not-found (<span class="symbol">::counter-initial</span> data-tree))]
                  (log/spy <span class="symbol">:info</span> (<span class="keyword">merge</span>
                                   {<span class="symbol">:ui/counter</span> (cond-&gt; {} initial (<span class="keyword">assoc</span> <span class="symbol">:ui/count</span> initial))}
                                   current-normalized
                                   data-tree))))}
  (dom/div
    (dom/h4 (<span class="keyword">str</span> counter-label <span class="string"><span class="delimiter">&quot;</span><span class="content"> [</span><span class="delimiter">&quot;</span></span> (<span class="keyword">or</span> counter-initial default-count) <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>))
    (ui-countdown-button counter)))

(<span class="keyword">def</span> <span class="function">ui-countdown</span> (comp/factory Countdown {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Root [this {<span class="symbol">::keys</span> [all-counters]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {<span class="symbol">::all-counters</span>
                           [{<span class="symbol">::counter-id</span>    (tempid/tempid)
                             <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>}
                            {<span class="symbol">::counter-id</span>    (tempid/tempid)
                             <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Y</span><span class="delimiter">&quot;</span></span>}
                            {<span class="symbol">::counter-id</span>      (tempid/tempid)
                             <span class="symbol">::counter-label</span>   <span class="string"><span class="delimiter">&quot;</span><span class="content">Z</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">::counter-initial</span> <span class="integer">9</span>}]})
   <span class="symbol">:query</span>         [{<span class="symbol">::all-counters</span> (comp/get-query Countdown)}]}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">when</span> (<span class="keyword">seq</span> all-counters)
      (dom/div {<span class="symbol">:style</span> {<span class="symbol">:display</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">flex</span><span class="delimiter">&quot;</span></span> <span class="symbol">:alignItems</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">center</span><span class="delimiter">&quot;</span></span> <span class="symbol">:justifyContent</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">space-between</span><span class="delimiter">&quot;</span></span>}}
        (mapv ui-countdown all-counters)))))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pre_merge_via_mutations"><a class="anchor" href="#_pre_merge_via_mutations"></a><a class="link" href="#_pre_merge_via_mutations">10.5.5. Pre-merge via Mutations</a></h4>
<div class="paragraph">
<p>We&#8217;ve already talked about ways to integrate new data using things like <code>comp/merge-component</code>, and since pre-merge
takes effect there as well we can rely on it in mutations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(m/defmutation create-countdown [countdown]
  (action [{<span class="symbol">:keys</span> [state <span class="keyword">ref</span>]}]
    (<span class="keyword">swap!</span> state comp/merge-component Countdown countdown <span class="symbol">:append</span> [<span class="symbol">::all-counters</span>])
    (<span class="keyword">swap!</span> state <span class="keyword">update-in</span> <span class="keyword">ref</span> <span class="keyword">assoc</span> <span class="symbol">:ui/new-countdown-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>And add some UI to trigger this mutation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Root [this {<span class="symbol">::keys</span> [all-counters]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {<span class="symbol">::all-counters</span>
                           [{<span class="symbol">::counter-id</span>    (comp/tempid)
                             <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>}
                            {<span class="symbol">::counter-id</span>    (comp/tempid)
                             <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Y</span><span class="delimiter">&quot;</span></span>}
                            {<span class="symbol">::counter-id</span>      (comp/tempid)
                             <span class="symbol">::counter-label</span>   <span class="string"><span class="delimiter">&quot;</span><span class="content">Z</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">::counter-initial</span> <span class="integer">9</span>}]})
   <span class="symbol">:query</span>         [{<span class="symbol">::all-counters</span> (comp/get-query Countdown)}
                   <span class="symbol">:ui/new-countdown-label</span>]}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this [`(create-countdown ~{<span class="symbol">::counter-id</span>    (comp/tempid)
                                                                      <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">New</span><span class="delimiter">&quot;</span></span>})])}
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Add counter</span><span class="delimiter">&quot;</span></span>)
    (dom/div {<span class="symbol">:style</span> {<span class="symbol">:display</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">flex</span><span class="delimiter">&quot;</span></span> <span class="symbol">:alignItems</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">center</span><span class="delimiter">&quot;</span></span> <span class="symbol">:justifyContent</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">space-between</span><span class="delimiter">&quot;</span></span>}}
      (mapv ui-countdown all-counters))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Full demo:</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. <a id="Premerge-mutation"></a><a href="#Premerge-mutation">Pre merge - mutation</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('countdown-mutation')">Focus Inspector</button>
<div class="short narrow example" id="countdown-mutation"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.pre-merge.countdown-mutation</span>
  (<span class="symbol">:require</span>
    [book.demos.util <span class="symbol">:refer</span> [now]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.algorithms.merge <span class="symbol">:as</span> <span class="keyword">merge</span>]
    [com.fulcrologic.fulcro.algorithms.tempid <span class="symbol">:as</span> tempid]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">default-count</span> <span class="integer">5</span>)

(defsc CountdownButton [this {<span class="symbol">:ui/keys</span> [<span class="keyword">count</span>]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">:ui/id</span> <span class="symbol">:ui/id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">:ui/id</span> <span class="symbol">:ui/count</span>]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree]}]
                (<span class="keyword">merge</span>
                  {<span class="symbol">:ui/id</span>    (random-uuid)
                   <span class="symbol">:ui/count</span> default-count}
                  current-normalized
                  data-tree))}
  (<span class="keyword">let</span> [done? (<span class="keyword">zero?</span> <span class="keyword">count</span>)]
    (dom/button {<span class="symbol">:disabled</span> done?
                 <span class="symbol">:onClick</span>  #(m/set-value! this <span class="symbol">:ui/count</span> (<span class="keyword">dec</span> <span class="keyword">count</span>))}
      (<span class="keyword">if</span> done? <span class="string"><span class="delimiter">&quot;</span><span class="content">Done!</span><span class="delimiter">&quot;</span></span> (<span class="keyword">str</span> <span class="keyword">count</span>)))))

(<span class="keyword">def</span> <span class="function">ui-countdown-button</span> (comp/factory CountdownButton {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(defsc Countdown [this {<span class="symbol">::keys</span>   [counter-label counter-initial]
                        <span class="symbol">:ui/keys</span> [counter]}]
  {<span class="symbol">:ident</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-id</span>]
   <span class="symbol">:query</span>     [<span class="symbol">::counter-id</span> <span class="symbol">::counter-label</span> <span class="symbol">::counter-initial</span>
               {<span class="symbol">:ui/counter</span> (comp/get-query CountdownButton)}]
   <span class="symbol">:pre-merge</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [current-normalized data-tree] <span class="symbol">:as</span> x}]
                (<span class="keyword">let</span> [initial (merge/nilify-not-found (<span class="symbol">::counter-initial</span> data-tree))]
                  (<span class="keyword">merge</span>
                    {<span class="symbol">:ui/counter</span> (cond-&gt; {} initial (<span class="keyword">assoc</span> <span class="symbol">:ui/count</span> initial))}
                    current-normalized
                    data-tree)))}
  (dom/div
    (dom/h4 (<span class="keyword">str</span> counter-label <span class="string"><span class="delimiter">&quot;</span><span class="content"> [</span><span class="delimiter">&quot;</span></span> (<span class="keyword">or</span> counter-initial default-count) <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>))
    (ui-countdown-button counter)))

(<span class="keyword">def</span> <span class="function">ui-countdown</span> (comp/factory Countdown {<span class="symbol">:keyfn</span> <span class="symbol">::counter-id</span>}))

(m/defmutation create-countdown [countdown]
  (action [{<span class="symbol">:keys</span> [state <span class="keyword">ref</span>]}]
    (<span class="keyword">swap!</span> state merge/merge-component Countdown countdown <span class="symbol">:append</span> [<span class="symbol">::all-counters</span>])
    (<span class="keyword">swap!</span> state <span class="keyword">update-in</span> <span class="keyword">ref</span> <span class="keyword">assoc</span> <span class="symbol">:ui/new-countdown-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)))

(defsc Root [this {<span class="symbol">::keys</span> [all-counters]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {<span class="symbol">::all-counters</span>
                           [{<span class="symbol">::counter-id</span>    (tempid/tempid)
                             <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>}
                            {<span class="symbol">::counter-id</span>    (tempid/tempid)
                             <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Y</span><span class="delimiter">&quot;</span></span>}
                            {<span class="symbol">::counter-id</span>      (tempid/tempid)
                             <span class="symbol">::counter-label</span>   <span class="string"><span class="delimiter">&quot;</span><span class="content">Z</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">::counter-initial</span> <span class="integer">9</span>}]})
   <span class="symbol">:query</span>         [{<span class="symbol">::all-counters</span> (comp/get-query Countdown)}
                   <span class="symbol">:ui/new-countdown-label</span>]}
  (dom/div
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Counters</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this [`(create-countdown ~{<span class="symbol">::counter-id</span>    (tempid/tempid)
                                                                      <span class="symbol">::counter-label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">New</span><span class="delimiter">&quot;</span></span>})])}
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Add counter</span><span class="delimiter">&quot;</span></span>)
    (dom/div {<span class="symbol">:style</span> {<span class="symbol">:display</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">flex</span><span class="delimiter">&quot;</span></span> <span class="symbol">:alignItems</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">center</span><span class="delimiter">&quot;</span></span> <span class="symbol">:justifyContent</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">space-between</span><span class="delimiter">&quot;</span></span>}}
      (mapv ui-countdown all-counters))))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="IncrementalLoading"><a class="anchor" href="#IncrementalLoading"></a><a class="link" href="#IncrementalLoading">10.6. Incremental Loading</a></h3>
<div class="paragraph">
<p>It is very common for your UI query to have a lot more in it than you want to load at any given time. In some cases,
even a specific entity asks for more than you&#8217;d like to load. A good example of this is a component that allows comments.
Perhaps you&#8217;d like the initial load of the component to not include the comments at all, then later load the comments
when the user, for example, opens (or scrolls to) that part of the UI.</p>
</div>
<div class="paragraph">
<p>Fulcro makes this quite easy. There are three basic steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Put the full query on the  UI</p>
</li>
<li>
<p>When you use that UI query with load, prune out the parts you don&#8217;t want.</p>
</li>
<li>
<p>Later, ask for the part you <strong>do</strong> want.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Step 2 sounds like it will be hard, but it isn&#8217;t:</p>
</div>
<div class="sect3">
<h4 id="_pruning_the_query"><a class="anchor" href="#_pruning_the_query"></a><a class="link" href="#_pruning_the_query">10.6.1. Pruning the Query</a></h4>
<div class="paragraph">
<p>Sometimes your UI graph asks for things that you&#8217;d like to load incrementally. Let&#8217;s say you were loading a blog
post that has comments. Perhaps you&#8217;d like to load the comments later:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load app <span class="symbol">:server/blog</span> Blog {<span class="symbol">:params</span> {<span class="symbol">:id</span> <span class="integer">1</span>}
                                <span class="symbol">:without</span> #{<span class="symbol">:blog/comments</span>}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:without</code> parameter can be used to elide portions of the query (it works recursively). The query sent to the
server will <strong>not</strong> ask for <code>:blog/comments</code>. Of course, your server has to parse and honor the exact details
of the query for this to work (if the server decides it&#8217;s going to returns the comments, you get them&#8230;&#8203;but this is why
we disliked REST, right?). Of course, Pathom makes this quite easy since it honors the query presented to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_filling_in_the_subgraph"><a class="anchor" href="#_filling_in_the_subgraph"></a><a class="link" href="#_filling_in_the_subgraph">10.6.2. Filling in the Subgraph</a></h4>
<div class="paragraph">
<p>Later, say when the user scrolls to the bottom of the screen or clicks on "show comments" we can load the rest
from of this previously partially-loaded graph within the Blog itself. We can do this using <code>df/load-field!</code>, which
does the opposite of <code>:without</code> on the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Blog [this props]
  {<span class="symbol">:ident</span>  <span class="symbol">:blog/id</span>
   <span class="symbol">:query</span>  [<span class="symbol">:blog/id</span> <span class="symbol">:blog/title</span> {<span class="symbol">:blog/content</span> (comp/get-query BlogContent)} {<span class="symbol">:blog/comments</span> (comp/get-query BlogComment)}]}
  (dom/div
     <span class="keyword">..</span><span class="keyword">.</span>
     (dom/button {<span class="symbol">:onClick</span> #(df/load-field! this <span class="symbol">:blog/comments</span> {})} <span class="string"><span class="delimiter">&quot;</span><span class="content">Show Comments</span><span class="delimiter">&quot;</span></span>)
     <span class="keyword">..</span><span class="keyword">.</span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>load-field!</code> function finds the query on the component (via <code>this</code>) and prunes everything from that query <strong>except</strong>
for the branch joined through the given key. It also generates an <strong>entity rooted query</strong> based on the calling component&#8217;s ident:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{[<span class="symbol">:table</span> ID] subquery}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, this would end up something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{[<span class="symbol">:blog/id</span> <span class="integer">1</span>] [{<span class="symbol">:blog/comments</span> [<span class="symbol">:comment/id</span> <span class="symbol">:comment/author</span> <span class="symbol">:comment/body</span>]}]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This kind of query can be handled automatically by Pathom as long as there is a resolver that takes <code>:blog/id</code> as
an input, and resolvers exist to fulfill the subgraph from there!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver blog-resolver [env {<span class="symbol">:blog/keys</span> [id]}]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">:blog/id</span>}
   <span class="symbol">::pc/output</span> [<span class="keyword">..</span><span class="keyword">.</span> {<span class="symbol">:blog/comments</span> [<span class="symbol">:comment/id</span>]}]}
  <span class="keyword">..</span><span class="keyword">.</span>)

(pc/defresolver comment-resolver [env {<span class="symbol">:comment/keys</span> [id]}]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">:comment/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:comment/body</span> {<span class="symbol">:comment/author</span> [<span class="symbol">:author/id</span>]}]}
  <span class="keyword">..</span><span class="keyword">.</span>)

<span class="comment">;; and so on</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_load_focus"><a class="anchor" href="#_load_focus"></a><a class="link" href="#_load_focus">Load Focus</a></h5>
<div class="paragraph">
<p>Another way to load a subgraph part is to use the <code>:focus</code> setting on the <code>load</code>, <code>:focus</code>
allow you to define a subquery to be loaded from the component query, to start simple here
is how we can write the same previous example using <code>:focus</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Blog [this props]
  {<span class="symbol">:ident</span>  [<span class="symbol">:blog/id</span> <span class="symbol">:db/id</span>]
   <span class="symbol">:query</span>  [<span class="symbol">:db/id</span> <span class="symbol">:blog/title</span> {<span class="symbol">:blog/content</span> (comp/get-query BlogContent)} {<span class="symbol">:blog/comments</span> (comp/get-query BlogComment)}]}
  (dom/div
     <span class="keyword">..</span><span class="keyword">.</span>
     (dom/button {<span class="symbol">:onClick</span> #(<span class="keyword">load</span> this (comp/get-ident this) Blog {<span class="symbol">:focus</span> [<span class="symbol">:blog/comments</span>]})}
       <span class="string"><span class="delimiter">&quot;</span><span class="content">Show Comments</span><span class="delimiter">&quot;</span></span>)
     <span class="keyword">..</span><span class="keyword">.</span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although the interface requires more code, it&#8217;s more flexible, let&#8217;s say for instance you only want
to load the comment id and author, you can write as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">load</span> this (get-ident this) Blog {<span class="symbol">:focus</span> [{<span class="symbol">:blog/comments</span> [<span class="symbol">:db/id</span> <span class="symbol">:comment/author</span>]}]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you might notice, in the first <code>:focus</code> example when we point to a join, the whole
join sub-query will be pulled, but you can get more precise by expressing more of the
sub-query.</p>
</div>
</div>
<div class="sect4">
<h5 id="_load_focus_on_unions"><a class="anchor" href="#_load_focus_on_unions"></a><a class="link" href="#_load_focus_on_unions">Load focus on unions</a></h5>
<div class="paragraph">
<p>A special case that worth mention about focus sub-query is how it handles unions. Other
than on unions, <code>:focus</code> will only use the attributes mentioned on the sub-query, but
on unions, if you don&#8217;t express some union branch it will be pulled as is, for example, let&#8217;s
say you have this given query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:feed/item</span> {<span class="symbol">:message</span> [<span class="symbol">:message/text</span> <span class="symbol">:message/timestamp</span>]
              <span class="symbol">:activity</span> [<span class="symbol">:activity/source-id</span> <span class="symbol">:activity/url</span>]}}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you <code>:focus</code> on this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:feed/item</span> {<span class="symbol">:message</span> [<span class="symbol">:message/text</span>]}}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you get out the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:feed/item</span> {<span class="symbol">:message</span> [<span class="symbol">:message/text</span>]
              <span class="symbol">:activity</span> [<span class="symbol">:activity/source-id</span> <span class="symbol">:activity/url</span>]}}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes sure you will keep all union branches.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_load_errors"><a class="anchor" href="#_load_errors"></a><a class="link" href="#_load_errors">10.7. Load Errors</a></h3>
<div class="paragraph">
<p>The <code>load!</code> function includes a number of options for dealing with problems during load. The docstring <code>load!</code>
describes your options, and we leave that discussion to the <a href="#UserExperience">chapter on overall error handling
and user experience</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="UserExperience"><a class="anchor" href="#UserExperience"></a><a class="link" href="#UserExperience">11. Network Latency, Error Handling, and User Experience</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most applications have to contend with network latency. A good user experience requires that applications be able
to give feedback to the user about the progress of network operations. The optimistic nature of Fulcro means that you
can often give the user the impression of zero latency (the UI changes before the networking even starts); however,
there are many circumstances where you would like to give the user some assurance that the full-stack operation
is complete before moving on. For example, when saving a form you usually don&#8217;t want to pop up some kind of error
about the submission of that form when the user has already moved on to a new screen.</p>
</div>
<div class="paragraph">
<p>You&#8217;ve certainly seen a number of different ways this can be handled. Network applications like Google Docs give the
user a continuous indication of when their changes are pending vs. when they have been saved, which allows the user
to work in an uninterrupted fashion where
they only need to worry about the network when they are done with the entire session. More and more applications
save data from things like settings screens as the changes are made, removing the need for a user "save step" as well.</p>
</div>
<div class="paragraph">
<p>Still others do more complex schemes that persist data into browser local storage as a method of preventing data loss
even if the network is spotty or the browser crashes while unsaved changes are queued.</p>
</div>
<div class="paragraph">
<p>Fulcro gives you the power to express any user experience, and this chapter covers some of the techniques you can
use to provide the experience you desire.</p>
</div>
<div class="sect2">
<h3 id="_global_network_activity"><a class="anchor" href="#_global_network_activity"></a><a class="link" href="#_global_network_activity">11.1. Global Network Activity</a></h3>
<div class="paragraph">
<p>Fulcro tracks the general idea that network activity is happening in the state database under
the key :com.fulcrologic.fulcro.application/active-remotes. The value is a set of remote names
(keywords) that have scheduled remote activity that has yet to complete. A remote will appear in
this set from the time the desire for remote content enters the transaction processing system until
that desire is met (or fails).</p>
</div>
<div class="paragraph">
<p>This global set can easily be queried for by a component that wants to track the status of network
activity by simply querying for it with a root link element in the query: <code>[::app/active-remotes '_]</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Any component querying for the network active remotes will see a lot of re-renders. It is recommended
that such a component be a leaf in the UI graph so you don&#8217;t trigger refresh on entire subtrees due
to network activity status updates.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc GlobalStatus [this {<span class="symbol">::app/keys</span> [active-remotes]}]
  {<span class="symbol">:query</span> [[<span class="symbol">::app/active-remotes</span> '_]]
   <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] [<span class="symbol">:component/id</span> <span class="symbol">:activity</span>])
   <span class="comment">;; important: components that query only for root data need to have at least some empty state of their own</span>
   <span class="symbol">:initial-state</span> {}}
  <span class="keyword">..</span><span class="keyword">.</span>
  (<span class="keyword">let</span> [loading? (<span class="keyword">boolean</span> (<span class="keyword">seq</span> active-remotes))]
    (<span class="keyword">when</span> loading?
      (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>))))</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 31. <a id="NetworkActivity"></a><a href="#NetworkActivity">Network Activity</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('network-activity')">Focus Inspector</button>
<div class="short narrow example" id="network-activity"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.server.network-activity</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.application <span class="symbol">:as</span> app]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [taoensso.timbre <span class="symbol">:as</span> log]
    [clojure.pprint <span class="symbol">:refer</span> [pprint]]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]))

<span class="comment">;; Simulated server</span>

(pc/defresolver silly-resolver [_ _]
  {<span class="symbol">::pc/output</span> [<span class="symbol">::data</span>]}
  {<span class="symbol">::data</span> <span class="integer">42</span>})

<span class="comment">;; Client</span>

(defsc ActivityIndicator [this props]
  {<span class="symbol">:query</span>         [[<span class="symbol">::app/active-remotes</span> '_]]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:component/id</span> <span class="symbol">::activity</span>])
   <span class="symbol">:initial-state</span> {}}
  (<span class="keyword">let</span> [active-remotes (<span class="symbol">::app/active-remotes</span> props)]
    (dom/div
      (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Active Remotes</span><span class="delimiter">&quot;</span></span>)
      (dom/pre (<span class="keyword">pr-str</span> active-remotes)))))

(<span class="keyword">def</span> <span class="function">ui-activity-indicator</span> (comp/factory ActivityIndicator {<span class="symbol">:keyfn</span> <span class="symbol">:id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [indicator]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:indicator</span> (comp/get-query ActivityIndicator)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:indicator</span> {}}}
  (dom/div {}
    (dom/p {} <span class="string"><span class="delimiter">&quot;</span><span class="content">Use the server controls to slow down the network, so you can see the activity</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(df/load! this <span class="symbol">::data</span> <span class="predefined-constant">nil</span>)} <span class="string"><span class="delimiter">&quot;</span><span class="content">Trigger a Load</span><span class="delimiter">&quot;</span></span>)
    (ui-activity-indicator indicator)))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pessimistic_operation"><a class="anchor" href="#_pessimistic_operation"></a><a class="link" href="#_pessimistic_operation">11.2. Pessimistic Operation</a></h3>
<div class="paragraph">
<p>Fulcro is optimistic by default, but pessimism is also a supported mode. There are a couple of clear techniques you can
use to allow the network activity to complete before allowing the user to continue:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The Load API has a number of parameters that can allow you to plug in your own code for dealing with results.</p>
</li>
<li>
<p>For mutations: use the action/ok-action/error-action to do a sequence of optimistically blocking the UI, sending the
request, and then using the ok-action/error-action as the place to unblock the UI and report the result. This is the
most similar to the approach other libraries use.</p>
</li>
<li>
<p>Use pessimistic transactions. This is a mode of transaction processing that allows each mutation in a single top-level
transaction (call to <code>transact!</code>) to complete (full-stack) before anything from the next one begins. This mode has
the advantage of making the sequence visible at the transaction layer, but requires you share progressive data through
the app state itself. Some people prefer this because the "happy path" can be expressed clearly in the UI, even though
the details are still within the mutation. Something like
<code>(comp/transact! this [(submit-form) (process-result)] {:optimistic? false})</code> is more directly informative to the reader
than <code>(comp/transact! this [(submit-form)])</code> (implied post-processing hidden in the mutation <code>ok-action</code>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There are also some more advanced techniques that allow you to leverage more global control:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Change the <code>default-result-action</code> for mutations and provide application-specific defaults for error handling.</p>
</li>
<li>
<p>Change the <code>internal-load</code> mutation for loads to add in whatever global changes you desire.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The above two techniques typically would leverage the default implementations so that the pre-defined behaviors still
work, but might include mechanisms you define to handle common cases without having to code them repeatedly. If you want
to explore these advanced techniques expect to use the source. See <code>mutations.cljc</code> and <code>data_fetch.cljc</code> for the
default implementations, and the docstring of <code>app/fulcro-app</code> for the options you can use to override the defaults.</p>
</div>
</div>
<div class="sect2">
<h3 id="FullStackErrorHandling"><a class="anchor" href="#FullStackErrorHandling"></a><a class="link" href="#FullStackErrorHandling">11.3. Full-Stack Error Handling</a></h3>
<div class="paragraph">
<p>The first thing I want to challenge you to think about is this: why do errors happen, and what can we do about them?</p>
</div>
<div class="paragraph">
<p>In the early days of web apps, our UI was completely dumb: the server did all of the logic. The answer to these questions
were clear, because it wasn&#8217;t even a distributed app: it was a <strong>remote display</strong> of an app running on a <strong>remote machine</strong>.
In other words, the context of the error handling was available at the same time as our request to do the operation.</p>
</div>
<div class="paragraph">
<p>In more modern apps we often block the UI so that the user cannot get ahead of things (like
submit a form and move on before the server has confirmed the submission).
Over the years we&#8217;ve gotten a little more clever with our error handling, but largely our users (and our ability
to reason about our programs) has kept us firmly rooted to the block-until-we-know method of error handling because
that behavior is simple: it is much less like an actual distributed system. Unfortunately, such UI interactions are
doomed to feel sluggish in congested or bandwidth-limited environments.</p>
</div>
<div class="paragraph">
<p>More and more code is moving to the client machine. In the world of single-page apps we want
things to "make sense" and we also want them to be snappy. Unfortunately, we still also have security concerns
at the server, so we get confused by the following fact: the server <strong>has</strong> to be able to
validate a request for security reasons. There is no getting around this. You cannot trust a client.</p>
</div>
<div class="paragraph">
<p>However, I think many of us take this too far: security concerns are often a lot easier to enforce than the full
client-level interaction <em>with</em> these concerns. For example, we can say on a server that a field must be a number.
This is one line of code that can be done with an assertion.</p>
</div>
<div class="paragraph">
<p>The UI logic for this is much larger: we have to tell the user what we expected, why we expected it, constrain the UI
to keep them from typing letters, etc. In other words, almost all of the <em>real</em> logic is <em>already on the client</em>, and unless
there is a bug, <strong>our</strong> UI <strong>won&#8217;t</strong> cause a server error because it is pre-checking everything before sending it out.</p>
</div>
<div class="paragraph">
<p>So, in a modern UI, here are the scenarios for errors <strong>from the server</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You have a bug. Is there anything you can really do? No, because it is a bug. If you could predict it going wrong, you would
have already fixed it. Testing and user bug reports are your only recourse.</p>
</li>
<li>
<p>There is a security violation. There is nothing for your UI to do, because your UI didn&#8217;t do it! This is an attack.
Throw an exception on the server, and never expect it in the UI. If you get it, it is a bug. See (1).</p>
</li>
<li>
<p>There is a user perspective outage (LAN/WiFi/phone). These are possibly recoverable. You can block the UI, and allow the
user to continue once networking is re-established.</p>
</li>
<li>
<p>There is an infrastructure outage. You&#8217;re screwed. Things are just down. If you&#8217;re lucky, it is networking and your
user is seeing it as (3) and is just blocked. If you&#8217;re not lucky, your database crashed and you have no idea
if your data is even consistent.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So, I would assert that the only full-stack error handling <strong>worth</strong> doing in <strong>any detail</strong> is for case (3). If communications
are down, the client can retry. But in a distributed system this can be a little nuanced. Did that mutation partially complete?</p>
</div>
<div class="paragraph">
<p>If your application can assume reasonably reliable networking and you write your server operations to be atomic then
your error handling can be a relatively small amount of code. Unrecoverable problems will be rare and at worst
you throw up a dialog that says you&#8217;ve had an error and the user hits reload on their browser.
If this happens to users once or twice a year, it isn&#8217;t going to hurt you.</p>
</div>
<div class="paragraph">
<p>But of course there is more to the story, and the devil is in the details.</p>
</div>
<div class="sect3">
<h4 id="_programming_with_pure_optimism"><a class="anchor" href="#_programming_with_pure_optimism"></a><a class="link" href="#_programming_with_pure_optimism">11.3.1. Programming with Pure Optimism</a></h4>
<div class="paragraph">
<p>The <em>general</em> philosophy of a Fulcro application is that optimistic updates are not even triggered on the client
unless they expect to succeed on the server. In other words, you write the application in such a way that operations cannot be triggered
from the UI unless you&#8217;re certain that a <strong>functioning server</strong> will execute them. A server should not throw an exception
and trigger a need for error handling unless there is a real, non-recoverable situation.</p>
</div>
<div class="paragraph">
<p>If this is true then a functioning server <strong>does</strong> need to do sanity checking for security reasons, but in general you
don&#8217;t need to give friendly errors when those checks fail: you should assume they are attempted hacks. Other serious
problems are similar: there is usually nothing you can do but throw an exception and let the user contact support.
Exceptions to this rule certainly exist, but they are not the central concern.</p>
</div>
<div class="paragraph">
<p>There are some cases where the server has to be involved in a validation interaction non-optimistically. Login is a great
example of this. However, invalid credentials on login need not be treated as an <strong>error</strong>. Instead they can be treated as
a response to a question. "Can I log in with these credentials?". Yes or no. This allows the UI to show the correct
result without treating anything as a distributed-systems/data-consistency kind of error.</p>
</div>
<div class="paragraph">
<p>This philosophy eases the overhead in general application programming. You need not write a bunch of code in the UI
that gives a nice friendly message for every kind of error that can possibly occur (nor does anyone really do that
anywhere anyhow, since it is quite expensive). If an error occurs, you can pretty much assume
it is either a bug or a real outage. In both cases, there isn&#8217;t a lot you can do that will work "well" for the user. If
it is a bug, then you really have no chance of predicting what will fix it, otherwise you would have already fixed the
bug. If it&#8217;s an outage you might be able to do retries, but in many cases you have no way of knowing what has gone wrong.</p>
</div>
<div class="paragraph">
<p>So, one approach is to treat most error conditions as a rare problem that needs fairly radical recovery.
One such method is to use a global error handler that is configured during
the setup of your client application. This function could update application
state to show some kind of top-level modal dialog that describes the problem, possibly allows the user to submit
application history (for support viewer) to your servers, and then re-initializes the application in some way.</p>
</div>
<div class="paragraph">
<p>You can, of course, get pretty creative with the re-initialization. For example, say you write screens so that they will
refresh their persistent data whenever it is older than some amount of time, and write it so all entities have a timestamp.
You could walk the state and "expire" all of the timestamps, and then close the dialog. Your retry
could be set up to check for the expiration, which in turn would trigger loads. If the server is really having
problems then the worst case is that the dialog pops back up telling them there is still a problem.</p>
</div>
</div>
<div class="sect3">
<h4 id="_being_a_bit_more_pessimisticflaky_network_operation"><a class="anchor" href="#_being_a_bit_more_pessimisticflaky_network_operation"></a><a class="link" href="#_being_a_bit_more_pessimisticflaky_network_operation">11.3.2. Being a Bit More Pessimistic&#8201;&#8212;&#8201;Flaky Network Operation</a></h4>
<div class="paragraph">
<p>If your users are likely using your software from a phone on a subway then you have a completely different issue.</p>
</div>
<div class="paragraph">
<p>Fortunately, Fulcro actually makes handling this case relatively easy as well. Here is what you can do:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a custom networking implementation for the client that detects the <strong>kind</strong> of error, and retries recoverable ones
until they succeed. Possibly with exponential backoff. (If an infinite loop happens, the user will eventually hit reload.)</p>
</li>
<li>
<p>Make your server mutations idempotent so that a client can safely re-apply a transaction without causing data corruption.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The default fulcro networking does not do retries because it isn&#8217;t safe without the idempotent guarantee.</p>
</div>
<div class="paragraph">
<p>The optimistic updates of Fulcro and the in-order server execution means that "offline" operation is actually quite
tractable. If programmed this way, your error handling becomes isolated almost entirely to the networking layer. Of course,
if the user navigates to a screen that needs server data, they will just have to wait. Writing UI code that possibly has
lifecycle timers to show progress updates will improve the overall feel, but the correctness will be there with a fairly
small number of additions.</p>
</div>
<div class="paragraph">
<p>However, even with these fancy tricks that make our applications better, there are times when we&#8217;d just like to
block until something is complete. The following example is a common way to do UI blocking with the mechanisms
you&#8217;ve already seen. It overrides the default <code>result-action</code> to look at the response from the server and decide what to do.</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. <a id="UIBlocking"></a><a href="#UIBlocking">UI Blocking</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('ui-blocking-example')">Focus Inspector</button>
<div class="short narrow example" id="ui-blocking-example"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.server.ui-blocking-example</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [taoensso.timbre <span class="symbol">:as</span> log]))

<span class="comment">;; SERVER</span>

(pc/defmutation submit-form-mutation [env params]
  {<span class="symbol">::pc/sym</span> `submit-form}
  (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Server got </span><span class="delimiter">&quot;</span></span> params)
  (<span class="keyword">if</span> (<span class="keyword">&gt;</span> <span class="float">0.5</span> (<span class="keyword">rand</span>))
    {<span class="symbol">:message</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Everything went swell!</span><span class="delimiter">&quot;</span></span>
     <span class="symbol">:ok?</span>     <span class="predefined-constant">true</span>}
    {<span class="symbol">:message</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Service temporarily unavailable!</span><span class="delimiter">&quot;</span></span>
     <span class="symbol">:ok?</span>     <span class="predefined-constant">false</span>}))

<span class="comment">;; CLIENT</span>

(defsc BlockingOverlay [this {<span class="symbol">:keys</span> [ui/active? ui/message]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:ui/active?</span> <span class="symbol">:ui/message</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:ui/active?</span> <span class="predefined-constant">false</span> <span class="symbol">:ui/message</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Please wait...</span><span class="delimiter">&quot;</span></span>}}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:position</span>        <span class="symbol">:absolute</span>
                    <span class="symbol">:display</span>         (<span class="keyword">if</span> active? <span class="string"><span class="delimiter">&quot;</span><span class="content">block</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">none</span><span class="delimiter">&quot;</span></span>)
                    <span class="symbol">:zIndex</span>          <span class="integer">65000</span>
                    <span class="symbol">:width</span>           <span class="string"><span class="delimiter">&quot;</span><span class="content">400px</span><span class="delimiter">&quot;</span></span>
                    <span class="symbol">:height</span>          <span class="string"><span class="delimiter">&quot;</span><span class="content">100px</span><span class="delimiter">&quot;</span></span>
                    <span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">rgba(0,0,0,0.5)</span><span class="delimiter">&quot;</span></span>}}
    (dom/div {<span class="symbol">:style</span> {<span class="symbol">:position</span>  <span class="symbol">:relative</span>
                      <span class="symbol">:top</span>       <span class="string"><span class="delimiter">&quot;</span><span class="content">40px</span><span class="delimiter">&quot;</span></span>
                      <span class="symbol">:color</span>     <span class="string"><span class="delimiter">&quot;</span><span class="content">white</span><span class="delimiter">&quot;</span></span>
                      <span class="symbol">:textAlign</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">center</span><span class="delimiter">&quot;</span></span>}} message)))

(<span class="keyword">def</span> <span class="function">ui-overlay</span> (comp/factory BlockingOverlay))

(<span class="keyword">defn</span> <span class="function">set-overlay-visible*</span> [state tf] (<span class="keyword">assoc-in</span> state [<span class="symbol">:overlay</span> <span class="symbol">:ui/active?</span>] tf))
(<span class="keyword">defn</span> <span class="function">set-overlay-message*</span> [state message] (<span class="keyword">assoc-in</span> state [<span class="symbol">:overlay</span> <span class="symbol">:ui/message</span>] message))

(defmutation submit-form [params]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                   (<span class="keyword">-&gt;</span> s
                     (set-overlay-message* <span class="string"><span class="delimiter">&quot;</span><span class="content">Working...</span><span class="delimiter">&quot;</span></span>)
                     (set-overlay-visible* <span class="predefined-constant">true</span>)))))
  (result-action [{<span class="symbol">:keys</span> [app state result]}]
    (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Result:</span><span class="delimiter">&quot;</span></span> result)
    (<span class="keyword">let</span> [mutation-result (<span class="keyword">-&gt;</span> result <span class="symbol">:body</span> (<span class="keyword">get</span> `submit-form))
          {<span class="symbol">:keys</span> [message ok?]} mutation-result]
      (<span class="keyword">if</span> ok?
        (<span class="keyword">swap!</span> state set-overlay-visible* <span class="predefined-constant">false</span>)
        (<span class="keyword">do</span>
          (<span class="keyword">swap!</span> state set-overlay-message* (<span class="keyword">str</span> message <span class="string"><span class="delimiter">&quot;</span><span class="content">   Retrying submission in 1s.</span><span class="delimiter">&quot;</span></span>))
          <span class="comment">;; could use setTimeout or immediately do it</span>
          (js/setTimeout
            #(comp/transact! app [(submit-form params)])
            <span class="integer">1000</span>)))))
  (remote [_] <span class="predefined-constant">true</span>))

(defsc Root [this {<span class="symbol">:keys</span> [ui/name overlay]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:ui/name</span> {<span class="symbol">:overlay</span> (comp/get-query BlockingOverlay)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:overlay</span> {} <span class="symbol">:ui/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Alicia</span><span class="delimiter">&quot;</span></span>}}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:width</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">400px</span><span class="delimiter">&quot;</span></span> <span class="symbol">:height</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">100px</span><span class="delimiter">&quot;</span></span>}}
    (ui-overlay overlay)
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">Name: </span><span class="delimiter">&quot;</span></span> (dom/input {<span class="symbol">:value</span> <span class="keyword">name</span>}))
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this [(submit-form {<span class="symbol">:made-up-data</span> <span class="integer">42</span>})])}
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Submit</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_remote_errors"><a class="anchor" href="#_defining_remote_errors"></a><a class="link" href="#_defining_remote_errors">11.3.3. Defining "Remote Errors"</a></h4>
<div class="paragraph">
<p>Fulcro&#8217;s concept of a "remote error" is configurable. It defaults to a function that returns true if the network result
includes a <code>:status-code</code> attribute that is not 200. However, it is common for applications to define errors more widely.
For example, you might consider certain data return values to be indications of an error.</p>
</div>
<div class="paragraph">
<p>You can define the meaning of "remote errors" when you create your Fulcro application via the <code>:remote-error?</code> option:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(app/fulcro-app {<span class="symbol">:remote-error?</span> (<span class="keyword">fn</span> [result] <span class="keyword">boolean</span>)})</code></pre>
</div>
</div>
<div class="paragraph">
<p>where the result value is the raw value that your selected remote encodes. Fulcro&#8217;s HTTP remote encodes result as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:body</span> raw-result
 <span class="symbol">:transaction</span> outgoing-tx
 <span class="symbol">:status-code</span> n
 <span class="keyword">..</span><span class="keyword">.</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This result is determined by the remote implementation and client network middleware can certainly expand/modify this as needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_global_error_handler"><a class="anchor" href="#_global_error_handler"></a><a class="link" href="#_global_error_handler">11.3.4. Global Error Handler</a></h4>
<div class="paragraph">
<p>When you create your application you can set a global function that is called on any kind of network error that
happens against any remote. The function will be called with the <code>env</code>, which will contain things like the AST,
network result, etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(app/fulcro-app {<span class="symbol">:global-error-action</span> (<span class="keyword">fn</span> [env] <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can of course swap against the state atom, use the app from the <code>env</code> to submit a new transaction, etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_load_errors_2"><a class="anchor" href="#_load_errors_2"></a><a class="link" href="#_load_errors_2">11.3.5. Load Errors</a></h4>
<div class="paragraph">
<p>Loads can define a mutation symbol that should be used to trigger a transaction on errors.  Loads may also choose
to specify a lambda</p>
</div>
</div>
<div class="sect3">
<h4 id="_server_error_demo"><a class="anchor" href="#_server_error_demo"></a><a class="link" href="#_server_error_demo">11.3.6. Server Error Demo</a></h4>
<div class="paragraph">
<p>We recommend using Pathom for the server, and one of the recommended plugins for Pathom will convert exceptions
into data errors on the response.  This allows pathom to give partial responses where it can partially fufill a
request for data.</p>
</div>
<div class="paragraph">
<p>Fulcro does not default to considering these particular kinds of errors as "hard errors", and leaves them up
to your interpretation; however, it is simply enough to redefine what Fulcro things of as hard errors
by setting the <code>:remote-error?</code> option on your application.</p>
</div>
<div class="paragraph">
<p>The live example below demonstrates redefining the meaning of hard errors to look for these Pathom values,
and shows the resulting use of the built-in <code>error-action</code> support of mutations.</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. <a id="ErrorHandling"></a><a href="#ErrorHandling">Error Handling</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('server-error-handling')">Focus Inspector</button>
<div class="short narrow example" id="server-error-handling"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.server-error-handling</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [taoensso.timbre <span class="symbol">:as</span> log]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [com.fulcrologic.fulcro.application <span class="symbol">:as</span> app]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(pc/defmutation server-error-mutation [env params]
  {<span class="symbol">::pc/sym</span> `error-mutation}
  <span class="comment">;; Throw a mutation error for the client to handle</span>
  (<span class="keyword">throw</span> (ex-info <span class="string"><span class="delimiter">&quot;</span><span class="content">Mutation error</span><span class="delimiter">&quot;</span></span> {})))

(pc/defresolver child-resolver [env input]
  {<span class="symbol">::pc/output</span> [<span class="symbol">:fulcro/read-error</span>]}
  (<span class="keyword">throw</span> (ex-info <span class="string"><span class="delimiter">&quot;</span><span class="content">read error</span><span class="delimiter">&quot;</span></span> {})))

(<span class="keyword">def</span> <span class="function">resolvers</span> [server-error-mutation child-resolver])

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="comment">;; Mutation used as a fallback for load error: In this case the `env` from the load result *is* the params to this mutation</span>
(defmutation read-error [params]
  (action [env]
    (js/alert <span class="string"><span class="delimiter">&quot;</span><span class="content">There was a read error</span><span class="delimiter">&quot;</span></span>)
    (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Result from server:</span><span class="delimiter">&quot;</span></span> (<span class="symbol">:result</span> params))
    (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Original load params:</span><span class="delimiter">&quot;</span></span> (<span class="symbol">:load-params</span> params))))

<span class="comment">;; an :error key is injected into the fallback mutation's params argument</span>
(defmutation error-mutation [params]
  (ok-action [env] (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Optimistic action ran ok</span><span class="delimiter">&quot;</span></span>))
  <span class="comment">;; Error action is only called if `:remote-error?` for the application is defined to consider the response an error.</span>
  (error-action [{<span class="symbol">:keys</span> [app <span class="keyword">ref</span> result]}]
    (js/alert <span class="string"><span class="delimiter">&quot;</span><span class="content">Mutation error</span><span class="delimiter">&quot;</span></span>)
    (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Result </span><span class="delimiter">&quot;</span></span> result))
  (remote [env] <span class="predefined-constant">true</span>))

(defsc Child [this props]
  {<span class="symbol">:initial-state</span> {}
   <span class="symbol">:query</span>         ['<span class="keyword">*</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:error.child/by-id</span> <span class="symbol">:singleton</span>])}
  (dom/div
    <span class="comment">;; declare a tx/fallback in the same transact call as the mutation</span>
    <span class="comment">;; if the mutation fails, the fallback will be called</span>
    (dom/button {<span class="symbol">:onClick</span> #(df/load! this <span class="symbol">:fulcro/read-error</span> <span class="predefined-constant">nil</span> {<span class="symbol">:fallback</span> `read-error})}
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Failing read with a fallback</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(error-mutation {})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Failing mutation</span><span class="delimiter">&quot;</span></span>)
    ))

(<span class="keyword">def</span> <span class="function">ui-child</span> (comp/factory Child))

(defsc Root [this {<span class="symbol">:keys</span> [child]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:child</span> (comp/get-initial-state Child {})})
   <span class="symbol">:query</span>         [{<span class="symbol">:child</span> (comp/get-query Child)}]}
  (dom/div (ui-child child)))

(<span class="keyword">defn</span> <span class="function">contains-error?</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Check to see if the response contains Pathom error indicators.</span><span class="delimiter">&quot;</span></span>
  [body]
  (<span class="keyword">when</span> (<span class="keyword">map?</span> body)
    (<span class="keyword">let</span> [values (<span class="keyword">vals</span> body)]
      (<span class="keyword">reduce</span>
        (<span class="keyword">fn</span> [error? v]
          (<span class="keyword">if</span> (<span class="keyword">or</span>
                (<span class="keyword">and</span> (<span class="keyword">map?</span> v) (<span class="keyword">contains?</span> (<span class="keyword">set</span> (<span class="keyword">keys</span> v)) <span class="symbol">::p/reader-error</span>))
                (<span class="keyword">=</span> v <span class="symbol">::p/reader-error</span>))
            (reduced <span class="predefined-constant">true</span>)
            error?))
        <span class="predefined-constant">false</span>
        values))))

(<span class="keyword">def</span> <span class="function">SPA</span> (app/fulcro-app {<span class="symbol">:remote-error?</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [body] <span class="symbol">:as</span> result}]
                                           (<span class="keyword">or</span>
                                             (app/default-remote-error? result)
                                             (contains-error? body)))}))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_aborting_a_request"><a class="anchor" href="#_aborting_a_request"></a><a class="link" href="#_aborting_a_request">11.4. Aborting a Request</a></h3>
<div class="paragraph">
<p>Requests that are heavy on the server or require significant data transfer often need to be cancelled. User experience,
especially in mobile environments, can be heavily impacted if their navigation is blocked with no way back. Futhermore,
there is no real reason for you to pay for the bandwidth to send or receive something that the user is no longer interested
in.</p>
</div>
<div class="paragraph">
<p>The built-in HTTP remote support aborts. If you use a custom or alternate remote implementation then that may
affect the availability of both abort and progress reports. See <a href="#CustomRemote">the documentation</a> and source of your remote for
more information.</p>
</div>
<div class="paragraph">
<p>The abort feature requires that the request be assigned a unique identifier. You can use any data type that supports
equivalence, but we recommend using keywords. The <code>df/load!</code> and <code>comp/transact!</code> functions both accept an option
for supplying this ID:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load! this <span class="symbol">:thing</span> Thing {<span class="symbol">:abort-id</span> <span class="symbol">:thing</span>})
(comp/transact! this [(f)] {<span class="symbol">:abort-id</span> <span class="symbol">:made-up-id</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>application</code> namespace includes and <code>abort!</code> function that can accept a component or app, and the abort ID:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(app/abort! this <span class="symbol">:made-up-id</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aborting a load or transaction <em>while holding the thread of submission</em> will have no effect on the load just
issues (the load/mutation will be on a submission queue, not in active processing):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load! this <span class="symbol">:thing</span> Thing {<span class="symbol">:abort-id</span> <span class="symbol">:thing</span>})
(<span class="keyword">when</span> bad-thing?
  <span class="comment">;; WILL NOT WORK</span>
  (app/abort! this <span class="symbol">:thing</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Technically, it will abort any earlier submission(s) with abort ID <code>:thing</code> that have entered the processing phase.</p>
</div>
<div class="paragraph">
<p>Aborting a request that is active on the network or has yet to start networking will remove the request from
the processing queue, cancel the network operation, and trigger a result action.  <a href="#WhatIsAnError">Your definition of <code>remote-error?</code></a>
on your application will determine if the result is considered an error (which will trigger the error side of
post-processing) or not (which will trigger the OK side of post-processing).</p>
</div>
<div class="paragraph">
<p>The <code>:result</code> reported to your <code>remote-error?</code> and post-processing will <strong>not</strong> include a body <strong>or</strong> status code
(since the network request didn&#8217;t finish and provide one), but will instead look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">::txn/aborted?</span> <span class="predefined-constant">true</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Therefore the default remote error definition <strong>will</strong> consider aborts to be an error (since it does not have a status code of 200).</p>
</div>
</div>
<div class="sect2">
<h3 id="_progress_updates"><a class="anchor" href="#_progress_updates"></a><a class="link" href="#_progress_updates">11.5. Progress Updates</a></h3>
<div class="paragraph">
<p>Obtaining progress updates on mutations are requested the same way as abort IDs: through AST manipulation on the mutation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation some-mutation [params]
  (remote [{<span class="symbol">:keys</span> [ast]}]
     (m/with-progressive-updates ast `(progress-mutation {<span class="symbol">:x</span> <span class="integer">1</span>}))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Progress updates are sent to the given mutation (which will always receive the parameters you specified). The parameters
will be augmented with information about the current progress:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:progress-phase</code> - will be one of :sending, :receiving, :complete, or :failed.</p>
</li>
<li>
<p><code>:progress-event</code> - the raw XhrIO event (which has loading progress data)</p>
</li>
<li>
<p><code>:transaction</code> - The transaction that is running</p>
</li>
<li>
<p><code>:body</code> - The current low-level body. Body is NOT processed through the middleware, and could be partial.</p>
</li>
<li>
<p><code>:status-code</code> - The HTTP status code if receiving.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>fulcro.client.network/progress%</code> function can be used to convert this into a number between 0 and 100.</p>
</div>
<div class="paragraph">
<p>Progress updates are currently supported on mutations. Support for progress directly on loads is possible,
but not yet implemented. The workaround for the moment to get progress for a load is to use <a href="#MutationJoins">mutation joins</a>
to return a value from a mutation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation some-mutation [params]
  (remote [{<span class="symbol">:keys</span> [ast state]}]
    (<span class="keyword">-&gt;</span> ast
      (m/with-progressive-updates `(progress {}))
      (m/returning state Thing))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>Thing</code> is some component that defines the query for the data being returned from the mutation.</p>
</div>
<div class="paragraph">
<p>In general progress updates are only really useful for larger requests, such as file uploads. Triggering
downloads to the user&#8217;s machine should probably be done using tricks that force the item into the
normal browser download mechanisms (external to Fulcro).</p>
</div>
<div class="paragraph">
<p>File uploads also require that you augment the new client network middleware, since there is no
reliable way to encode an image of arbitrary size into a transaction.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="BuildingAServer"><a class="anchor" href="#BuildingAServer"></a><a class="link" href="#BuildingAServer">12. Building a Server</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>It turns out that the server API handling is relatively light. Most of the work goes into getting things set up
for easy server restart (e.g. making components stop/start) and getting those components into your parsing environment.</p>
</div>
<div class="paragraph">
<p>In general you should probably use a template project that already has a server set up, along with the
various bits you need for configuration, restart during development, testing, etc.</p>
</div>
<div class="paragraph">
<p>If you have an existing server then you&#8217;ve mostly figured out all of that stuff already and just want to plug
a Fulcro API handler into it.</p>
</div>
<div class="paragraph">
<p>Here are the basic requirements:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure your Ring stack has transit-response and transit-params.</p>
</li>
<li>
<p>Use <code>api-middleware/handle-api-request</code> to handle requests for the correct URI (defaults to <code>/api</code>)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>An example basic Ring stack was demonstrated in the Getting Started chapter&#8217;s <a href="#GoingRemote">Going Remote</a> section.</p>
</div>
<div class="sect2">
<h3 id="_use_pathom_to_process_the_eql"><a class="anchor" href="#_use_pathom_to_process_the_eql"></a><a class="link" href="#_use_pathom_to_process_the_eql">12.1. Use Pathom to Process the EQL</a></h3>
<div class="paragraph">
<p>You can hand-write a server-side parser to handle EQL from the client, but you should really just use Pathom.
See the <a href="https://wilkerlucio.github.io/pathom">Pathom Developer&#8217;s Guide</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_server_configuration"><a class="anchor" href="#_server_configuration"></a><a class="link" href="#_server_configuration">12.2. Server Configuration</a></h3>
<div class="paragraph">
<p>Fulcro includes a small set of functions that can help you with managing your server-side configuration data.
These functions are in the <code>com.fulcrologic.fulcro.server.config</code> namespace. The primary function
is <code>load-config!</code>.</p>
</div>
<div class="paragraph">
<p>Server configuration requires two EDN files:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>config/defaults.edn</code>: This file (from CLASSPATH, typically resources) should contain a single EDN map that contains
defaults for everything that the application wants to configure.</p>
</li>
<li>
<p><code>/abs/path/of/choice</code>: This file can be named what you want (you supply the name when
making the server). The content can be an empty map, but is meant to be machine-local
overrides of the configuration in the defaults. This file is required. We chose to do this because
it keeps people from starting the app in an production environment that is missing a configuration file.
NOTE: If the path is relative it is looked for via CLASSPATH (resource). If it is absolute, the real filesystem
is searched.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">make-system</span> []
  (server/make-fulcro-server
    <span class="symbol">:config-path</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/usr/local/etc/app.edn</span><span class="delimiter">&quot;</span></span>
    <span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The configuration loading has a number of built-in features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>defaults.edn</code> is the target of configuration merge. Your config EDN file must be a map, and anything
in it will override what is in defaults. The merge is a deep (recursive) merge.</p>
</li>
<li>
<p>You can override the configuration file that will be used as <code>:config-path</code> with a JVM option: <code>-Dconfig=filename</code>. This
allows you to specify the file on a per-environment basis.</p>
</li>
<li>
<p>Values can take the form <code>:env/VAR</code>, which will use the <strong>string</strong> value of that environment variable as the value.</p>
</li>
<li>
<p>Values can take the form <code>:env.edn/VAR</code>, which will use <code>read-string</code> to interpret the environment variable as the value.</p>
</li>
<li>
<p>Relative paths for the config file can be used, and will search the CLASSPATH instead of local disk. This allows you
to package your config with your application.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you are using something like <a href="https://github.com/tolitius/mount">mount</a>, then you will typically use <code>load-config!</code> directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defstate config <span class="symbol">:start</span> (server/load-config! {<span class="symbol">:config-path</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">config/dev.edn</span><span class="delimiter">&quot;</span></span>}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then <code>config</code> (after start) will simply contain the EDN of the defaults/config file merge.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ui_state_machines"><a class="anchor" href="#_ui_state_machines"></a><a class="link" href="#_ui_state_machines">13. UI State Machines</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>User interfaces are full of interactions that beg for the help of state machines. Just a simple
login form is usually quite difficult to code (independent of tools) because
its behavior depends on a number of factors&#8230;&#8203;factors that are actually quite easy to represent
with state machines, but get ugly quickly when spread out in various code artifacts.</p>
</div>
<div class="paragraph">
<p>This is not a new idea.  People have been using state machines to control user interfaces
and graphics systems for decades.  For some reason most UI libraries and frameworks don&#8217;t usually have
a well-known or particularly general-purpose state machine aspect.  Part of the problem is that
a state machine needs to interact with actual UI state and vice-versa, so it is difficult
to "bolt on" something, and there is often a lot of "glue code" to make the two hang together
properly.</p>
</div>
<div class="paragraph">
<p>It turns out that Fulcro&#8217;s approach to UI is quite easily amenable to state machines because it
has the following facets:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The transactional nature of mutations and central state is <strong>already</strong> a lot <em>like</em> a state machine.</p>
</li>
<li>
<p>Application state is just data.</p>
</li>
<li>
<p>The application database is normalized: It is very easy to describe where particular bits of
data are in a non-ambiguous manner.</p>
</li>
<li>
<p>The UI refresh is <strong>based on</strong> the normalized data model, and not the UI structure.  Triggering
refreshes requires only that you know what data your changing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thus, it turns out to be quite easy to build a state machine system for Fulcro
with the following properties:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The state machine doesn&#8217;t need not know anything about the UI</p>
</li>
<li>
<p>The UI only needs to support displaying the declared state of the state machine.</p>
</li>
<li>
<p>Simple aliasing can map the state machine "values" onto Fulcro database values.</p>
</li>
<li>
<p>The aliasing makes it possible to re-use state machines on UIs that have varying shapes, and need
not even name their Fulcro state according to the state machine&#8217;s conventions.</p>
</li>
<li>
<p>State machines can be <strong>instanced</strong>, so that more than one of the same kind can be running at once.</p>
</li>
<li>
<p>Active state machine data is stored in Fulcro&#8217;s app database, so it honors all history properties (e.g.
support viewer, etc.) and is amenable to great tooling.</p>
</li>
<li>
<p>Any number of simultaneous state machines of varying type can be running at once (even on the same component).</p>
</li>
<li>
<p>The state machine declarations are reusable (they are just maps), and make it easy to "derive" new
definitions based on existing ones with simple clj functions like <code>merge</code> and <code>assoc-in</code>.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_aliases"><a class="anchor" href="#_aliases"></a><a class="link" href="#_aliases">13.1. Aliases</a></h3>
<div class="paragraph">
<p>The first powerful concept for our state machines is aliasing.  The first kind of aliasing is
for the "actors" that will participate in our UI.  An actor is simply a keyword defined in the
state machine declaration, and is meant to stand for "some UI component".  The actions
of a state machine can then be written to abstractly refer to that component without
actually needing to know anything else about it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defstatemachine login
  {<span class="symbol">::uism/actor-names</span> #{<span class="symbol">:actor/dialog</span> <span class="symbol">:actor/form</span>}
   <span class="keyword">..</span><span class="keyword">.</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example we plan to have a "dialog" and a "form" on the UI.  These could be separate UI
components, or could be the same.  It doesn&#8217;t matter to the state machine!  We adopt the
<em>convention</em> of using the <code>actor</code> namespace for these, but it is not required.</p>
</div>
<div class="paragraph">
<p>In reality actors are merely names for some "yet to be specified" ident that points to an entity in your
database.</p>
</div>
<div class="paragraph">
<p>The next layer of aliasing is for the data our state machine will manipulate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defstatemachine login-machine
  {<span class="symbol">::uism/actor-names</span> #{<span class="symbol">:actor/dialog</span> <span class="symbol">:actor/form</span>}
   <span class="symbol">::uism/aliases</span> {<span class="symbol">:visible?</span>       [<span class="symbol">:actor/dialog</span> <span class="symbol">:ui/active?</span>]
                   <span class="symbol">:login-enabled?</span> [<span class="symbol">:actor/form</span> <span class="symbol">:ui/login-enabled?</span>]
                   <span class="symbol">:busy?</span>          [<span class="symbol">:actor/form</span> <span class="symbol">:ui/busy?</span>]
                   <span class="symbol">:error</span>          [<span class="symbol">:actor/form</span> <span class="symbol">:ui/login-error</span>]
                   <span class="symbol">:username</span>       [<span class="symbol">:actor/form</span> <span class="symbol">:user/email</span>]
                   <span class="symbol">:password</span>       [<span class="symbol">:actor/form</span> <span class="symbol">:user/password</span>]}
   <span class="keyword">..</span><span class="keyword">.</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus, the alias <code>busy?</code> is now the data path to some field of an entity in the database. The actual path
will be resolved at runtime based on what components actually end up being used as the actors. For
example if you use a component with ident <code>[:modal/id :general]</code> as the <code>:actor/dialog</code> then the alias
<code>:visible?</code> means the path <code>[:modal/id :general :ui/active?]</code>. This is the primary aspect of UI state machines
that makes them reusable.</p>
</div>
</div>
<div class="sect2">
<h3 id="DerivedSM"><a class="anchor" href="#DerivedSM"></a><a class="link" href="#DerivedSM">13.2. Derived State Machines </a></h3>
<div class="paragraph">
<p>State machine definitions are just maps.  If you needed the field on the dialog to
be called <code>:ui/visible?</code> instead of <code>:ui/active?</code> you could simply do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defstatemachine custom-login-machine
  (<span class="keyword">assoc-in</span> login-machine [<span class="symbol">::uism/aliases</span> <span class="symbol">:visible?</span> <span class="integer">1</span>] <span class="symbol">:ui/visible?</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes it possible to easily build a library of state machines that work on your app state
in a very general and configurable way without having to change any actual logic!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
State machine definitions must be declared with <code>defstatemachine</code> even though
they are just maps. The declaration registers them with the system so that they have
a unique ID that can be used within the instances in Fulcro&#8217;s client database.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_plugins"><a class="anchor" href="#_plugins"></a><a class="link" href="#_plugins">13.3. Plugins</a></h3>
<div class="paragraph">
<p>In order for a state machine to be as reusable as possible we&#8217;d also like to be able to write
logic that the state machine uses in a form that can be easily changed.  We call these bits of
logic "plugins".  The are simply functions that will receive a map of the current UI state
(by alias name) and will do some calculation.  They are meant to be side-effect free
calculations.</p>
</div>
<div class="paragraph">
<p>For example a login form we usually don&#8217;t want them to be able to press "Login" (or enter) until both
username and password fields have something in them.  If the username is an email we might also
want to check that it looks like a valid email before allowing submission.</p>
</div>
<div class="paragraph">
<p>The state machine can come with a simple plugin like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">   <span class="symbol">::uism/plugins</span>     {<span class="symbol">:valid-credentials?</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [username password]}]
                                             (<span class="keyword">boolean</span> (<span class="keyword">and</span> (<span class="keyword">seq</span> username) (<span class="keyword">seq</span> password))))}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Plugins receive (as a map) all of the current aliased data used by the state machine (so
they can easily destructure it as shown).  They can return any value.</p>
</div>
<div class="paragraph">
<p>Changing a plugin is as simple as the trick shown for overriding an alias in <a href="#DerivedSM">Derived State Machines</a>.</p>
</div>
<div class="paragraph">
<p>Plugins are called within a state handler like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">  <span class="keyword">..</span><span class="keyword">.</span>
  <span class="symbol">:event/login</span>        {<span class="symbol">::uism/handler</span>
                        (<span class="keyword">fn</span> [env]
                          (<span class="keyword">let</span> [valid?   (uism/run env <span class="symbol">:valid-credentials?</span>)]
                            <span class="keyword">..</span><span class="keyword">.</span>))}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_states"><a class="anchor" href="#_states"></a><a class="link" href="#_states">13.4. States</a></h3>
<div class="paragraph">
<p>The final bit of a state machine definition is, of course, the actual <strong>states</strong>.  In our
system we define these as a map from user-defined state name to a function that will
receive the running state machine environment for all events triggered on that state machine.</p>
</div>
<div class="paragraph">
<p>The states <strong>must</strong> include an <code>:initial</code> state, whose handler will be invoked with a
<code>::uism/started</code> event when the state machine is first started.  The "current state"
handler is always invoked for each event that is triggered while it is active, but
only the <code>:initial</code> state sees a <code>::uism/started</code> event.</p>
</div>
<div class="paragraph">
<p>The overall configuration of states looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defstatemachine login-machine
  {<span class="symbol">::uism/actor-names</span> #{<span class="keyword">..</span><span class="keyword">.</span>}
   <span class="symbol">::uism/aliases</span> {<span class="keyword">..</span><span class="keyword">.</span>}
   <span class="symbol">::uism/states</span> {<span class="symbol">:initial</span> { <span class="keyword">..</span><span class="keyword">.</span> }   <span class="comment">; REQUIRED</span>
                  <span class="symbol">:state/state-id</span> { <span class="keyword">..</span><span class="keyword">.</span> }
                  <span class="symbol">:state/state2-id</span> { <span class="keyword">..</span><span class="keyword">.</span> }
   <span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>By convention it is a good idea to name your states with a <code>state</code> namespace for readability, but this is not required.</p>
</div>
<div class="paragraph">
<p>You have two options for what you put in a state&#8217;s definition.</p>
</div>
<div class="sect3">
<h4 id="_option_1predicatehandler_preferred"><a class="anchor" href="#_option_1predicatehandler_preferred"></a><a class="link" href="#_option_1predicatehandler_preferred">13.4.1. Option 1&#8201;&#8212;&#8201;Predicate/handler (preferred)</a></h4>
<div class="paragraph">
<p>With this option you specify a map of events to a description of what should happen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="clojure"><span class="symbol">::uism/states</span> {<span class="symbol">:initial</span>    {<span class="symbol">::uism/events</span>
                            {<span class="symbol">:event/thing-happened!</span>
                              {<span class="symbol">::uism/event-predicate</span> (<span class="keyword">fn</span> [env] <span class="keyword">..</span><span class="keyword">.</span> <span class="predefined-constant">true</span>)
                               <span class="comment">;; target-states is doc for diagram tools</span>
                               <span class="symbol">::uism/target-states</span>   #{<span class="symbol">:state/next-state</span> <span class="symbol">:state/other-state</span>}
                               <span class="symbol">::uism/handler</span>         (<span class="keyword">fn</span> [env] <span class="keyword">..</span><span class="keyword">.</span> (uism/activate env <span class="symbol">:state/next-state</span>))}}}
               <span class="symbol">:state/next-state</span> {<span class="keyword">..</span><span class="keyword">.</span>}
               <span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the event <code>:event/thing-happened!</code> is an event that can happen while in the <code>:initial</code> state
which:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>If</strong> there is an event predicate, it is run. The default predicate is <code>(constantly true)</code>.  If the predicate returns
<code>false</code> then the event is ignored <strong>and nothing else happens</strong>.</p>
</li>
<li>
<p><strong>If</strong> the predicate returned true (or didn&#8217;t exist), then the handler is run.  Any effects it has
on <code>env</code> are propagated.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The predicate is useful for a few reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You may have a condition that should short-circuit triggers of numerous events.  Without the predicate you&#8217;d
have to code an <code>if</code> into each handler.</p>
</li>
<li>
<p>The UISM helper functions that set state (e.g. <code>set-string!</code>) apply state changes before your handler.  Under
certain circumstances you&#8217;d like to avoid that.  If predicate is <code>false</code>, then these events (as per the rules
above) are <strong>not</strong> applied.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_option_2a_single_handler"><a class="anchor" href="#_option_2a_single_handler"></a><a class="link" href="#_option_2a_single_handler">13.4.2. Option 2&#8201;&#8212;&#8201;A Single Handler</a></h4>
<div class="paragraph">
<p>This format of defining the states allows you to write just one function, but is not normally recommended, as it
does not give you the ability to analyze the states/events as a diagram via simple data analysis.  It does, however,
allow you complete flexibility with how the state machine is defined, so you are welcome to use it. Basically you do
not define an event map, and instead embed a handler in it&#8217;s place:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">   <span class="symbol">::uism/states</span>  {<span class="symbol">:initial</span>
                   {<span class="symbol">::uism/handler</span>
                     (<span class="keyword">fn</span> [env]
                       (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Initial state.</span><span class="delimiter">&quot;</span></span>)
                       <span class="keyword">..</span><span class="keyword">.</span>)}}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_handlers_and_data_manipulation"><a class="anchor" href="#_writing_handlers_and_data_manipulation"></a><a class="link" href="#_writing_handlers_and_data_manipulation">13.5. Writing Handlers and Data Manipulation</a></h3>
<div class="paragraph">
<p>From here it&#8217;s pretty easy.  The handlers are functions that receive a state machine (SM) environment and
must return an updated environment (or nil, which is considered "no change"). Since the
environment is an immutable value you will typically thread a sequence of these
together to end up with a final result to return from the handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">fn</span> [env]
  (<span class="keyword">-&gt;</span> env
     (uism/assoc-aliased <span class="symbol">:visible?</span> <span class="predefined-constant">true</span>)
     <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The library includes many functions for manipulating the system via the state machine handler&#8217;s <code>env</code>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(uism/assoc-aliased env alias new-value &amp; more-kv-pairs)</code></dt>
<dd>
<p>Sets Fulcro state associated with the given alias
to the given new value. Can accept multiple k-v pairs (like <code>assoc</code>).</p>
</dd>
<dt class="hdlist1"><code>(uism/dissoc-aliased env alias &amp; more-aliases)</code></dt>
<dd>
<p>Removes given aliases from Fulcro state. Can accept multiple
aliases (like <code>dissoc</code>).</p>
</dd>
<dt class="hdlist1"><code>(uism/update-aliased env alias f &amp; args)</code></dt>
<dd>
<p>Updates given aliases in Fulcro state with function f
and given arguments. (like <code>update</code>).</p>
</dd>
<dt class="hdlist1"><code>(uism/integrate-ident env ident &amp; named-parameter)</code></dt>
<dd>
<p>Integrates idents (append or prepend) to aliases in Fulcro state
that refer to a list of idents. (like <code>mutations/integrate-ident*</code>).</p>
</dd>
<dt class="hdlist1"><code>(uism/remove-ident env ident alias)</code></dt>
<dd>
<p>Removes ident from aliases that refer to a list of idents, in
Fulcro state. (like <code>fulcro.client.mutations/remove-ident*</code>).</p>
</dd>
<dt class="hdlist1"><code>(uism/alias-value env alias)</code></dt>
<dd>
<p>Gets the current Fulcro state value associated with an alias.</p>
</dd>
<dt class="hdlist1"><code>(uism/run env plugin-name)</code></dt>
<dd>
<p>Runs the given plugin (passing it all of the aliased data from
current Fulcro state) and returns the value from the plugin.</p>
</dd>
<dt class="hdlist1"><code>(uism/activate env state-name)</code></dt>
<dd>
<p>Returns a new env with <code>state-name</code> as the new active state.</p>
</dd>
<dt class="hdlist1"><code>(uism/exit env)</code></dt>
<dd>
<p>Returns a new env that will end the state machine (and GC it&#8217;s instance from
Fulcro state) after the results of the handler are processed.</p>
</dd>
<dt class="hdlist1"><code>(uism/store env k v)</code></dt>
<dd>
<p>Saves a state-machine local value.  Useful for keeping track of some additional
bit of data while your state machine is running.</p>
</dd>
<dt class="hdlist1"><code>(uism/retrieve env k)</code></dt>
<dd>
<p>Get state-machine local value.</p>
</dd>
<dt class="hdlist1"><code>(uism/apply-action env (fn [state-map] state-map))</code></dt>
<dd>
<p>use a fn of state-map (i.e. some mutation helper) via a SM env.</p>
</dd>
<dt class="hdlist1"><code>(uism/asm-value env ks)</code></dt>
<dd>
<p>Get the value of from an active state machine based on keyword OR key-path <code>ks</code>. Primarily
used for extending the library and internal use.</p>
</dd>
<dt class="hdlist1"><code>(uism/actor&#8594;ident env actor-name)</code></dt>
<dd>
<p>Get the ident of an actor</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Some of the utilities allow you to work fields directly on actors without having to alias fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(uism/actor-path env actor-name)</code></dt>
<dd>
<p>Get the real Fulcro state-path for the entity of the given actor.</p>
</dd>
<dt class="hdlist1"><code>(uism/actor-path env actor-name k)</code></dt>
<dd>
<p>Get the real Fulcro state-path for the attribute k of the entity of the given actor.</p>
</dd>
<dt class="hdlist1"><code>(uism/set-actor-value env actor-name k v)</code></dt>
<dd>
<p>Set a value in the actor&#8217;s Fulcro entity. Only the actor is resolved. The k is not processed as an alias.</p>
</dd>
<dt class="hdlist1"><code>(uism/actor-value env actor-name k follow-idents?)</code></dt>
<dd>
<p>Get the value of a particular key in the given actor&#8217;s entity. If follow-idents? is true (which is the default),
then it will recursively follow idents until it finds a non-ident value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_using_state_machines_from_the_ui"><a class="anchor" href="#_using_state_machines_from_the_ui"></a><a class="link" href="#_using_state_machines_from_the_ui">13.6. Using State Machines from the UI</a></h3>
<div class="paragraph">
<p>The next step, of course, is hooking this state machine up so it can control your UI (which really
just means your app state).</p>
</div>
<div class="sect3">
<h4 id="_starting_an_instance"><a class="anchor" href="#_starting_an_instance"></a><a class="link" href="#_starting_an_instance">13.6.1. Starting An Instance</a></h4>
<div class="paragraph">
<p>The first thing you need to do is create an instance and start it:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(uism/begin! app-or-component machine-def instance-id actor-map)</code></dt>
<dd>
<p>Installs an instance of a state
machine (to be known as <code>instance-id</code>, an arbitrary keyword), based on the definition in <code>machine-def</code>, into
Fulcro&#8217;s state and sends the <code>::uism/started</code> event.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This is a Fulcro transaction internally, so it follows the normal transactional semantics and can be used from almost
anywhere (including inside of another state machine handler).</p>
</div>
<div class="paragraph">
<p>The instance is stored in your database at the well-known <code>::uism/asm-id</code> table with an id that is
the instance ID you supply to this call.</p>
</div>
<div class="sect4">
<h5 id="_the_actor_map"><a class="anchor" href="#_the_actor_map"></a><a class="link" href="#_the_actor_map">The Actor Map</a></h5>
<div class="paragraph">
<p>The <code>actor-map</code> is a map, keyed by actor-id, that lets the state machine know what components in your Fulcro app are being
acted upon.  It also supplies the necessary information that is needed when doing remote mutations
and loads (since a component class or instance is needed to figure out normalization).</p>
</div>
<div class="paragraph">
<p>The actor map values must be one of the following:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">An ident</dt>
<dd>
<p>A raw ident is allowed, but should normally be augmented using <code>with-actor-class</code> so that it can work with loads/mutations.</p>
</dd>
<dt class="hdlist1">A component class</dt>
<dd>
<p>In this case the actor is assumed to be a singleton. The ident will be derived by calling
<code>(comp/get-ident class {})</code>.  This actor will work properly with remote return values and loads.</p>
</dd>
<dt class="hdlist1">A component instance (e.g. <code>this</code>)</dt>
<dd>
<p>A component instance can be <code>this</code>, or can be found using Fulcro&#8217;s live indexes
(e.g. <code>(comp/ref&#8594;any reconciler [:person/id 1])</code>).  A component instance is
sufficient for the state machine to find the correct ident <em>and</em> query for the UI component,
so it will work with loads/mutations.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_example_starts"><a class="anchor" href="#_example_starts"></a><a class="link" href="#_example_starts">Example Starts</a></h5>
<div class="paragraph">
<p>For example, to start the above state machine with an instance ID of <code>::loginsm</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(uism/begin! this login-machine <span class="symbol">::loginsm</span> {<span class="symbol">:actor/dialog</span>  Dialog
                                           <span class="symbol">:actor/session</span> Session
                                           <span class="symbol">:actor/form</span>    LoginForm})</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example all three of our components are singletons whose idents are constant.  If you are working
with actors that are more dynamic you either need to use a react instance (such as <code>this</code>), or an explicit ident:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(uism/begin! this person-editing-machine <span class="symbol">::personsm</span> {<span class="symbol">:person</span> (uism/with-actor-class [<span class="symbol">:person/id</span> <span class="integer">3</span>] Person)
                                                     <span class="symbol">:editor</span> this
                                                     <span class="symbol">:dialog</span> Dialog})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_triggering_events"><a class="anchor" href="#_triggering_events"></a><a class="link" href="#_triggering_events">13.6.2. Triggering Events</a></h4>
<div class="paragraph">
<p>Now that you have a state machine running it is ready to receive events.  It will have already
run the initial state handler. For example, in our login case the initial
state might show the dialog, clear the input fields, etc.</p>
</div>
<div class="paragraph">
<p>Forms may want to send an event to indicate that a value is changing in some form field.  Because this is
such a common operation there are two helpers for it. For example, to
update a string from a DOM <code>onChange</code> event or raw string:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(uism/set-string! component state-machine-id data-alias event-or-string)</code></dt>
<dd>
<p>Puts a string into
the given data alias (you can pass a string or a DOM onChange event) and
sends a <code>::uism/value-changed</code> event to your machine.</p>
</dd>
<dt class="hdlist1"><code>(uism/set-value! component state-machine-id data-alias raw-value)</code></dt>
<dd>
<p>Puts a raw (unmodified) value into
the given data alias and sends a <code>::uism/value-changed</code> event to your machine.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>You can define other "custom" events to stand for whatever you want (and they can include
aux data that you can pass along to the handlers).  To trigger arbitrary events use:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(uism/trigger! comp-or-reconciler state-machine-id event)</code></dt>
<dd>
<p>Trigger an arbitrary event on the given
state machine.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(uism/trigger! this <span class="symbol">::loginsm</span> <span class="symbol">:event/failure</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>would send a (user-defined) <code>:event/failure</code> event.  Event data is just a map that can be passed as an
additional parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(uism/trigger! reconciler <span class="symbol">::loginsm</span> <span class="symbol">:event/failure</span> {<span class="symbol">:message</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Server is down. Try in 15 minutes.</span><span class="delimiter">&quot;</span></span>})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_looking_at_the_running_instance"><a class="anchor" href="#_looking_at_the_running_instance"></a><a class="link" href="#_looking_at_the_running_instance">13.6.3. Looking at The Running Instance</a></h4>
<div class="paragraph">
<p>For debugging purposes you can just look in Fulcro Inspect at the database.  The active
state machines are in the <code>::uism/asm-id</code> table, with the ID you assigned.</p>
</div>
<div class="paragraph">
<p>UI code can also look at the state machine&#8217;s current state:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(uism/get-active-state this asm-id)</code></dt>
<dd>
<p>Returns the current state name (keyword).</p>
</dd>
<dt class="hdlist1"><code>(uism/asm-ident asm-id)</code></dt>
<dd>
<p>Returns the ident of the active state machine with the given ID.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Technically you must query for any data you use in the UI, but these functions help keep
the internals of the UISM system out of your UI code.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Any changes made to actor aliases presumably change data that a component is already querying for, meaning that those
components will automatically refresh without a problem; however, if you use data without querying for it (and this is
true everywhere in Fulcro) then you can experience what looks like "missed refreshes".</p>
</div>
<div class="paragraph">
<p>Remember that Fulcro won&#8217;t re-render a component unless its props change (they are all pure components). If you use
<code>(get-active-state)</code> from a UI then you are "grabbing data" without it going through props. In order to
get proper refreshes on a component whose UI depends on the current state you <strong>must</strong> query for that state machine&#8217;s
data.  Including the ident in your query is enough:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Component [this props]
  {<span class="symbol">:query</span> (<span class="keyword">fn</span> [] [ (uism/asm-ident <span class="symbol">::my-machine</span>) <span class="keyword">..</span><span class="keyword">.</span>])
   <span class="keyword">..</span><span class="keyword">.</span>}
  <span class="keyword">..</span><span class="keyword">.</span>
  (<span class="keyword">let</span> [s (get-active-state this <span class="symbol">::my-machine</span>)] <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mutations_and_state_machines"><a class="anchor" href="#_mutations_and_state_machines"></a><a class="link" href="#_mutations_and_state_machines">13.7. Mutations and State Machines</a></h3>
<div class="paragraph">
<p>Functions are included that allow you to trigger <strong>remote</strong> mutations.  Your state machine handlers are
already an implementation of the client side operations of a mutation, so really what we need is a way to trigger
a remote mutation and then trigger events based on the outcome.</p>
</div>
<div class="paragraph">
<p>The <code>trigger-remote-mutation</code> function does this. It takes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>env</code> - The SM handler environment</p>
</li>
<li>
<p><code>actor</code> - The name (keyword) of a defined actor.  The mutation will be run in the context of this actor&#8217;s state
(see <code>pm/pmutate!</code>), which means that progress will be visible there. THERE MUST BE A MOUNTED COMPONENT
with this actor&#8217;s name ON the UI, or the mutation will abort. This does <strong>not</strong> have to be the same
component as you&#8217;re (optionally) returning from the mutation itself. It is purely for progress UI.</p>
</li>
<li>
<p><code>mutation</code> - The symbol (or mutation declaration) of the <strong>server</strong> mutation to run. This function will <strong>not</strong> run a local
version of the mutation (nor do you have to write one).</p>
</li>
<li>
<p><code>options-and-params</code> - The parameters to pass to your mutation. This map can <strong>also</strong> include these additional
options (which will not show up in the remote and are namespaced to avoid collision):</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>::m/returning Class</code> </dt>
<dd>
<p>Indicate a return value of the remote mutation (for normalizing the returned result). If you
know the class you can use it. Use <code>(actor-class actor-name)</code> to get the correct class for an arbitrary actor, or
<code>(comp/registry-key&#8594;class component-fully-qualified-symbol)</code> to look a class up (for avoiding circular `require`s in Clojure).</p>
</dd>
<dt class="hdlist1"><code>::targeting/target explicit-target</code> </dt>
<dd>
<p>Option for targeting retuned result using data-targeting. Should be used with <code>::m/returning</code>.</p>
</dd>
<dt class="hdlist1"><code>::uism/target-actor actor</code> </dt>
<dd>
<p>Helper that can translate an actor name to a target, if returning a result.</p>
</dd>
<dt class="hdlist1"><code>::uism/target-alias field-alias</code> </dt>
<dd>
<p>Helper that can translate a data alias to a target (ident + field).</p>
</dd>
<dt class="hdlist1"><code>::uism/ok-event event-id</code> </dt>
<dd>
<p>The SM event to trigger when the pessimistic mutation succeeds (no default).</p>
</dd>
<dt class="hdlist1"><code>::uism/error-event event-id</code> </dt>
<dd>
<p>The SM event to trigger when the pessimistic mutation fails (no default).</p>
</dd>
<dt class="hdlist1"><code>::uism/ok-data map-of-data</code> </dt>
<dd>
<p>Data to include in the event-data on an ok event</p>
</dd>
<dt class="hdlist1"><code>::uism/error-data map-of-data</code> </dt>
<dd>
<p>Data to include in the event-data on an error event</p>
</dd>
<dt class="hdlist1"><code>::uism/mutation-remote</code> </dt>
<dd>
<p>The keyword name of the Fulcro remote (defaults to :remote)</p>
</dd>
</dl>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The mutation response follows the same rules as normal mutations (e.g. <code>default-result-action</code>). The result
will also be in the <code>::uism/event-data</code> under the <code>::uism/mutation-result</code> key so that
the <code>ok-event</code> and <code>error-event</code> handlers can simply look in event-data for the data sent back from the server.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In general you should use actors as the mechanism for obtaining a return type&#8217;s class, since that
will keep your state machine code decoupled from UI code.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_loads_and_state_machines"><a class="anchor" href="#_loads_and_state_machines"></a><a class="link" href="#_loads_and_state_machines">13.8. Loads and State Machines</a></h3>
<div class="paragraph">
<p>The API includes these functions for doing loads in the context of a running state
machine:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(load env k component-class params)</code></dt>
<dd>
<p>Just like Fulcro&#8217;s load, but takes a SM env. Typically you should
use <code>actor-class</code> or the component registry <code>comp/registry-key&#8594;class</code> to get the component class so you don&#8217;t couple
UI code into your machine.</p>
</dd>
<dt class="hdlist1"><code>(load-actor env actor-name params)</code></dt>
<dd>
<p>(Re)load the given actor.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>params</code> of these functions are the normal Fulcro <code>load!</code> options, but can include these additional special items:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>::uism/ok-event</code></dt>
<dd>
<p>An event to send when the load is done (instead of calling a mutation)</p>
</dd>
<dt class="hdlist1"><code>::uism/ok-event-data</code></dt>
<dd>
<p>Extra parameters to send as event-data on the post-event.</p>
</dd>
<dt class="hdlist1"><code>::uism/error-event</code></dt>
<dd>
<p>The event to send if the load triggers a fallback.</p>
</dd>
<dt class="hdlist1"><code>::uism/error-event-data</code></dt>
<dd>
<p>Extra parameters to send as event-data on a fallback.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>DEPRECATED (use the ok/error versions instead):
<code>::uism/post-event</code>:: An event to send when the load is done (instead of calling a mutation)
<code>::uism/post-event-params</code>:: Extra parameters to send as event-data on the post-event.
<code>::uism/fallback-event</code>:: The event to send if the load triggers a fallback.
<code>::uism/fallback-event-params</code>:: Extra parameters to send as event-data on a fallback.</p>
</div>
<div class="sect3">
<h4 id="_dynamic_actor_idents"><a class="anchor" href="#_dynamic_actor_idents"></a><a class="link" href="#_dynamic_actor_idents">13.8.1. Dynamic Actor Idents</a></h4>
<div class="paragraph">
<p>There are all sorts of situations where you may not know the ident of an actor when the machine is first
started, or perhaps the ident of an actor can change over time. The <code>reset-actor-ident</code> function
can be used to update an actor.</p>
</div>
<div class="paragraph">
<p>Say you start the machine like this, with a (made-up) <code>:none</code> marker as an ID.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(uism/begin! this person-editing-machine <span class="symbol">::personsm</span>
  {<span class="symbol">:actor/selected-person</span> (uism/with-actor-class [<span class="symbol">:person/id</span> <span class="symbol">:none</span>] Person)
   <span class="symbol">:actor/list</span>            [<span class="symbol">:person-list</span> <span class="symbol">:singleton</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can later set the actor&#8217;s ident like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="keyword">..</span><span class="keyword">.</span> <span class="comment">;; somewhere in the UI</span>
(uism/trigger! this <span class="symbol">::personsm</span> <span class="symbol">:event/person-selected</span> {<span class="symbol">:new-ident</span> [<span class="symbol">:person/id</span> <span class="integer">33</span>]})

<span class="keyword">..</span><span class="keyword">.</span>

<span class="comment">;; in the machine definition:</span>
<span class="symbol">:event/person-selected</span>
{<span class="symbol">::uism/handler</span> (<span class="keyword">fn</span> [{{<span class="symbol">:keys</span> [new-ident]} <span class="symbol">::uism/event-data</span> <span class="symbol">:as</span> env}]
                  (uism/reset-actor-ident env <span class="symbol">:actor/selected-person</span> new-ident))}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_timer_events"><a class="anchor" href="#_timer_events"></a><a class="link" href="#_timer_events">13.9. Timer Events</a></h3>
<div class="paragraph">
<p>Many UI interactions require some kind of timeout.  For example, you don&#8217;t want to issue a load on an
autocomplete search field until the user stops typing for 300ms, or perhaps you&#8217;d like to close a dialog and show
an error if a data load takes more than 5 seconds.</p>
</div>
<div class="paragraph">
<p>The <code>(uism/set-timeout env timer-id event-id event-data timeout cancel-on-events)</code> function can be used
in a handler to schedule a ms timer, where <code>timer-id</code> is a user-invented name for the timer (keyword),
the <code>event-id</code> is the invented keyword for the event you want to send, <code>event-data</code> is additional
data you&#8217;d like to send with the event, and <code>timeout</code> is in ms.</p>
</div>
<div class="paragraph">
<p>The <code>cancel-on-events</code> parameter is a function that will be sent the name of any event that occurs while the timeout is
waiting. If it returns <code>true</code> (not <code>false</code> or <code>nil</code>) then the timeout will be auto-cancelled.</p>
</div>
<div class="paragraph">
<p>You can cancel a timeout with `(uism/clear-timeout! env timer-id)</p>
</div>
</div>
<div class="sect2">
<h3 id="_sending_events_from_one_state_machine_to_another"><a class="anchor" href="#_sending_events_from_one_state_machine_to_another"></a><a class="link" href="#_sending_events_from_one_state_machine_to_another">13.10. Sending Events from one State Machine to Another</a></h3>
<div class="paragraph">
<p>The mechanism for sending events from one state machine to another
is the <code>trigger</code> method (with no <code>!</code>). This version takes and returns a handler <code>env</code>, and is composed
into the threading of <code>env</code> in your handlers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">fn</span> [env]
  (<span class="keyword">-&gt;</span> env
    (uism/trigger <span class="symbol">:state-machine-id</span> <span class="symbol">:event-id</span> {<span class="symbol">:data</span> <span class="symbol">:map</span>})
    <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This has the effect of queueing the event for after the current handler has finished.</p>
</div>
<div class="sect3">
<h4 id="_nested_event_order"><a class="anchor" href="#_nested_event_order"></a><a class="link" href="#_nested_event_order">13.10.1. Nested Event Order</a></h4>
<div class="paragraph">
<p>State machines that trigger events may cause handlers to run that themselves trigger further events.
The ordering of such a cascade will be that of function call semantics. That is to say that if state
machine A triggers an event on B and D, and B triggers an event on C, then the runtime evaluation
order will be A, B, C, D.</p>
</div>
</div>
<div class="sect3">
<h4 id="_leveraging_state_machine_local_storage"><a class="anchor" href="#_leveraging_state_machine_local_storage"></a><a class="link" href="#_leveraging_state_machine_local_storage">13.10.2. Leveraging State Machine Local Storage</a></h4>
<div class="paragraph">
<p>There are many times that you will want to send in "configuration" information to a state machine that
should be remembered ov the lifetime of that machine.  For example if you have code that triggers
events in other state machines you might want to pass the ID of the other state machine as a parameter when
you start the new one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(uism/begin! this SM <span class="symbol">::sm-id</span> actor-map {<span class="symbol">:other-machine</span> <span class="symbol">:machine-id</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then simply add a handler for the <code>::uism/started</code> event that extracts this data and stores it in the
state machine&#8217;s local store:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(uism/defstatemachine SM
  {<span class="keyword">..</span><span class="keyword">.</span>
   <span class="symbol">::uism/states</span>      {<span class="symbol">:initial</span>
                       {<span class="symbol">::uism/events</span>
                        {<span class="symbol">:uism/started</span>
                         {<span class="symbol">::uism/handler</span>
                          (<span class="keyword">fn</span> [{<span class="symbol">::uism/keys</span> [event-data] <span class="symbol">:as</span> env}]
                            (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [other-machine]} event-data]
                              (<span class="keyword">-&gt;</span> env
                                (uism/store <span class="symbol">:mid</span> other-machine))))}}}}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>That value is then available via <code>(uism/retrieve env key)</code> for the lifetime of that state machine.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_aborting_loads_and_mutations"><a class="anchor" href="#_aborting_loads_and_mutations"></a><a class="link" href="#_aborting_loads_and_mutations">13.11. Aborting Loads and Mutations</a></h3>
<div class="paragraph">
<p>The built-in Fulcro support for aborting network requests requires the use of the actual application.  The general
recommendation is to save your app into a <code>defonce</code> somewhere that can be required in any other file.</p>
</div>
<div class="paragraph">
<p>The state machine load/mutation system supports abort IDs by simply adding an <code>:abort-id</code> to the options map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(uism/load env <span class="symbol">::session</span> (uism/actor-class env <span class="symbol">:session</span>)
  {<span class="symbol">:abort-id</span>         <span class="symbol">:abort/session-load</span>
   <span class="symbol">::uism/post-event</span> <span class="symbol">:session-checked</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then explicitly cancel such a request in the normal way (via your app) inside of your state
machine handlers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="keyword">..</span><span class="keyword">.</span>
  <span class="symbol">::uism/handler</span>
    (<span class="keyword">fn</span> [env]
      (<span class="keyword">when</span> @my-app
        (app/abort-request! my-app <span class="symbol">:abort/session-load</span>))
      env)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>trigger-remote-mutation</code> function also support abort IDs using the <code>::txn/abort-id</code> key.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Aborting mutations is a risky business. Doing so leaves you in an unknown state since you don&#8217;t know how much
the server actually saw or did; also, aborting the network request usually does not affect the server processing once
the mutation has been sent.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_full_example"><a class="anchor" href="#_full_example"></a><a class="link" href="#_full_example">13.12. Full Example</a></h3>
<div class="paragraph">
<p>TODO: Embed live demo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parting_thoughts"><a class="anchor" href="#_parting_thoughts"></a><a class="link" href="#_parting_thoughts">13.13. Parting Thoughts</a></h3>
<div class="paragraph">
<p>This relatively small set of primitives gives you quite a bit of power.  Here are some things you
can do with this system that you might not immediately realize:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Associate Multiple Machines with a Control</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You might have a state machine that is interested in tracking something like the autocomplete status of a dropdown.
Another state machine could be tracking the overall state of the form that the autocomplete is embedded in.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Create a Library of Reusable Machines</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We&#8217;ve mentioned this, but it bears repeating.  Common patterns exist all over the place.</p>
</div>
<div class="paragraph">
<p>Take an autocomplete dropdown.  The behavior of waiting for some period of time between
keystrokes before issuing a load, cancelling a load if the user starts typing again,
showing/hiding the list of options and such can all be parameterized.  The loads <strong>load an
actor with parameters</strong>.  This means the actual query and results for the load portion
are controlled at <code>begin!</code>, not from within the state machine.  Various other aspects
are also easy to make "tunable" by using the state machine&#8217;s local storage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defstatemachine dropdown-autocomplete
  {<span class="symbol">::uism/actors</span> #{<span class="symbol">:dropdown-control</span> <span class="keyword">..</span><span class="keyword">.</span>}
   <span class="symbol">::uism/aliases</span> {<span class="symbol">:options-visible?</span> [<span class="symbol">:dropdown-control</span> <span class="symbol">:ui/show-options?</span>]
                   <span class="keyword">..</span><span class="keyword">.</span>}
   <span class="symbol">::uism/states</span>
     {<span class="symbol">:initial</span> {
       <span class="symbol">::uism/events</span> {<span class="symbol">::uism/started</span>
                       {<span class="symbol">::uism/handler</span> (<span class="keyword">fn</span> [{<span class="symbol">::uism/keys</span> [event-data] <span class="symbol">:as</span> env}]
                                         (uism/store env <span class="symbol">:params</span> event-data)
                                         <span class="keyword">..</span><span class="keyword">.</span>
<span class="keyword">..</span><span class="keyword">.</span>

(uism/begin! this dropdown-autocomplete <span class="symbol">:dropdown-car-make-sm</span>
  {<span class="symbol">:dropdown-control</span> (uism/with-actor-class [<span class="symbol">:dropdown/id</span> <span class="symbol">:car-make</span>] Dropdown))}
  {<span class="symbol">:dropdown-key-timeout</span> <span class="integer">200</span>})</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_form_validation"><a class="anchor" href="#_form_validation"></a><a class="link" href="#_form_validation">13.13.1. Form Validation</a></h4>
<div class="paragraph">
<p>My initial experiments lead me towards the opinion that form validation does not generally belong in a state
machine. Here are my reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rules around validation are often large and complex. This leads to a lot of states that become hard to follow.</p>
</li>
<li>
<p>The forms-state namespace in Fulcro does a nice job of tracking field state, letting you undo, diff, etc.  It
is much easier to "follow" validation at the UI layer, where it is also simpler to co-locate validity checks
and messages with fields.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, simple things like a login form might be ok to validate in the state machine, but larger forms should
probably localize validation to the form itself.</p>
</div>
<div class="paragraph">
<p>There is one element that you will often need <strong>within</strong> the state machine: whether or not the form <strong>is</strong>
currently valid.</p>
</div>
<div class="paragraph">
<p>Remember:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>env</code> in the state machine handler includes the current Fulcro state map as the key <code>::uism/state-map</code>.</p>
</li>
<li>
<p>You can use <code>fdn/db&#8594;tree</code> to convert a state map into a tree using a component&#8217;s class and ident.</p>
</li>
<li>
<p>You can get an actor&#8217;s component class with <code>uism/actor-class</code>.</p>
</li>
<li>
<p>You can get an actor&#8217;s ident with <code>uism/actor&#8594;ident</code>.</p>
</li>
<li>
<p>The form-state support in Fulcro can give you a validity check based on the form props.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also pass specific event data when you trigger events, so you can trigger your own state change events
(instead of using <code>uism/set-value!</code>) that include the current validity of the form.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dynamic_router"><a class="anchor" href="#_dynamic_router"></a><a class="link" href="#_dynamic_router">14. Dynamic Router</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The dynamic router in Fulcro 3 uses dynamic queries to change the route, and was designed with the following
requirements in mind:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Composition</dt>
<dd>
<p>Routers should compose in a flexible manner that includes the easy ability to refactor the application and restructure.</p>
</dd>
<dt class="hdlist1">There should be a way to complete network operations <strong>before</strong> moving to a given route</dt>
<dd>
<p>This should be a chain of operations that is derived from the target routers themselves (or their children?).</p>
</dd>
<dt class="hdlist1">UI Code should be able to prevent a route change</dt>
<dd>
<p>E.g. say there are unsaved changes on some page in a tree: a UI component must be able to "hook into" the routing system in order to prevent changes. NOTE: This is not a feature of the <strong>routers</strong>, but a feature of the <strong>content</strong> under a router.  This can be modelled as a global concern, since routing (esp. that involves URI changes) is a global concern.</p>
</dd>
<dt class="hdlist1">Code Splitting</dt>
<dd>
<p>A complete routing system for SPAs should make it easy to do code splitting at particular routes so that an initial load of the application need not load the code for every feature.</p>
</dd>
<dt class="hdlist1">DRY</dt>
<dd>
<p>It should not be necessary to repeat the "route path" as an external data structure when it matches the UI
structure. The UI composition itself can easily act as a "default" routing path structure.</p>
</dd>
<dt class="hdlist1">URI &lt;&#8658; UI Routes should be flexible and able to "alias"</dt>
<dd>
<p>Reshaping the URI can be done by optional functions that sit in-between browser URI and code.</p>
</dd>
<dt class="hdlist1">Navigable Code</dt>
<dd>
<p>During development it should be easy to see (as local concerns) what happens along a given UI route.  Code navigation (jumping from root through subcomponents) should make it trivial to understand all routing concerns. Route "operations" like loading should be co-located with the components that act as routing targets.</p>
</dd>
<dt class="hdlist1">Introspection</dt>
<dd>
<p>One should be able to query for the available routes (of loaded code), and the current visible route.</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_routers"><a class="anchor" href="#_routers"></a><a class="link" href="#_routers">14.1. Routers</a></h3>
<div class="paragraph">
<p>Dynamic routing in Fulcro can be easily facilitated by leveraging the UI query, which is a tool of composition that is always guaranteed to be present in a properly-structured application.  Each component&#8217;s state will be normalized, and the class and relative UI position can be determined by examining the current UI query.</p>
</div>
<div class="paragraph">
<p>Take the following UI layout:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/tree.png" alt="tree" width="970" height="392">
</div>
</div>
<div class="paragraph">
<p>The routers in this system can easily be autogenerated by a macro that is given nothing more than the classes of the components that are the targets of routing (i.e. User, Settings, etc.).  The macro can simply compose them together into a component that has a dynamic query whose "current route" points to the first class listed (marked with <code>D</code> in the diagram).  If the given router is to be shown on initial startup, then these default routing targets must be singletons (have an ident that does not depend on their props).</p>
</div>
<div class="paragraph">
<p>This delegates the novelty of routing targets to the <strong>target itself</strong>.  Interestingly, this is quite convenient for composition and refactoring.  The router is not programmed with any foreknowledge of the routing novelty of a target&#8230;&#8203;only it&#8217;s symbolic name!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defrouter RootRouter [this props]
  {<span class="symbol">:router-targets</span> [Settings User]})
(<span class="keyword">def</span> <span class="function">ui-root-router</span> (prim/factory RootRouter))

(defrouter SettingsRouter [this props]
  {<span class="symbol">:router-targets</span> [Pane1 Pane2]})
(<span class="keyword">def</span> <span class="function">ui-settings-router</span> (prim/factory SettingsRouter))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameter list (this and props) are used with deferred routing, explained below.</p>
</div>
<div class="paragraph">
<p>The use of query scanning and dynamic queries for routing mean that you can easily add or remove a sub-route just by moving the symbol to a different router.</p>
</div>
<div class="paragraph">
<p>Such routers are simple Fulcro components, and can be composed into the UI just like any other components. The initial state parameters passed to such a router are <strong>forwarded</strong> to the <strong>default</strong> (first listed) router target (if it has initial state).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Routers are true singletons. A router ends up with a dynamic query keyed by the class itself. This means that a given router cannot be used in a UI in more than one place. This seems like a reasonable restriction given that they are so simple to declare at a given tree (sub)root, and are typically very positional in nature.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_routing_targets"><a class="anchor" href="#_routing_targets"></a><a class="link" href="#_routing_targets">14.2. Routing Targets</a></h3>
<div class="paragraph">
<p>Most of the novelty about routes can now be encoded into normal components with simple declarations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app</span>
  (<span class="symbol">:require</span>
    <span class="keyword">..</span><span class="keyword">.</span>
    [fulcro.incubator.dynamic-routing <span class="symbol">:as</span> dr <span class="symbol">:refer</span> [defrouter]]))

(defsc X [this props]
 {<span class="keyword">..</span><span class="keyword">.</span>
  <span class="symbol">:route-segment</span>   [<span class="string"><span class="delimiter">&quot;</span><span class="content">path</span><span class="delimiter">&quot;</span></span>] <span class="comment">; the portions of the path that this component represents. typically just one, or one with params</span>
  <span class="symbol">:will-enter</span>      (<span class="keyword">fn</span> [app route-params] <span class="keyword">..</span><span class="keyword">.</span>defer <span class="keyword">or</span> immediate.<span class="keyword">..</span>)
  <span class="symbol">:route-cancelled</span> (<span class="keyword">fn</span> [route-params] <span class="keyword">..</span><span class="keyword">.</span>called <span class="keyword">if</span> deferred route to here is cancelled before it completes.<span class="keyword">..</span>)
  <span class="symbol">:will-leave</span>      (<span class="keyword">fn</span> [this props] <span class="keyword">..</span><span class="keyword">.</span>return <span class="predefined-constant">true</span> <span class="keyword">or</span> <span class="predefined-constant">false</span> to accept being removed from screen.<span class="keyword">..</span>)]}
 (dom/div <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>:route-segment</code></dt>
<dd>
<p>A (relative) path segment that this component can "consume" from an incoming route. This is purely static data. The current composition of routing targets in the UI determines the overall "absolute" path of a route. Each <code>router</code> in the UI should be thought of as a stand-in for a "/" in an HTML5 URI path.</p>
</dd>
<dt class="hdlist1"><code>:will-enter</code></dt>
<dd>
<p>A notification that this route target should be shown.  Can return a value indicating a desire to do so immediately, or that it would like a delay (for some I/O). This method is called <strong>before</strong> the component is on-screen, so it cannot receive a react component instance.  It is passed the app and router parameters which can be used to do things like issues loads and run mutations.</p>
</dd>
<dt class="hdlist1"><code>:route-cancelled</code></dt>
<dd>
<p>A notification that this route target was in a deferred state but the user made some other routing decision during that delay. This can be used to cancel heavy I/O operations for this target.</p>
</dd>
<dt class="hdlist1"><code>:will-leave</code></dt>
<dd>
<p>A method that can prevent a route change that causes this component to leave the screen. This is called on the instance, so <code>this</code> and <code>props</code> are available. A request to change routes will signal this method from deepest child towards the parent, and will stop if any returns false.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<code>will-enter</code> SHOULD NOT side-effect (order of operations could cause strange behavior), but must instead do
any I/O in the lambda passed to <code>route-deferred</code>.
It must also trigger the <code>dr/target-ready</code> mutation to indicate that the route is ready. You can use plain <code>transact!</code>
to start a mutation within route-deferred, and the mutation can use <code>target-ready!</code> to send the signal.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Route targets can be singletons or regular components that have multiple instances.  In the latter case you must be sure that
the ident returned from <code>will-enter</code> points to valid data in state by the time the route is resolved.</p>
</div>
</div>
<div class="sect2">
<h3 id="_initial_route"><a class="anchor" href="#_initial_route"></a><a class="link" href="#_initial_route">14.3. Initial Route</a></h3>
<div class="paragraph">
<p>The dynamic routing relies on a call to <code>change-route</code> in order to start the routing system.  Therefore you MUST make
a call to <code>change-route</code> on start in order for the dynamic routers to work; however, there is also the concern of what
gets rendered on the "first frame" of application mount.</p>
</div>
<div class="paragraph">
<p>Your top-most router will be in an "uninitialized" state on initial load. You can use the body of that router to
render the "first frame" of your mounted app:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defrouter RootRouter2 [this props]
  {<span class="symbol">:router-targets</span>     [Settings User]}
  (<span class="keyword">case</span> current-state
    <span class="symbol">:pending</span> (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>)
    <span class="symbol">:failed</span> (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed!</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">;; default will be used when the current state isn't yet set</span>
    (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">No route selected.</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are doing SSR, then you will need to simulate calling <code>change-route</code> there.  The function
<code>dr/ssr-initial-state</code> (written, but untested) can be used to help you construct the proper state for a given path (which must be used
for the server-side render, and also as the initial state for the client). Technically, this means that the
function can also be used to generate initial state for the client on the front-end as well.</p>
</div>
</div>
<div class="sect2">
<h3 id="_route_segments_and_changing_routes"><a class="anchor" href="#_route_segments_and_changing_routes"></a><a class="link" href="#_route_segments_and_changing_routes">14.4. Route Segments and Changing Routes</a></h3>
<div class="paragraph">
<p>UI Composition determines the available routes, and each route target must declare what part of the current "route" they can consume.  The declaration is a vector of literal strings and keywords:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span> <span class="symbol">:user-id</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Strings in the route segment <strong>MUST</strong> exactly match an incoming path prefix or the route does not match.  The keyword parameters are <strong>route parameters</strong>, and <strong>capture</strong> the incoming route element <strong>as a string</strong> (this ensures that URI&#8217;s will work just as well as code-based paths that might contain other data types).  Any data types you pass in the vector are converted via <code>str</code>, so if you need a
more complicated coercion please do it before using it to change the route.</p>
</div>
<div class="paragraph">
<p>Path segments compose in the UI. In our earlier diagram the <code>Settings</code> component might have the route segments: <code>["settings"]</code> and the <code>User</code> component <code>["user" :user-id]".  The `Pane2</code> component might list <code>["pane1"]</code>.  Now, since the pane 1 component is currently <strong>nested</strong> as a target of the router underneath the settings component, we can derive that the <strong>full path</strong> to Pane 1 in <strong>this</strong> particular UI layout is <code>["settings" "pane1"]</code>. This is the next critical step in our composition:  Routers in a tree look for targets that can consume <strong>what remains</strong> of the path after parent targets have <strong>consumed</strong> the portion that matched those route segments.</p>
</div>
<div class="paragraph">
<p>Hopefully you can see how this directly matches the necessary logic for HTML5 URI routing.  The following URIs are trivial to convert between the two forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="string"><span class="delimiter">&quot;</span><span class="content">/settings/pane1</span><span class="delimiter">&quot;</span></span>  <span class="keyword">&lt;=</span>=&gt;  [<span class="string"><span class="delimiter">&quot;</span><span class="content">settings</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">pane1</span><span class="delimiter">&quot;</span></span>]
<span class="string"><span class="delimiter">&quot;</span><span class="content">/user/1</span><span class="delimiter">&quot;</span></span>          <span class="keyword">&lt;=</span>=&gt;  [<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This mechanism makes routing as simple as "read the URI, split the string, and call a function".</p>
</div>
<div class="paragraph">
<p>The function to cause a route change is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(dr/change-route this [<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>])</code></pre>
</div>
</div>
<div class="paragraph">
<p>and it <strong>always</strong> starts from the root of your application and causes a full update of the correct route.</p>
</div>
<div class="paragraph">
<p>Notice that since the command to control the route is up to you, so is the path you pass to it. This makes it easy to do things like alias one path found in the URI to a different UI path, which is useful when you restructure the real UI but would like to maintain support for old paths that users may have bookmarked.</p>
</div>
<div class="paragraph">
<p>Additional useful functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(current-route component-or-reconciler starting-component)</code></dt>
<dd>
<p>Returns a vector of the path components on the current (live) route starting at the given <code>starting-component</code>. If you use your root component it will be the absolute path, and using some other component router will give the relative path from there.</p>
</dd>
<dt class="hdlist1"><code>(change-route-relative this-or-reconciler relative-class-or-instance new-route timeouts)</code></dt>
<dd>
<p>Just like <code>change-route</code>, but can take a relative <code>new-route</code> and apply it starting and the given <code>relative-class-or-instance</code>. Thus, some module of a program can route in a relative manner which will further decouple the components, making it easier to use a module in a development card or refactor it to a different location in the app without breaking local concerns.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This library will not have any code that connects HTML5 routing events to UI routing.  That is a relatively simple exercise and there are plenty of libraries that can help with the task.  The logic of transforming a URI to the correct vector and calling a function is trivial, and the concern of aliasing and legacy path transforms is something you will likely want to put in the middle of that.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_aborting_a_route_change"><a class="anchor" href="#_aborting_a_route_change"></a><a class="link" href="#_aborting_a_route_change">14.5. Aborting a Route Change</a></h3>
<div class="paragraph">
<p>The <code>:will-leave</code> is called when a target is going to leave the screen, and may return false.
If it does so AND is active on the screen then it prevents the entire route change.  This allows a screen to hold up
routing in case edits would be lost, etc.  Of course you should do something in this method to change the UI so the
user knows what is going on.  This is a non-static method and receives the component, so it can <code>transact!</code>, etc.</p>
</div>
<div class="paragraph">
<p>TODO: Probably needs more parameters, such as the "route being attempted" in case the component wants to save it
for a later "continue" operation (e.g. "Are You Sure?", "Yes").</p>
</div>
</div>
<div class="sect2">
<h3 id="_deferred_routing"><a class="anchor" href="#_deferred_routing"></a><a class="link" href="#_deferred_routing">14.6. Deferred Routing</a></h3>
<div class="paragraph">
<p>There are times when you want to delay a route change based on some I/O operation, like a load or mutation.  A router can do this via the return value of the <code>will-enter</code> method:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(df/route-deferred ident f)</code></dt>
<dd>
<p>Record the fact that the route wants to change, but don&#8217;t actually apply it. The ident passed should be the ident of the component that should be routed to (of the current type).
The function <code>f</code> will be called to allow you to issue instructions that will complete the route.</p>
</dd>
<dt class="hdlist1"><code>(df/route-immediate ident)</code></dt>
<dd>
<p>Immediately apply the route for this router.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Of course you should not do immediate routing if the ident you&#8217;re returning does not point to something that already exists in the database.  Perhaps you need to load it.</p>
</div>
<div class="paragraph">
<p>Pending routes can be completed by calling the <code>dr/target-ready</code> mutation with a <code>target</code> parameter that matches the
<code>ident</code> you passed with <code>route-deferred</code>.  For example, say you wanted to load a user before routing to them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc User [this props]
  {<span class="symbol">:query</span>     [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span>]
   <span class="symbol">:ident</span>     [<span class="symbol">:user/id</span> <span class="symbol">:user/id</span>]
   <span class="symbol">:route-segment</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span> <span class="symbol">:user-id</span>])
   <span class="symbol">:route-cancelled</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [user-id]}] (my-abort-load (<span class="keyword">keyword</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span> user-id)))
   <span class="symbol">:will-enter</span>      (<span class="keyword">fn</span> [app {<span class="symbol">:keys</span> [user-id]}]
                      (<span class="keyword">when-let</span> [user-id (some-&gt; user-id (js/parseInt))]
                        (dr/route-deferred
                          [<span class="symbol">:user/id</span> user-id]
                          #(df/load app [<span class="symbol">:user/id</span> user-id] User {<span class="symbol">:post-mutation</span>        `dr/target-ready
                                                                 <span class="symbol">:post-mutation-params</span> {<span class="symbol">:target</span> [<span class="symbol">:user/id</span> user-id]}}))))]
  (dom/div <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the route parameters come in via a map keyed by the keyword in your <code>route-segment</code>. Remember that the value
of these elements is guaranteed to be a string, so be sure you coerce them if you need them to be a different type.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The <code>will-enter</code> method <strong>MUST</strong> return the value of a call to either <code>route-immediate</code> or <code>route-deferred</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_target_ready_within_mutations"><a class="anchor" href="#_target_ready_within_mutations"></a><a class="link" href="#_target_ready_within_mutations">14.6.1. Target Ready within Mutations</a></h4>
<div class="paragraph">
<p>The mutation <code>target-ready</code> is meant for use with loads as a post-mutation.  The assumption is that there will be
some natural delay before it is called.</p>
</div>
<div class="paragraph">
<p>If you need to signal that a target is ready from within a mutation (instead of in the lambda of the
<code>route-deferred</code>), please use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation do-stuff-and-finish-routing [params]
  (action [{<span class="symbol">:keys</span> [app]}]
    (dr/target-ready! app ident-of-target)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>earlier versions had a mutation helper, but that is insufficient in this case and that helper was useless (and
it was removed).</p>
</div>
</div>
<div class="sect3">
<h4 id="_router_rendering_of_a_deferred_ui"><a class="anchor" href="#_router_rendering_of_a_deferred_ui"></a><a class="link" href="#_router_rendering_of_a_deferred_ui">14.6.2. Router Rendering of a Deferred UI</a></h4>
<div class="paragraph">
<p>The router uses a state machine internally and sets two timeouts with respect to deferred routes: and <code>:error-timeout</code>, and a
<code>:deferred-timeout</code> (which can be sent with your calls to <code>change-route</code>).  The error timeout is how long a route can be
deferred before it moves to the <code>:failed</code> state, and the deferred timeout is how long a route can be deferred before
it moves to a <code>:pending</code> state.</p>
</div>
<div class="paragraph">
<p>The router can be defined with custom UI for these various states using the <code>defrouter</code> macro, which looks much like
<code>defsc</code>, but only allows <code>:router-targets</code> in the options map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defrouter MyRouter [this {<span class="symbol">:keys</span> [current-state pending-path-segment route-factory route-props]}]
  {<span class="symbol">:router-targets</span> [A B C]}
  (<span class="keyword">case</span> current-state
    <span class="symbol">:initial</span> (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">What to show when the router is on screen but has never been asked to route</span><span class="delimiter">&quot;</span></span>)
    <span class="symbol">:pending</span> (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>)
    <span class="symbol">:failed</span> (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Oops</span><span class="delimiter">&quot;</span></span>)}))</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If you do not specify a body for the <code>defrouter</code> (e.g. <code>(defrouter A [_ _] {:router-targets [X Y]})</code>), then it
will render whatever route is currently active instead of this "alternate" context-sensitive UI.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>this</code> <strong>is</strong> a real Fulcro component instance and turns into a <code>defsc</code>, but the body is only rendered in the
initial/pending/failure states to do whatever you deem necessary. The options map will be passed through to defsc (though query/ident/protocols/initial-state will be overridden), so you can define React lifecycle methods and such if that is useful for your particular use-case. See the next section for critical notes, though.</p>
</div>
<div class="paragraph">
<p>The incoming props are actually generated to include a number of useful things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:current-state</code> - The current (<strong>transitory</strong>) state of the router (:initial, :pending, or :failed)</p>
</li>
<li>
<p><code>:pending-path-segment</code> - Where the router is trying to go in the :pending and :failed state. This will be the
concrete path segment that was requested (e.g. <code>["user" "1"]</code> and not <code>["user" :user/id]</code>).</p>
</li>
<li>
<p><code>:route-props</code> - The props for the current (old, non-pending) route (if there was a route on-screen).</p>
</li>
<li>
<p><code>:route-factory</code> - The function to call to render the current (old, non-pending) route (if there was a route on-screen).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The route factory/props are useful if you want to continue to render the "current" page even though a timeout has
occurred, but perhaps you want to pass some computed data to indicate progress
(e.g. <code>(route-factory (prim/computed route-props {:waiting true}))</code>).  Of course, you can
instead <code>route-immediate</code>, skip timeouts altogether, and do normal load markers on the target screen. The former
method is useful on a deferred route that simply has nothing to render until the data is present.  Regular named
load markers are also a good way of giving user feedback.</p>
</div>
<div class="paragraph">
<p>You can specify overrides for the default timeouts when you call <code>change-route</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(change-route this [<span class="string"><span class="delimiter">&quot;</span><span class="content">new</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">path</span><span class="delimiter">&quot;</span></span>] {<span class="symbol">:error-timeout</span> <span class="integer">2000</span> <span class="symbol">:deferred-timeout</span> <span class="integer">200</span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>They default to 5000ms and 100ms.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
A deferred route that resolves after an error timeout <strong>can still auto-recover</strong> if <code>target-ready</code> is called
  after the error timeout (it will move to the correct resolved route and stop showing the error).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
A request to change the route when a deferred route was in progress will cancel the timeouts and immediately attempt
the new route.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_router_react_lifecycle_methods"><a class="anchor" href="#_router_react_lifecycle_methods"></a><a class="link" href="#_router_react_lifecycle_methods">Router React Lifecycle Methods</a></h5>
<div class="paragraph">
<p>The props seen in react lifecycles will <strong>not</strong> be what you see in the props of the router body.  The props of the router body are synthesized for your convenience, but raw react lifecycles will see the low-level internal props of the router instead. The id of the router is the same as the ID for the router&#8217;s UI state machine. Using <code>uism/current-state</code> on that ASM will give you the current route state, and looking in that ASM&#8217;s local store will give you things like the pending segment. The ID of the active state machine will be
the keyword name of the router:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defrouter MyRouter [this props]
  {<span class="symbol">:router-target</span> <span class="keyword">..</span><span class="keyword">.</span>
   <span class="symbol">:componentDidUpdate</span> (<span class="keyword">fn</span> [this pprops pstate]
      (<span class="keyword">let</span> [current-state (uism/current-state this <span class="symbol">:MyRouter</span>)
            route-props (<span class="symbol">:fulcro.incubator.dynamic-routing/current-route</span> pprops)]
         <span class="keyword">..</span><span class="keyword">.</span>))
   <span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_code_splitting"><a class="anchor" href="#_code_splitting"></a><a class="link" href="#_code_splitting">14.6.3. Code Splitting</a></h4>
<div class="paragraph">
<p>The route defer mechanism should be sufficient to implement code splitting, where the routing target is the
"join point" for the dynamic code.  Basically the component would not include the code-split child in the query or UI
initially, but could trigger a code load and defer routing (storing the ident in a place where the loaded code could
trigger the completion of the route, and a dynamic query change of the original component to point to the newly loaded
component).</p>
</div>
<div class="paragraph">
<p>Something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc CodeSplit [this props]
  {<span class="symbol">:ident</span>     (<span class="keyword">fn</span> [] [<span class="symbol">:CodeSplit</span> <span class="integer">1</span>])     <span class="comment">; constant ident</span>
   <span class="symbol">:query</span>     [{<span class="symbol">:loaded-component</span> ['<span class="keyword">*</span>]}] <span class="comment">; a placeholder join. Set dynamically after code load</span>
   <span class="symbol">:initial-state</span> {<span class="symbol">:loaded-component</span> {}} <span class="comment">; placeholder state data</span>
   <span class="symbol">:will-enter</span> (<span class="keyword">fn</span> [app route-params]
                 (dr/route-deferred [<span class="symbol">:CodeSplit</span> <span class="integer">1</span>]
                   (<span class="keyword">fn</span> []
                     (loader/load <span class="symbol">:module</span>)
                     <span class="comment">;; the loaded code would issue a target-ready mutation once loaded</span>
                     <span class="comment">;; the loaded code would also use set-query to change the query of CodeSplit</span>
                     )))}
   <span class="keyword">..</span><span class="keyword">.</span>
   <span class="comment">;; The DOM can use the component registry to find the component that should be rendered</span>
   (<span class="keyword">when-let</span> [cls (comp/registry-key-&gt;class <span class="symbol">:some.loaded.ns/Component</span>)
              factory (comp/factory cls)]
      (factory loaded-component)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO: A dynamic code load means that there may be path segments in the current route that cannot be evaluated until the code load is complete.  It may be necessary to "re-trigger" a route after a code load to ensure that the path segments have been fully evaluated.  This would be a good use of a relative change route function, which could be run on the newly-loaded sub-components with the remaining path.  I think it should be relatively easy to just defer the rest of the sub-routing until the given route is resolved&#8230;&#8203;that is probably best, as it doesn&#8217;t require user intervention. The problem with that is that sub-routes may also want to queue I/O, and getting it all queued at once might be preferable to delaying. We could support something like <code>route-blocked</code> which would resume routing after the ready signal, and allow the <code>route-deferred</code> to continue down the route resolving sub-paths and queuing I/O.  Undecided.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_live_router_example"><a class="anchor" href="#_live_router_example"></a><a class="link" href="#_live_router_example">14.7. Live Router Example</a></h3>
<div class="paragraph">
<p>The router example below uses our people server to demonstrate the various concepts
covered in this chapter. It loads people by ID (the buttons could be HTML URL segments). If
the loading is slow, it shows a load marker. If the route changes before the user is loaded
then a proper console message prints to show you that you could have handled that to
cancel network operations.</p>
</div>
<div class="paragraph">
<p>Make sure you use the server controls in the upper-right corner to see the difference between a fast server (under 100ms) and a slow one. Also be sure to crank it up to a large number so you can try moving to a different route while the user is loading.</p>
</div>
<div class="paragraph">
<p>Finally, the <code>Person</code> route includes a checkbox that you can check. When checked the
<code>Person</code> component will prevent all route changes to simulate what you might
want to do in a dirty form situation.</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. <a id="DynamicRouter"></a><a href="#DynamicRouter">Dynamic Router Example</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('dynamic-router-example')">Focus Inspector</button>
<div class="short narrow example" id="dynamic-router-example"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.dynamic-router-example</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.routing.dynamic-routing <span class="symbol">:as</span> dr <span class="symbol">:refer</span> [defrouter]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [taoensso.timbre <span class="symbol">:as</span> log]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]))

(defsc Settings [this props]
  {<span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:component/id</span> <span class="symbol">::settings</span>])
   <span class="symbol">:query</span>         [<span class="symbol">:settings</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:settings</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">stuff</span><span class="delimiter">&quot;</span></span>}
   <span class="symbol">:route-segment</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">settings</span><span class="delimiter">&quot;</span></span>]
   <span class="symbol">:will-enter</span>    (<span class="keyword">fn</span> [app route-params]
                    (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Will enter settings with route params </span><span class="delimiter">&quot;</span></span> route-params)
                    (dr/route-immediate [<span class="symbol">:component/id</span> <span class="symbol">::settings</span>]))
   <span class="symbol">:will-leave</span>    (<span class="keyword">fn</span> [this props]
                    (js/console.log (comp/get-ident this) <span class="string"><span class="delimiter">&quot;</span><span class="content">props</span><span class="delimiter">&quot;</span></span> props)
                    <span class="predefined-constant">true</span>)}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Settings</span><span class="delimiter">&quot;</span></span>))

(defsc Person [this {<span class="symbol">:ui/keys</span>      [modified?]
                     <span class="symbol">:person/keys</span>  [id <span class="keyword">name</span>]
                     <span class="symbol">:address/keys</span> [city state]
                     <span class="symbol">:as</span>           props}]
  {<span class="symbol">:query</span>           [<span class="symbol">:ui/modified?</span> <span class="symbol">:person/id</span> <span class="symbol">:person/name</span> <span class="symbol">:address/city</span> <span class="symbol">:address/state</span>]
   <span class="symbol">:ident</span>           <span class="symbol">:person/id</span>
   <span class="symbol">:route-segment</span>   [<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/id</span>]
   <span class="symbol">:route-cancelled</span> (<span class="keyword">fn</span> [{<span class="symbol">:person/keys</span> [id]}]
                      (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Routing cancelled to user </span><span class="delimiter">&quot;</span></span> id))
   <span class="symbol">:will-leave</span>      (<span class="keyword">fn</span> [this {<span class="symbol">:ui/keys</span> [modified?]}]
                      (<span class="keyword">when</span> modified?
                        (js/alert <span class="string"><span class="delimiter">&quot;</span><span class="content">You cannot navigate until the user is not modified!</span><span class="delimiter">&quot;</span></span>))
                      (<span class="keyword">not</span> modified?))
   <span class="symbol">:will-enter</span>      (<span class="keyword">fn</span> [app {<span class="symbol">:person/keys</span> [id] <span class="symbol">:as</span> route-params}]
                      (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Will enter user with route params </span><span class="delimiter">&quot;</span></span> route-params)
                      <span class="comment">;; be sure to convert strings to int for this case</span>
                      (<span class="keyword">let</span> [id (<span class="keyword">if</span> (<span class="keyword">string?</span> id) (js/parseInt id) id)]
                        (dr/route-deferred [<span class="symbol">:person/id</span> id]
                          #(df/load app [<span class="symbol">:person/id</span> id] Person
                             {<span class="symbol">:post-mutation</span> `dr/target-ready
                              <span class="symbol">:post-mutation-params</span>
                                             {<span class="symbol">:target</span> [<span class="symbol">:person/id</span> id]}}))))}
  (dom/div
    (dom/h3 (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Person </span><span class="delimiter">&quot;</span></span> id))
    (dom/div (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content"> from </span><span class="delimiter">&quot;</span></span> city <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> state))
    (dom/div
      (dom/input {<span class="symbol">:type</span>     <span class="string"><span class="delimiter">&quot;</span><span class="content">checkbox</span><span class="delimiter">&quot;</span></span>
                  <span class="symbol">:onChange</span> (<span class="keyword">fn</span> []
                              (m/toggle! this <span class="symbol">:ui/modified?</span>))
                  <span class="symbol">:checked</span>  (<span class="keyword">boolean</span> modified?)})
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Modified (prevent routing)</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person {<span class="symbol">:keyfn</span> <span class="symbol">:person/id</span>}))

(defsc Main [this props]
  {<span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:component/id</span> <span class="symbol">::main</span>])
   <span class="symbol">:query</span>         [<span class="symbol">:main</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:main</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">stuff</span><span class="delimiter">&quot;</span></span>}
   <span class="symbol">:route-segment</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>]
   <span class="symbol">:will-enter</span>    (<span class="keyword">fn</span> [app route-params]
                    (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Will enter main</span><span class="delimiter">&quot;</span></span> route-params)
                    (dr/route-immediate [<span class="symbol">:component/id</span> <span class="symbol">::main</span>]))
   <span class="symbol">:will-leave</span>    (<span class="keyword">fn</span> [this props]
                    (log/info (comp/get-ident this) <span class="string"><span class="delimiter">&quot;</span><span class="content">props</span><span class="delimiter">&quot;</span></span> props)
                    <span class="predefined-constant">true</span>)}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Main</span><span class="delimiter">&quot;</span></span>))

(defrouter TopRouter [this {<span class="symbol">:keys</span> [current-state pending-path-segment]}]
  {<span class="symbol">:router-targets</span> [Main Settings Person]}
  (<span class="keyword">case</span> current-state
    <span class="symbol">:pending</span> (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>)
    <span class="symbol">:failed</span> (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading seems to have failed. Try another route.</span><span class="delimiter">&quot;</span></span>)
    (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown route</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-top-router</span> (comp/factory TopRouter))

(defsc Root [this {<span class="symbol">:root/keys</span> [router]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:root/router</span> (comp/get-query TopRouter)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:root/router</span> {}}}
  (dom/div
    (dom/button {<span class="symbol">:onClick</span> #(dr/change-route this [<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Go to main</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(dr/change-route this [<span class="string"><span class="delimiter">&quot;</span><span class="content">settings</span><span class="delimiter">&quot;</span></span>])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Go to settings</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(dr/change-route this [<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Go to person 1</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(dr/change-route this [<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Go to person 2</span><span class="delimiter">&quot;</span></span>)
    (ui-top-router router)))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fulcro_and_graphql"><a class="anchor" href="#_fulcro_and_graphql"></a><a class="link" href="#_fulcro_and_graphql">15. Fulcro and GraphQL</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>GraphQL is rapidly becoming the standard for writing graph-based servers.  As a result there are many existing
ways to deploy such an API, and many businesses have decided that their back-end will simply use the
standard.  There are BaaS (back-end as a service) providers that also let you quickly define and
deploy a GraphQL API.</p>
</div>
<div class="paragraph">
<p>All of this makes GraphQL an attractive server-side solution for Fulcro.</p>
</div>
<div class="paragraph">
<p>Luckily, <a href="https://github.com/wilkerlucio/pathom">Pathom</a> has all of the tools necessary to make this integration
simple and easy!</p>
</div>
<div class="paragraph">
<p>You can see some of it in action in <a href="https://youtu.be/Yk7xFry0w2Y">one of the Fulcro video series</a>, and read about
configuring it in the <a href="https://wilkerlucio.github.io/pathom/#GraphQL">Pathom Documentation</a>.</p>
</div>
<div class="paragraph">
<p>The simplest integration is to simply use Pathom&#8217;s GraphQL remote:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app</span>
  (<span class="symbol">:require</span>
    <span class="keyword">..</span><span class="keyword">.</span>
    [com.wsscode.pathom.fulcro.network <span class="symbol">:as</span> pfn]))

(<span class="keyword">def</span> <span class="function">client</span> (fulcro/make-fulcro-client
              {<span class="symbol">:networking</span> {<span class="symbol">:remote</span> (pfn/graphql-network
                                      {<span class="symbol">::pfn/url</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://api.github.com/graphql?access_token=</span><span class="delimiter">&quot;</span></span> token)})}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The more powerful and extensible method allows you to combine GraphQL access with Pathom Connect.  This gives
you very powerful features, including many useful ones that GraphQL doesn&#8217;t support natively!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="DynamicQueries"><a class="anchor" href="#DynamicQueries"></a><a class="link" href="#DynamicQueries">16. Dynamic Queries</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fulcro supports dynamic queries: the ability the change the query of a component at runtime. This feature is fully
serializable (works with the support viewer and other time-travel features), and is necessary for code splitting since
the parent component won&#8217;t be able to compose in the child&#8217;s query until it is loaded.</p>
</div>
<div class="sect2">
<h3 id="_query_ids"><a class="anchor" href="#_query_ids"></a><a class="link" href="#_query_ids">16.1. Query IDs</a></h3>
<div class="paragraph">
<p>For dynamic queries to work right they have to be stored in your application database and every aspect of them must
be serializable. Additionally, the UI must be able to look them up at the component level in order to do optimal refresh.
The solution to this is query IDs. A query ID is a simple combination of the component&#8217;s fully-qualified class name
combined with a user-defined qualifier (which defaults to the empty string).</p>
</div>
<div class="paragraph">
<p>Since this qualifier is needed both in the code that obtains queries (<code>get-query</code>) and in the UI rendering (the factory
that draws that component), it is easiest to locate the qualifier in the UI factory itself. This allows you
to have instances of a class that can have different queries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Thing <span class="keyword">..</span><span class="keyword">.</span>)
(<span class="keyword">def</span> <span class="function">ui-thing</span> (comp/factory Thing)) <span class="comment">; query ID is based solely on the class itself (with no qualifier)</span>
(<span class="keyword">def</span> <span class="function">ui-thing-1</span> (comp/factory Thing {<span class="symbol">:qualifier</span> <span class="symbol">:a</span>})) <span class="comment">; query ID is derived from Thing plus the qualifier :a</span>

(defsc Parent [this props]
  {<span class="symbol">:query</span> (<span class="keyword">fn</span> [] [{<span class="symbol">:child</span> (comp/get-query ui-thing-1)}])}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example one can now set the query for <code>Thing</code>, or &#8220;Thing` with qualifier `:a&#8221;.</p>
</div>
<div class="paragraph">
<p>The following live demo shows dynamic queries in action:</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. <a id="DynamicQuery"></a><a href="#DynamicQuery">Dynamic Query</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('dynamic-queries')">Focus Inspector</button>
<div class="short narrow example" id="dynamic-queries"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.queries.dynamic-queries</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [goog.object]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]))

(<span class="keyword">declare</span> <span class="function">ui-leaf</span>)

<span class="comment">; This component allows you to toggle the query between [:x] and [:y]</span>
(defsc Leaf [this {<span class="symbol">:keys</span> [x y]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:x</span> <span class="integer">1</span> <span class="symbol">:y</span> <span class="integer">42</span>})
   <span class="symbol">:query</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:x</span>])                              <span class="comment">; avoid error checking so we can destructure both :x and :y in props</span>
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:LEAF</span> <span class="symbol">:ID</span>])}                      <span class="comment">; there is only one leaf in app state</span>
  (dom/div
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [] (comp/set-query! this ui-leaf {<span class="symbol">:query</span> [<span class="symbol">:x</span>]}))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Set query to :x</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [] (comp/set-query! this ui-leaf {<span class="symbol">:query</span> [<span class="symbol">:y</span>]}))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Set query to :y</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">; If the query is [:x] then x will be defined, otherwise it will not.</span>
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [e] (<span class="keyword">if</span> x
                                    (m/set-value! this <span class="symbol">:x</span> (<span class="keyword">inc</span> x))
                                    (m/set-value! this <span class="symbol">:y</span> (<span class="keyword">inc</span> y))))}
      (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Count: </span><span class="delimiter">&quot;</span></span> (<span class="keyword">or</span> x y)))                             <span class="comment">; only one will be defined at a time</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content"> Leaf</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">def</span> <span class="function">ui-leaf</span> (comp/factory Leaf {<span class="symbol">:qualifier</span> <span class="symbol">:x</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [root/leaf] <span class="symbol">:as</span> props}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {<span class="symbol">:root/leaf</span> (comp/get-initial-state Leaf {})})
   <span class="symbol">:query</span>         (<span class="keyword">fn</span> [] [{<span class="symbol">:root/leaf</span> (comp/get-query ui-leaf)}])}
  (dom/div (ui-leaf leaf)))</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 36. <a id="DynamicQueryParameters"></a><a href="#DynamicQueryParameters">Dynamic Query Parameters</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('dynamic-query-parameters')">Focus Inspector</button>
<div class="short narrow example" id="dynamic-query-parameters"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.queries.dynamic-query-parameters</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [goog.object]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]))

<span class="comment">; This component has a query parameter that can be set to whatever we want dynamically</span>
(defsc Leaf [this {<span class="symbol">:keys</span> [x y] <span class="symbol">:as</span> props}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:x</span> <span class="integer">1</span> <span class="symbol">:y</span> <span class="integer">99</span>})
   <span class="symbol">:query</span>         (<span class="keyword">fn</span> [] '[<span class="symbol">:x</span> ?additional-stuff])           <span class="comment">; the parameter ?additional-stuff starts out empty</span>
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:LEAF</span> <span class="symbol">:ID</span>])}
  (dom/div
    (dom/button  {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [] (comp/set-query! this Leaf {<span class="symbol">:params</span> {<span class="symbol">:additional-stuff</span> <span class="symbol">:y</span>}}))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Add :y to query</span><span class="delimiter">&quot;</span></span>)
    (dom/button  {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [] (comp/set-query! this Leaf {<span class="symbol">:params</span> {}}))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Drop :y from query</span><span class="delimiter">&quot;</span></span>)
    (dom/ul
      (dom/li  <span class="string"><span class="delimiter">&quot;</span><span class="content">x: </span><span class="delimiter">&quot;</span></span> x)
      (dom/li  <span class="string"><span class="delimiter">&quot;</span><span class="content">y: </span><span class="delimiter">&quot;</span></span> y))))

(<span class="keyword">def</span> <span class="function">ui-leaf</span> (comp/factory Leaf))

(defsc Root [this {<span class="symbol">:keys</span> [root/leaf] <span class="symbol">:as</span> props}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {<span class="symbol">:root/leaf</span> (comp/get-initial-state Leaf {})})
   <span class="symbol">:query</span>         (<span class="keyword">fn</span> [] [{<span class="symbol">:root/leaf</span> (comp/get-query ui-leaf)}])}
  (dom/div  (ui-leaf leaf)))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_setting_a_query"><a class="anchor" href="#_setting_a_query"></a><a class="link" href="#_setting_a_query">16.2. Setting a Query</a></h3>
<div class="paragraph">
<p>The whole point of a dynamic query is being able to set the query to something new on a component.  This has one
critical component that you must be very careful with: normalization.  A component&#8217;s query is augmented with metadata
the marks which component is used to normalize (via idents) the entity found for the given portion of the query that
it handles.  Therefore, you must still use <code>get-query</code> to pull the query for portions of your subquery that you wish
to include when setting a new query.  If done incorrectly then normalization will not
work correctly on these components.</p>
</div>
<div class="paragraph">
<p>The top-level metadata will be added for you, so this is fine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation change-a-query [_]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state comp/set-query* B {<span class="symbol">:query</span> [<span class="symbol">:MODIFIED</span>]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>but as soon as there&#8217;s a join you must ensure the subqueries have the correct metadata.  This means that the following is
<strong>incorrect</strong> (because <code>[:x]</code> probably goes with some other normalized component):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation change-a-query [_]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state comp/set-query* B {<span class="symbol">:query</span> [<span class="symbol">:MODIFIED</span> {<span class="symbol">:subquery</span> [<span class="symbol">:x</span>]}]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>instead, you should use <code>get-query</code> with a state parameter to pull the query for a given component.  So, say you
wanted to change the query for this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc X [_ _]
  {<span class="symbol">:query</span> [<span class="symbol">:id</span> <span class="symbol">:name</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:x/id</span> <span class="symbol">:id</span>]})

(defsc A [_ _]
  {<span class="symbol">:query</span> [<span class="symbol">:id</span> {<span class="symbol">:x</span> (comp/get-query X)}]
   <span class="symbol">:ident</span> [<span class="symbol">:a/id</span> <span class="symbol">:id</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>and you want to change both component&#8217;s queries.  The correct form for the resulting mutation is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation change-a-query [_]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                    (as-&gt; s state-map
                      (comp/set-query* state-map X {<span class="symbol">:query</span> [<span class="symbol">:id</span> <span class="symbol">:address</span>]})
                      (comp/set-query* state-map A {<span class="symbol">:query</span> [<span class="symbol">:id</span> <span class="symbol">:new-prop</span> {<span class="symbol">:x</span> (comp/get-query X state-map}]}))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a top-level API call <code>comp/set-query!</code> if you want to change a query outside of a mutation.</p>
</div>
<div class="paragraph">
<p>;; ================================================================================
;; TODO: Move legacy routers to appendix or perhaps even diff library?
;; ================================================================================
= Legacy UI Routers <a id="UIRouting"></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This chapter describes routers from Fulcro 2 that are a bit harder to use and less feature-rich than the
<a href="#_dynamic_router">Dynamic Router</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>UI Routing is an important task in Fulcro, as it is an important part of keeping your application
running quickly. You see, any given sub-tree of your application can query for quite a bit of data and very often
a good portion of the side branches are not currently on-screen. If your entire query runs on every
render frame then things can become slow. The routers in Fulcro route not only the visible DOM, but also the
subquery that needs to run. It does that by using either dynamic queries or union queries with to-one relations to keep
the query targeted to just the active UI.</p>
</div>
<div class="paragraph">
<p>Unfortunately many people find hand-writing union components a little challenging. Fulcro provides a nice
pre-written facility that can write much of the code for you, making the process more conceptual as UI Routing.</p>
</div>
</div>
<div class="sect2">
<h3 id="BasicRouter"><a class="anchor" href="#BasicRouter"></a><a class="link" href="#BasicRouter">16.3. A Basic Router</a></h3>
<div class="paragraph">
<p>A basic router looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:refer</span> [defrouter defsc-router]]) <span class="comment">; requires 2.6.18 for defsc-router</span>

(defsc Index [this {<span class="symbol">:keys</span> [db/id router/page]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span> <span class="symbol">:router/page</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:router/page</span> <span class="symbol">:PAGE/index</span>}}
  <span class="keyword">..</span><span class="keyword">.</span>)

(defsc Settings [this {<span class="symbol">:keys</span> [db/id router/page]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span> <span class="symbol">:router/page</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:router/page</span> <span class="symbol">:PAGE/settings</span>}}
  <span class="keyword">..</span><span class="keyword">.</span>)

<span class="comment">;; Pre-2.6.18</span>
(defrouter RootRouter <span class="symbol">:root/router</span>
  <span class="comment">; OR (fn [t p] [(:router/page p) (:db/id p)])</span>
  [<span class="symbol">:router/page</span> <span class="symbol">:db/id</span>]
  <span class="symbol">:PAGE/index</span> Index
  <span class="symbol">:PAGE/settings</span> Settings)

<span class="comment">;; Post 2.6.18</span>
(defsc-router RootRouter [this {<span class="symbol">:keys</span> [router/page db/id]]
 {<span class="symbol">:router-id</span> <span class="symbol">:root/router</span>
  <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] [page id]) <span class="comment">; props are destructured in the context of the route TARGET</span>
  <span class="symbol">:default-route</span> Index
  <span class="symbol">:router-targets</span> {<span class="symbol">:PAGE/index</span> Index
                  <span class="symbol">:PAGE/settings</span> Settings}}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">What to render if the route is bad</span><span class="delimiter">&quot;</span></span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The newer form lets you define React lifecycle methods, and also lets you define what to render when the route is
invalid (the body is only rendered under that circumstance, otherwise is renders the routed component). It can also
be set to resolve like <code>defsc</code> in Cursive, so you get proper symbol resolution.</p>
</div>
<div class="paragraph">
<p>See old versions of the book in Fulcro&#8217;s git history for docs on the old <code>defrouter</code>.</p>
</div>
<div class="sect3">
<h4 id="_details_on_defsc_router"><a class="anchor" href="#_details_on_defsc_router"></a><a class="link" href="#_details_on_defsc_router">16.3.1. Details on <code>defsc-router</code></a></h4>
<div class="paragraph">
<p>The required parameters of <code>defsc-router</code> are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>:router-id</code></dt>
<dd>
<p>An ID to give the router</p>
</dd>
<dt class="hdlist1"><code>:ident</code></dt>
<dd>
<p>MUST be in <code>fn</code> form, and can use destructured parameters from <code>props</code> (which are in the context of the route target)</p>
</dd>
<dt class="hdlist1"><code>:default-route</code></dt>
<dd>
<p>The component that should be shown by default. Should have initial state so it exists on app start.</p>
</dd>
<dt class="hdlist1"><code>:router-targets</code></dt>
<dd>
<p>A map from the component&#8217;s Fulcro database table to the component that can be routed to. Routing switches
on the FIRST element of the ident (the table name). This is because unions are used, and this allows sub-screens to have
ID&#8217;s that vary. For example, you could router to <code>[:user/id 44]</code> by adding <code>:user/id User</code> as an entry to this map and
making sure the ident function can resolve the ident correctly for the props of a user.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>You may also include most other <code>defsc</code> options, other than <code>:query</code> and <code>:initial-state</code>, which are set internally.</p>
</div>
<div class="paragraph">
<p>The optional body of <code>defsc-router</code> is what to render if the route is bad (e.g. the ident in state for the route doesn&#8217;t
point to a valid routing target).</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. <a id="SimpleRouter"></a><a href="#SimpleRouter">Simple Router</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('simple-router-1')">Focus Inspector</button>
<div class="short narrow example" id="simple-router-1"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.simple-router-1</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r <span class="symbol">:refer-macros</span> [defsc-router]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]))

(defsc Index [this {<span class="symbol">:keys</span> [db/id router/page]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span> <span class="symbol">:router/page</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])                         <span class="comment">; IMPORTANT! Look up both things, don't use the shorthand for idents on screens!</span>
   <span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:router/page</span> <span class="symbol">:PAGE/index</span>}}
  (dom/div <span class="predefined-constant">nil</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Index Page</span><span class="delimiter">&quot;</span></span>))

(defsc Settings [this {<span class="symbol">:keys</span> [db/id router/page]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span> <span class="symbol">:router/page</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:router/page</span> <span class="symbol">:PAGE/settings</span>}}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Settings Page</span><span class="delimiter">&quot;</span></span>))

(defsc-router RootRouter [this {<span class="symbol">:keys</span> [router/page db/id]}]
  {<span class="symbol">:router-id</span>      <span class="symbol">:root/router</span>
   <span class="symbol">:default-route</span>  Index
   <span class="symbol">:ident</span>          (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:router-targets</span> {<span class="symbol">:PAGE/index</span>    Index
                    <span class="symbol">:PAGE/settings</span> Settings}}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad route</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">def</span> <span class="function">ui-root-router</span> (comp/factory RootRouter))

(defsc Root [this {<span class="symbol">:keys</span> [router]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {<span class="symbol">:router</span> (comp/get-initial-state RootRouter {})})
   <span class="symbol">:query</span>         [{<span class="symbol">:router</span> (comp/get-query RootRouter)}]}
  (dom/div
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this
                        `[(r/set-route {<span class="symbol">:router</span> <span class="symbol">:root/router</span>
                                        <span class="symbol">:target</span> [<span class="symbol">:PAGE/index</span> <span class="integer">1</span>]})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Index</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this
                        `[(r/set-route {<span class="symbol">:router</span> <span class="symbol">:root/router</span>
                                        <span class="symbol">:target</span> [<span class="symbol">:PAGE/settings</span> <span class="integer">1</span>]})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Settings</span><span class="delimiter">&quot;</span></span>)
    (ui-root-router router)))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Be sure to look at the database view in the example above. Notice that all that has to happen is a change
of a single ident. This as the effect of switching the rendering, and choosing the
subquery for the remainder of the visible UI.</p>
</div>
</div>
<div class="sect3">
<h4 id="_rendering_a_bad_route"><a class="anchor" href="#_rendering_a_bad_route"></a><a class="link" href="#_rendering_a_bad_route">16.3.2. Rendering a "Bad Route"</a></h4>
<div class="paragraph">
<p>If the app state doesn&#8217;t point to a proper router target then the router won&#8217;t know what to render. This is the
purpose of the body of the <code>defsc-router</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc-router Router [this props]
  {<span class="keyword">..</span><span class="keyword">.</span>}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad route!</span><span class="delimiter">&quot;</span></span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is <strong>very important</strong> to note that the <code>props</code> arg can be destructured in the <strong>context</strong> of a route target, but when
you&#8217;re rendering the "bad route" the props will be the props of the <strong>router itself</strong>.  We recommend you use a pattern
like this if you want to examine the "current route" in the body of the "bad route" rendering:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc-router Router [this props]
  {<span class="keyword">..</span><span class="keyword">.</span>}
  (<span class="keyword">let</span> [{<span class="symbol">:com.fulcrologic.fulcro.routing.legacy-ui-routers/keys</span> [id current-route]} (comp/props this)]
    (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad route: </span><span class="delimiter">&quot;</span></span> current-route)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>but most likely the current route is just going to be <code>nil</code>, since you&#8217;re looking at denormalized props, and the ident
that is in state is pointing at something wrong. So, instead you can pull the state map and see what the bad ident is
instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">..</span><span class="keyword">.</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r <span class="symbol">:refer</span> [defsc-router]]))

(defsc-router Router [this props]
  {<span class="keyword">..</span><span class="keyword">.</span>}
  (<span class="keyword">let</span> [state-map (comp/component-&gt;state-map this)
        {<span class="symbol">:com.fulcrologic.fulcro.routing.legacy-ui-routers/keys</span> [id]} (comp/props this)]
        current-route (<span class="keyword">get-in</span> state-map [r/routers-table <span class="symbol">::r/id</span> id <span class="symbol">::r/current-route</span>])]
    (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad route ident: </span><span class="delimiter">&quot;</span></span> current-route)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>of course you probably don&#8217;t want to render that to the user, but in case you find it useful at least you know how to
get it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_composing_routers"><a class="anchor" href="#_composing_routers"></a><a class="link" href="#_composing_routers">16.3.3. Composing Routers</a></h4>
<div class="paragraph">
<p>It is very easy from here to compose together as many of these as you&#8217;d like in order to
build a more complicated UI. For example, the settings could have several subscreens as in this
example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. <a id="NestedRouter"></a><a href="#NestedRouter">Nested Router</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('simple-router-2')">Focus Inspector</button>
<div class="short narrow example" id="simple-router-2"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.simple-router-2</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r <span class="symbol">:refer-macros</span> [defsc-router]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]))

(defsc Index [this {<span class="symbol">:keys</span> [router/page db/id]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span> <span class="symbol">:router/page</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:router/page</span> <span class="symbol">:PAGE/index</span>}}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Index Page</span><span class="delimiter">&quot;</span></span>))

(defsc EmailSettings [this {<span class="symbol">:keys</span> [db/id router/page]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span> <span class="symbol">:router/page</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:router/page</span> <span class="symbol">:PAGE/email</span>}}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Email Settings Page</span><span class="delimiter">&quot;</span></span>))

(defsc ColorSettings [this {<span class="symbol">:keys</span> [db/id router/page]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span> <span class="symbol">:router/page</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:initial-state</span> {<span class="symbol">:db/id</span> <span class="integer">1</span> <span class="symbol">:router/page</span> <span class="symbol">:PAGE/color</span>}}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Color Settings</span><span class="delimiter">&quot;</span></span>))

(defsc-router SettingsRouter [this {<span class="symbol">:keys</span> [router/page db/id]}]
  {<span class="symbol">:router-id</span>      <span class="symbol">:settings/router</span>
   <span class="symbol">:ident</span>          (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:router-targets</span> {<span class="symbol">:PAGE/email</span> EmailSettings
                    <span class="symbol">:PAGE/color</span> ColorSettings}
   <span class="symbol">:default-route</span>  EmailSettings}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad route</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">def</span> <span class="function">ui-settings-router</span> (comp/factory SettingsRouter))

(defsc Settings [this {<span class="symbol">:keys</span> [router/page db/id subpage]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span> <span class="symbol">:router/page</span> {<span class="symbol">:subpage</span> (comp/get-query SettingsRouter)}]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p]
                    {<span class="symbol">:db/id</span>       <span class="integer">1</span>
                     <span class="symbol">:router/page</span> <span class="symbol">:PAGE/settings</span>
                     <span class="symbol">:subpage</span>     (comp/get-initial-state SettingsRouter {})})}
  (dom/div
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this
                        `[(r/set-route {<span class="symbol">:router</span> <span class="symbol">:settings/router</span>
                                        <span class="symbol">:target</span> [<span class="symbol">:PAGE/email</span> <span class="integer">1</span>]})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Email</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this
                        `[(r/set-route {<span class="symbol">:router</span> <span class="symbol">:settings/router</span>
                                        <span class="symbol">:target</span> [<span class="symbol">:PAGE/color</span> <span class="integer">1</span>]})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Colors</span><span class="delimiter">&quot;</span></span>)
    (js/console.log <span class="symbol">:p</span> (comp/props this))
    (ui-settings-router subpage)))

(defsc-router RootRouter [this {<span class="symbol">:keys</span> [router/page db/id]}]
  {<span class="symbol">:router-id</span>      <span class="symbol">:root/router</span>
   <span class="symbol">:ident</span>          (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:default-route</span>  Index
   <span class="symbol">:router-targets</span> {<span class="symbol">:PAGE/index</span>    Index
                    <span class="symbol">:PAGE/settings</span> Settings}}
  (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad route</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">def</span> <span class="function">ui-root-router</span> (comp/factory RootRouter))

(defsc Root [this {<span class="symbol">:keys</span> [router]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {<span class="symbol">:router</span> (comp/get-initial-state RootRouter {})})
   <span class="symbol">:query</span>         [{<span class="symbol">:router</span> (comp/get-query RootRouter)}]}
  (dom/div
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this
                        `[(r/set-route {<span class="symbol">:router</span> <span class="symbol">:root/router</span>
                                        <span class="symbol">:target</span> [<span class="symbol">:PAGE/index</span> <span class="integer">1</span>]})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Index</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this
                        `[(r/set-route {<span class="symbol">:router</span> <span class="symbol">:root/router</span>
                                        <span class="symbol">:target</span> [<span class="symbol">:PAGE/settings</span> <span class="integer">1</span>]})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Settings</span><span class="delimiter">&quot;</span></span>)
    (ui-root-router router)))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This allows you to build up a tree of routers that keeps your query minimal, and allows for very nice dynamic
structuring of the applicataion at runtime.</p>
</div>
<div class="paragraph">
<p>If you have screens that could have different instances (for example, different reports), then each report could
have an ID, and routing would involve selecting the screen&#8217;s table, as well as a distinct ID.</p>
</div>
<div class="paragraph">
<p>The problem, of course, is that managing all of these routers in your application logic becomes
somewhat of a chore. Also, it is common to want to mix UI routing with HTML5 history, where only a single
"route" is spelled out, but you may need to logically "switch" any number of these UI routers to reach
the indicated screen.</p>
</div>
<div class="paragraph">
<p>For example, one could imagine wanting to go to <code>/settings/colors</code> as a URI for the previous example. That single
URI <strong>as a concept</strong> is a single route to a screen, but the mutation you&#8217;d trigger would be to <code>set-route</code> on
two different routers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! this `[(r/set-route <span class="keyword">..</span><span class="keyword">.</span>) (r/set-route <span class="keyword">..</span><span class="keyword">.</span>)])</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_routing_tree_support"><a class="anchor" href="#_routing_tree_support"></a><a class="link" href="#_routing_tree_support">16.4. Routing Tree Support</a></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Fulcro Incubator&#8217;s Dynamic Routers automatically compose and understand paths, so there is no need to declare a
routing tree with them.  You might want to try those as an alternative.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Fulcro includes some routing tree primitives to do the mapping from single conceptual "routes" like <code>/settings/colors</code>
to a set of instructions that you need to send to your UI routers. There is an additional concern as well: route
parameters. It is quite common to want to interpret URIs like <code>/user/436</code> as a route that populates a given screen
with some data.</p>
</div>
<div class="paragraph">
<p>Thus, the tree support is based on the concept of a Route Handler and Route Parameters.</p>
</div>
<div class="paragraph">
<p>Defining routes requires just a few steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Define routers as shown in <a href="#BasicRouter">the prior section</a>, giving each router a distinct ID.</p>
</li>
<li>
<p>Give each <strong>routable screen (i.e. URI)</strong> in your tree a handler name.  The example below shows two routers with
5 conceptual target screen. The screens have <strong>handler names</strong> <code>:main</code>, <code>:login</code>, etc.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">              (top-router w/id <span class="symbol">:top-router</span>)
                 ----------------------
                <span class="keyword">/</span>     <span class="keyword">/</span>     <span class="error">|</span>          \
           <span class="symbol">:main</span>  <span class="symbol">:login</span>  <span class="symbol">:new-user</span>    (report router w/id <span class="symbol">:report-router</span>)
                                             <span class="error">|</span>
                              (reports shared content screen)
                                             <span class="error">|</span>
                                            <span class="keyword">/</span> \
                                      <span class="symbol">:status</span>  <span class="symbol">:graph</span></code></pre>
</div>
</div>
</li>
<li>
<p>Define your routing tree. This is a data structure that gives instructions to one-or-more routers that are necessary to
display the screen with a given handler name. In the above example you need to tell <strong>both</strong> the top router and report router
to change what they are showing in order to get a <code>:status</code> or <code>:graph</code> onto the screen.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">routing-tree</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">A map of route handling instructions. A given route has a handler name (e.g. `:main`) which is
  thought of as the target of a routing operation (i.e. interpretation of a URI). It also has a vector
  of `router-instruction`s, which say

  1. which router should be changed
  2. What component instance that router should point to (by ident)

  The routing tree for the diagram above is therefore:
  </span><span class="delimiter">&quot;</span></span>
  (r/routing-tree
    (r/make-route <span class="symbol">:main</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:main</span> <span class="symbol">:top</span>])])
    (r/make-route <span class="symbol">:login</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:login</span> <span class="symbol">:top</span>])])
    (r/make-route <span class="symbol">:new-user</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:new-user</span> <span class="symbol">:top</span>])])
    (r/make-route <span class="symbol">:graph</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:report</span> <span class="symbol">:top</span>])
                          (r/router-instruction <span class="symbol">:report-router</span> [<span class="symbol">:graphing-report</span> <span class="symbol">:param/report-id</span>])])
    (r/make-route <span class="symbol">:status</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:report</span> <span class="symbol">:top</span>])
                           (r/router-instruction <span class="symbol">:report-router</span> [<span class="symbol">:status-report</span> <span class="symbol">:param/report-id</span>])])))</code></pre>
</div>
</div>
</li>
<li>
<p>Compose the application as normal, placing the routers as shown in <a href="#BasicRouter">the prior section</a>.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_routing_tree"><a class="anchor" href="#_using_the_routing_tree"></a><a class="link" href="#_using_the_routing_tree">16.5. Using the Routing Tree</a></h3>
<div class="paragraph">
<p>The routing namespace includes a Fulcro mutation for triggering the routing tree handler.
It takes a <code>:handler</code> (e.g. <code>:main</code>)  and an optional <code>:route-params</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; assumes you've aliased com.fulcrologic.fulcro.routing.legacy-ui-routers to r</span>
(comp/transact! `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:main</span>})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running this mutation will run all of the <code>router-instruction</code>, and will also do route parameter substitution on the
resulting idents.</p>
</div>
<div class="sect3">
<h4 id="_route_parameters"><a class="anchor" href="#_route_parameters"></a><a class="link" href="#_route_parameters">16.5.1. Route Parameters</a></h4>
<div class="paragraph">
<p>Anything you pass in the <code>:route-params</code> map will get automatically plugged into the parameter
placeholders in your routing tree instructions. By default anything that looks like an integer (only digits) will
be coerced to an integer. Anything that contains only letters will map to a keyword.</p>
</div>
<div class="paragraph">
<p>If the default coercion isn&#8217;t sufficient then you can customize it using <a href="#ParamCoercion">parameter coercion</a>.</p>
</div>
<div class="paragraph">
<p>It is a very common task to need to convert incoming strings (e.g. from a URL) to elements of an ident. If you&#8217;d like
to use this support in your own code then use <code>(r/set-ident-route-params ident params)</code> which
supports the coercion and replacement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(r/set-ident-route-params [<span class="symbol">:param/table</span> <span class="symbol">:param/id</span>] {<span class="symbol">:table</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span> <span class="symbol">:id</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>})
<span class="comment">; =&gt; [:a 1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the params argument is just what you&#8217;d get from a URL when using something like bidi (everything will come
in as strings).</p>
</div>
<div class="sect4">
<h5 id="ParamCoercion"><a class="anchor" href="#ParamCoercion"></a><a class="link" href="#ParamCoercion">Parameter Coercion</a></h5>
<div class="paragraph">
<p>The default coercion converts integer-looking things to integers, and string-looking things to keywords.</p>
</div>
<div class="paragraph">
<p>There is a multimethod <code>r/coerce-param</code> that dispatches on <code>:param/X</code> and replaces the value with
whatever you return. You customize coercion simply by adding your own coercion for
a parameter by name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defmethod</span> <span class="function">r/coerce-param</span> <span class="symbol">:param/NAME</span>
  [k incoming-string-value]
  (transform-it incoming-string-value))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, be sure that your namespace with the <code>defmethod</code> is loaded so that your methods get installed.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_examining_routes_in_ui_and_mutations"><a class="anchor" href="#_examining_routes_in_ui_and_mutations"></a><a class="link" href="#_examining_routes_in_ui_and_mutations">16.6. Examining Routes in UI and Mutations</a></h3>
<div class="paragraph">
<p>Your UI will often want to rely on knowing the "current" route of a given router in order to give
user navigation feedback. You cannot embed <strong>your</strong> router in the query, because that would often
make the query have a circular reference and blow the stack.</p>
</div>
<div class="paragraph">
<p>The only real bit of information in a router that is useful is the current route
The <code>current-route</code> function can be used in a mutation or component (by querying for the router
table) to check the route:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">x</span>
  (<span class="symbol">:require</span> [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r]
            [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span>]))

(r/defsc-router SomeRouter [this props]
 {<span class="symbol">:router-id</span> <span class="symbol">:top-router</span>
  <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] <span class="keyword">..</span><span class="keyword">.</span>)
  <span class="symbol">:default-route</span> HomePage
  <span class="symbol">:router-targets</span> {<span class="symbol">:home-page</span> HomePage
                   <span class="symbol">:about-page</span> AboutPage}}
  <span class="keyword">..</span><span class="keyword">.</span>)

(defmutation do-something-with-routes [params]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">let</span> [current (r/current-route state <span class="symbol">:top-router</span>)] <span class="comment">; current will be an ident of a screen of :top-router</span>
    <span class="keyword">..</span><span class="keyword">.</span>)))

(defsc NavBar [this props]
  {<span class="symbol">:query</span> (<span class="keyword">fn</span> [] [ [r/routers-table '_] ])
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {})}
  (<span class="keyword">let</span> [current (current-route props <span class="symbol">:top-router</span>)] <span class="comment">; current will be an ident of a screen of :top-router</span>
     <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_complete_ui_routing_example"><a class="anchor" href="#_a_complete_ui_routing_example"></a><a class="link" href="#_a_complete_ui_routing_example">16.7. A Complete UI Routing Example</a></h3>
<div class="paragraph">
<p>The following shows the example routing tree in a complete running demo:</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. <a id="RoutingDemo"></a><a href="#RoutingDemo">Routing Demo</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('ui-routing')">Focus Inspector</button>
<div class="short narrow example" id="ui-routing"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.ui-routing</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r <span class="symbol">:refer-macros</span> [defsc-router]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]))

(defsc Main [this {<span class="symbol">:keys</span> [label] <span class="symbol">:as</span> props}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:page</span> <span class="symbol">:main</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">MAIN</span><span class="delimiter">&quot;</span></span>}
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [(<span class="symbol">:page</span> props) <span class="symbol">:top</span>])
   <span class="symbol">:query</span>         [<span class="symbol">:page</span> <span class="symbol">:label</span>]}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>}}
    label))

(defsc Login [this {<span class="symbol">:keys</span> [label] <span class="symbol">:as</span> props}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:page</span> <span class="symbol">:login</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">LOGIN</span><span class="delimiter">&quot;</span></span>}
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [(<span class="symbol">:page</span> props) <span class="symbol">:top</span>])
   <span class="symbol">:query</span>         [<span class="symbol">:page</span> <span class="symbol">:label</span>]}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">green</span><span class="delimiter">&quot;</span></span>}}
    label))

(defsc NewUser [this {<span class="symbol">:keys</span> [label] <span class="symbol">:as</span> props}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:page</span> <span class="symbol">:new-user</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">New User</span><span class="delimiter">&quot;</span></span>}
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [(<span class="symbol">:page</span> props) <span class="symbol">:top</span>])
   <span class="symbol">:query</span>         [<span class="symbol">:page</span> <span class="symbol">:label</span>]}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">skyblue</span><span class="delimiter">&quot;</span></span>}}
    label))

(defsc StatusReport [this {<span class="symbol">:keys</span> [id page]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:id</span> <span class="symbol">:a</span> <span class="symbol">:page</span> <span class="symbol">:status-report</span>}
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:query</span>         [<span class="symbol">:id</span> <span class="symbol">:page</span> <span class="symbol">:label</span>]}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">yellow</span><span class="delimiter">&quot;</span></span>}}
    (dom/div (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Status </span><span class="delimiter">&quot;</span></span> id))))

(defsc GraphingReport [this {<span class="symbol">:keys</span> [id page]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:id</span> <span class="symbol">:a</span> <span class="symbol">:page</span> <span class="symbol">:graphing-report</span>}
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page id])
   <span class="symbol">:query</span>         [<span class="symbol">:id</span> <span class="symbol">:page</span> <span class="symbol">:label</span>]}                       <span class="comment">; make sure you query for everything need by the router's ident function!</span>
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">orange</span><span class="delimiter">&quot;</span></span>}}
    (dom/div (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Graph </span><span class="delimiter">&quot;</span></span> id))))

(defsc-router ReportRouter [this props]
  {<span class="symbol">:router-id</span>      <span class="symbol">:report-router</span>
   <span class="symbol">:ident</span>          (<span class="keyword">fn</span> [] [(<span class="symbol">:page</span> props) (<span class="symbol">:id</span> props)])
   <span class="symbol">:default-route</span>  StatusReport
   <span class="symbol">:router-targets</span> {<span class="symbol">:status-report</span>   StatusReport
                    <span class="symbol">:graphing-report</span> GraphingReport}})

(<span class="keyword">def</span> <span class="function">ui-report-router</span> (comp/factory ReportRouter))

<span class="comment">; BIG GOTCHA: Make sure you query for the prop (in this case :page) that the union needs in order to decide. It won't pull it itself!</span>
(defsc ReportsMain [this {<span class="symbol">:keys</span> [page report-router]}]
  <span class="comment">; nest the router under any arbitrary key, just be consistent in your query and props extraction.</span>
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:page</span> <span class="symbol">:report</span> <span class="symbol">:report-router</span> (comp/get-initial-state ReportRouter {})})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [page <span class="symbol">:top</span>])
   <span class="symbol">:query</span>         [<span class="symbol">:page</span> {<span class="symbol">:report-router</span> (comp/get-query ReportRouter)}]}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">grey</span><span class="delimiter">&quot;</span></span>}}
    <span class="comment">; Screen-specific content to be shown &quot;around&quot; or &quot;above&quot; the subscreen</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">REPORT MAIN SCREEN</span><span class="delimiter">&quot;</span></span>
    <span class="comment">; Render the sub-router. You can also def a factory for the router (e.g. ui-report-router)</span>
    (ui-report-router report-router)))

(defsc-router TopRouter [this props]
  {<span class="symbol">:router-id</span>      <span class="symbol">:top-router</span>
   <span class="symbol">:default-route</span>  Main
   <span class="symbol">:ident</span>          (<span class="keyword">fn</span> [] [(<span class="symbol">:page</span> props) <span class="symbol">:top</span>])
   <span class="symbol">:router-targets</span> {<span class="symbol">:main</span>     Main
                    <span class="symbol">:login</span>    Login
                    <span class="symbol">:new-user</span> NewUser
                    <span class="symbol">:report</span>   ReportsMain}})

(<span class="keyword">def</span> <span class="function">ui-top</span> (comp/factory TopRouter))

(<span class="keyword">def</span> <span class="function">routing-tree</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">A map of route handling instructions. The top key is the handler name of the route which can be
  thought of as the terminal leaf in the UI graph of the screen that should be </span><span class="content">\&quot;</span><span class="content">foremost</span><span class="content">\&quot;</span><span class="content">.

  The value is a vector of routing-instructions to tell the UI routers which ident
  of the route that should be made visible.

  A value in this ident using the `param` namespace will be replaced with the incoming route parameter
  (without the namespace). E.g. the incoming route-param :report-id will replace :param/report-id</span><span class="delimiter">&quot;</span></span>
  (r/routing-tree
    (r/make-route <span class="symbol">:main</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:main</span> <span class="symbol">:top</span>])])
    (r/make-route <span class="symbol">:login</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:login</span> <span class="symbol">:top</span>])])
    (r/make-route <span class="symbol">:new-user</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:new-user</span> <span class="symbol">:top</span>])])
    (r/make-route <span class="symbol">:graph</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:report</span> <span class="symbol">:top</span>])
                          (r/router-instruction <span class="symbol">:report-router</span> [<span class="symbol">:graphing-report</span> <span class="symbol">:param/report-id</span>])])
    (r/make-route <span class="symbol">:status</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:report</span> <span class="symbol">:top</span>])
                           (r/router-instruction <span class="symbol">:report-router</span> [<span class="symbol">:status-report</span> <span class="symbol">:param/report-id</span>])])))

(defsc Root [this {<span class="symbol">:keys</span> [top-router]}]
  <span class="comment">; r/routing-tree-key implies the alias of com.fulcrologic.fulcro.routing.legacy-ui-routers as r.</span>
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] (<span class="keyword">merge</span> routing-tree
                                 {<span class="symbol">:top-router</span> (comp/get-initial-state TopRouter {})}))
   <span class="symbol">:query</span>         [r/routing-tree-key
                   {<span class="symbol">:top-router</span> (comp/get-query TopRouter)}]}
  (dom/div
    <span class="comment">; Sample nav mutations</span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:main</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Main</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:new-user</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">New User</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:login</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Login</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:status</span> <span class="symbol">:route-params</span> {<span class="symbol">:report-id</span> <span class="symbol">:a</span>}})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Status A</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:graph</span> <span class="symbol">:route-params</span> {<span class="symbol">:report-id</span> <span class="symbol">:a</span>}})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Graph A</span><span class="delimiter">&quot;</span></span>)
    (ui-top top-router)))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_combining_routing_with_data_management"><a class="anchor" href="#_combining_routing_with_data_management"></a><a class="link" href="#_combining_routing_with_data_management">16.8. Combining Routing with Data Management</a></h3>
<div class="paragraph">
<p>Of course you can compose this with other mutations into a single transaction. This is common when you&#8217;re trying
to switch to a screen whose data might not yet exist:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/transact! `[(ensure-report-loaded {<span class="symbol">:report-id</span> <span class="symbol">:a</span>}) (r/route-to {<span class="symbol">:graph</span> <span class="symbol">:a</span>})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>here we&#8217;re assuming that <code>ensure-report-loaded</code> is a mutation that ensures that there is at least placeholder data in
place (or the UI rendering might look a bit odd or otherwise fail from lack of data). It may also do things like trigger background
loads that will fufill the graph&#8217;s needs, something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation ensure-report-loaded [{<span class="symbol">:keys</span> [report-id]}]
  (action [{<span class="symbol">:keys</span> [state] <span class="symbol">:as</span> env}]
    (<span class="keyword">let</span> [when-loaded (<span class="keyword">get-in</span> @state [<span class="symbol">:reports/id</span> report-id <span class="symbol">:load-time-ms</span>] <span class="integer">0</span>)
          is-missing? (<span class="keyword">=</span> <span class="integer">0</span> when-loaded)
          now-ms (<span class="keyword">.</span>getTime (js/Date.))
          age-ms (<span class="keyword">-</span> now-ms when-loaded)
          should-be-loaded? (<span class="keyword">or</span> (too-old? age-ms) is-missing?)]
      <span class="comment">; if missing, put placeholder</span>
      <span class="comment">; if too old, add remote load to Fulcro queue (see data-fetch for remote-load and load-action)</span>
      (<span class="keyword">when</span> is-missing? (<span class="keyword">swap!</span> state add-report-placeholder report-id))
      (<span class="keyword">when</span> should-be-loaded? (df/load-action env [<span class="symbol">:reports/id</span> report-id] StatusReport)))})
  (remote [env] (df/load-action env)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additional mutations might do things like garbage collect old data that is not in the view. You may also need to
trigger renders of things like your main screen with follow-on reads (e.g. of a keyword on the root
component of your UI). Of course, combining such things into functions adds a nice touch:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">show-report!</span>
  [component report-id]
  (comp/transact! component `[(app/clear-old-reports)
                              (app/ensure-report-loaded {<span class="symbol">:report-id</span> ~report-id})
                              (r/route-to {<span class="symbol">:graph</span> ~report-id})
                              <span class="symbol">:top-level-key</span>]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>which can then be used more cleanly in the UI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(dom/a {<span class="symbol">:onClick</span> #(show-report! this <span class="symbol">:a</span>)} <span class="string"><span class="delimiter">&quot;</span><span class="content">Report A</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mutations_with_routing"><a class="anchor" href="#_mutations_with_routing"></a><a class="link" href="#_mutations_with_routing">16.9. Mutations with Routing</a></h3>
<div class="paragraph">
<p>In some cases you will find it most convenient to do your routing within a mutation itself. This will let you
check state, trigger loads, etc. If you trigger loads, then you can also easily defer the routing until the
load completes. Of course, in that case you may want to do something in the state to cause your UI to indicate
the routing is in progress.</p>
</div>
<div class="paragraph">
<p>There is nothing special about this technique. There are several functions in the <code>routing</code> namespace
that can be used easily within your own mutations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>update-routing-links</code> - For standard union-based <code>defsc-router</code> (does not support dynamic code loading routers): Takes
the state map and a route match (map with :handler and :route-params) and returns a new state map with the routes updated.</p>
</li>
<li>
<p><code>route-to-impl!</code> - For all kinds of routers (including dynamic): Takes the mutation <code>env</code> and a bidi-style match {:handler/:params}.
Works with dynamic routes. Does swaps against app state, but is safe to use within a mutation.</p>
</li>
<li>
<p><code>set-route</code> - Changes the current route on a <strong>specific</strong> <code>defsc-router</code> instance. Takes a state map, router ID, and a target ident.
Used if <strong>not</strong> using routing trees or dynamic routers.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_html5_routing"><a class="anchor" href="#_html5_routing"></a><a class="link" href="#_html5_routing">16.10. HTML5 Routing</a></h3>
<div class="paragraph">
<p>Hooking HTML5 or hash-based routing up to this is relatively simple using, for example, <code>pushy</code> and <code>bidi</code>.</p>
</div>
<div class="paragraph">
<p>We do not provide direct support for this, since your application will need to make a number of decisions that
really are local to the specific app:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How to map URIs to your leaf screens. If you use bidi then <code>bidi-match</code> will return exactly what you need from
a URI route match (e.g. <code>{:handler :x :route-params {:p v}}</code>).</p>
</li>
<li>
<p>How to grab the URI bits you need. For example, <code>pushy</code> lets you hook up to HTML5 history events.</p>
</li>
<li>
<p>If a routing decision should be deferred/reversed? E.g. navigation should be denied until a form is saved.</p>
</li>
<li>
<p>How you want to update the URI on routing. You can define your own additional mutation to do this (e.g. via <code>pushy/set-token!</code>)
and possibly compose it into a new mutations with <code>route-to</code>. The function <code>r/update-routing-links</code> can be used for
such a composition:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; in some defmutation</span>
(<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [m]
                (<span class="keyword">-&gt;</span> m
                    (r/update-routing-links { <span class="symbol">:handler</span> <span class="symbol">:h</span> <span class="symbol">:route-params</span> p })
                    (app/your-state-updates)))
(pushy/set-token! your-uri-interpretation-of-h)</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the fulcro-template on github. It supports HTML5 routing with a demo tree.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_forms_overview"><a class="anchor" href="#_forms_overview"></a><a class="link" href="#_forms_overview">17. Forms Overview</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>On the surface forms are trivial: you have DOM input fields, users put stuff in them, and you submit that to a server.
For really simple forms you already have sufficient tools and you can simply code them however you see fit.</p>
</div>
<div class="paragraph">
<p>The next most critical thing you&#8217;ll want is some help with managing the meta-state that goes with most form
interactions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When is the content of a field valid?</p>
</li>
<li>
<p>When should you show a validation error message? E.g. you should not tell a user that they made a mistake
on a field they have yet to touch.</p>
</li>
<li>
<p>How do you "reset" the form if the user changes their mind or cancels an edit?</p>
</li>
<li>
<p>How do you ensure that just the data that has changed is sent to the server?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These more advanced interactions require that you track a few things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The validation rules</p>
</li>
<li>
<p>Which fields are "complete" (ready for validation)?</p>
</li>
<li>
<p>What was the state of the form fields <strong>before</strong> the user started interacting with it?</p>
</li>
<li>
<p>How do you transition states (e.g. indicate that the updated form is now the new "real state"?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You will also commonly need a way to deal with the fact that a form may cross several entities in your database,
generating a more global top-level form concern: are all of the entities in this form valid?</p>
</div>
<div class="paragraph">
<p>Again, you can certainly code all of this by hand, but Fulcro includes two different namespaces of helpers that
can make dealing with these aspects of forms a little easier. The reason there are two is that the older
version was not easy to change without breaking existing code, so new functions were written in a new namespace
as an alternative.</p>
</div>
<div class="paragraph">
<p>The <a href="#FormState">form state</a> support in Fulcro concentrates just on providing utilities to manage the data, and has validation
that is based on Clojure Spec but is completely pluggable.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="FormState"><a class="anchor" href="#FormState"></a><a class="link" href="#FormState">18. Form State Support</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The namespace <code>com.fulcrologic.fulcro.algorithms.form-state</code> (aliased to <code>fs</code> in this chapter) includes functions and mutations for
working with your entity as a form. This support brings functions for dealing with common state storage and form transitions
with minimal opinion or additional complexity.</p>
</div>
<div class="paragraph">
<p>Your UI is still built and rendered identically to what you&#8217;re already used to. The form state support simply
adds some additional state tracking that can help you manage things like field validation and minimal delta
submissions to the server.</p>
</div>
<div class="sect2">
<h3 id="_defining_the_form_component"><a class="anchor" href="#_defining_the_form_component"></a><a class="link" href="#_defining_the_form_component">18.1. Defining the Form Component</a></h3>
<div class="paragraph">
<p>A component that wishes to act as a form must have an ident and a query.
There are two additional steps you must do to prepare your component to work with form state management:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add a form configuration join to your query.</p>
</li>
<li>
<p>Declare which of your props/joins are part of the form.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So, a minimal form-state-compatible component looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc NameForm [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:id</span> <span class="symbol">:name</span> fs/form-config-join]
   <span class="symbol">:ident</span> [<span class="symbol">:name-form/id</span> <span class="symbol">:id</span>]
   <span class="symbol">:form-fields</span> #{<span class="symbol">:name</span>}} <span class="comment">; MUST be a set of keywords from your query</span>
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>next, you&#8217;ll want to populate your state with some data. Of course during this step you&#8217;ll need to populate that
form configuration data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_form_configuration"><a class="anchor" href="#_form_configuration"></a><a class="link" href="#_form_configuration">18.2. Form Configuration</a></h3>
<div class="paragraph">
<p>Form state is stored in a form configuration entity in your app state database. This configuration entity includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The "pristine" state of your entity.</p>
</li>
<li>
<p>Which properties (and joins) of your entity are part of the form.</p>
</li>
<li>
<p>Which properties are "complete" (ready for validation).</p>
</li>
<li>
<p>A map of which parts of the form come from which declared component.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The form state is normalized into your state database. There are two ways of adding this configuration:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add it to a tree of initial (or incoming) state, and merge that (which will normalize it all).</p>
</li>
<li>
<p>Add it directly to your state database.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>these methods are described in the following section.</p>
</div>
<div class="sect3">
<h4 id="_initializing_a_tree_of_data"><a class="anchor" href="#_initializing_a_tree_of_data"></a><a class="link" href="#_initializing_a_tree_of_data">18.2.1. Initializing a Tree of Data</a></h4>
<div class="paragraph">
<p>This case occurs when you have either some initial state or a function on the client side that generates a new
entity (i.e. with a tempid) and you want to immediately use it with a form. Forms can be nested into
a group, and the functions automatically support initializing the configuration recursively for a given form set.</p>
</div>
<div class="paragraph">
<p>Say you have a person with multiple (normalized) phone numbers. You want to make a new person and set them up
with an initial phone number to fill out. The tree for that data might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">person-tree</span>
  { <span class="symbol">:db/id</span> (comp/tempid)
    <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>
    <span class="symbol">:person/phone-numbers</span> [{<span class="symbol">:db/id</span> (comp/tempid) <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">555-1212</span><span class="delimiter">&quot;</span></span>}]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>with components like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc PhoneForm [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:phone/number</span> fs/form-config-join]
   <span class="symbol">:ident</span> [<span class="symbol">:phone/id</span> <span class="symbol">:db/id</span>]
   <span class="symbol">:form-fields</span> #{<span class="symbol">:phone/number</span>}}
  <span class="keyword">..</span><span class="keyword">.</span>)

(defsc PersonForm [this props]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:person/name</span> {<span class="symbol">:person/phone-numbers</span> (comp/get-query PhoneForm)}
           fs/form-config-join]
   <span class="symbol">:ident</span> [<span class="symbol">:person/id</span> <span class="symbol">:db/id</span>]
   <span class="symbol">:form-fields</span> #{<span class="symbol">:person/name</span> <span class="symbol">:person/phone-numbers</span>}}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Normally you might throw this into your application state with something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/merge-component! reconciler PersonForm person-tree)</code></pre>
</div>
</div>
<div class="paragraph">
<p>which will insert and normalize the person and phone number.</p>
</div>
<div class="paragraph">
<p>If you also are supporting form interactions then you can augment the form with form configuration data like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">person-tree-with-form-support</span> (fs/add-form-config PersonForm person-tree))
(comp/merge-component! reconciler PersonForm person-tree-with-form-support)</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>add-form-config</code> will look at all of the form (and subforms reachable from that form), but it will
only add config to the ones that are missing it. This means the current form state is <strong>not</strong> reset by this call.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_initializing_in_a_mutation"><a class="anchor" href="#_initializing_in_a_mutation"></a><a class="link" href="#_initializing_in_a_mutation">18.2.2. Initializing in a Mutation</a></h4>
<div class="paragraph">
<p>The other very common case is this: You&#8217;ve loaded something from the server, and you&#8217;d like to use it as the basis
for form fields. In this case the data is already normalized in your state database, and you&#8217;ll need to work on
it via a mutation.</p>
</div>
<div class="paragraph">
<p>The <code>add-form-config*</code> function is the helper for that. The common pattern for using it is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation use-person-as-form [{<span class="symbol">:keys</span> [person-id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                   (<span class="keyword">-&gt;</span> s
                     (fs/add-form-config* PersonForm [<span class="symbol">:person/id</span> person-id]) <span class="comment">; this will affect the joined phone as well</span>
                     (<span class="keyword">assoc-in</span> [<span class="symbol">:component</span> <span class="symbol">:person-editor</span> <span class="symbol">:person-to-edit</span>] [<span class="symbol">:person/id</span> person-id]) <span class="comment">; hook it into an editor?</span>
                     <span class="keyword">..</span><span class="keyword">.</span>))))) <span class="comment">; other setup code</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>add-form-config*</code> will look at all of the form (and subforms reachable from that form), but it will
only add config to the ones that are missing it. This means the current form state is <strong>not</strong> reset by this call. This
is intentional, since you might add sub-forms (e.g. a new phone number) to a form group, and this allows you to
re-run the add of config data from the top without worrying about affecting pre-existing form state.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_validation"><a class="anchor" href="#_validation"></a><a class="link" href="#_validation">18.3. Validation</a></h3>
<div class="paragraph">
<p>Validation in the form state system is completely customizable. There is built-in support for working with Clojure Spec as your validation
layer. In order for this to be effective you should be sure to namespace all of your properties in a globally-unique
way, and then simply write normal specs for them. The section on <a href="#CustomValidators">custom validators</a> describes
the other supported mechanism for validation.</p>
</div>
<div class="paragraph">
<p>The central function for using specs is <code>fs/get-spec-validity</code>, which can be used on an entire form or a single field.
This function returns one of <code>#{:valid, :invalid, :unchecked}</code>.
Initially, a form&#8217;s fields are marked as incomplete. When in this state the validity will <strong>always</strong> be <code>:unchecked</code>.</p>
</div>
<div class="paragraph">
<p>Some additional helpers are useful for concise UI code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(invalid-spec? form field)</code> - Field is an optional argument. Returns true if the form (field) is complete <strong>and</strong> invalid.</p>
</li>
<li>
<p><code>(valid-spec? form field)</code> - Field is an optional argument. Returns true if the form (field) is complete <strong>and</strong> valid.</p>
</li>
<li>
<p><code>(checked? form field)</code> - Field is an optional argument. Returns true if the form (field) is complete. This function works no matter
what validator you&#8217;re using.</p>
</li>
<li>
<p><code>(dirty? form field)</code> - Field is an optional argument. Returns true if the pristine copy of the form (field) doesn&#8217;t match the current entity.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc PersonForm [this {<span class="symbol">:keys</span> [person/name] <span class="symbol">:as</span> props}]
   <span class="keyword">..</span><span class="keyword">.</span>
   <span class="comment">;; The `mark-complete!` mutation is covered below</span>
   (dom/input {<span class="symbol">:value</span> <span class="keyword">name</span> <span class="symbol">:onBlur</span> #(comp/transact! this `[(fs/mark-complete! <span class="keyword">..</span><span class="keyword">.</span>)]) <span class="keyword">..</span><span class="keyword">.</span>})
   (<span class="keyword">when</span> (fs/invalid-spec? props <span class="symbol">:person/name</span>)
      (dom/span <span class="string"><span class="delimiter">&quot;</span><span class="content">Invalid username!</span><span class="delimiter">&quot;</span></span>)
   <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>will show the error only if the field is complete (shown as a call to <code>mark-complete!</code> on blur), but only if the field&#8217;s value
does not match the spec for <code>:person/name</code>.</p>
</div>
<div class="paragraph">
<p>As you can see, the idea of "complete" is important to validation.</p>
</div>
<div class="sect3">
<h4 id="_completing_fields"><a class="anchor" href="#_completing_fields"></a><a class="link" href="#_completing_fields">18.3.1. Completing Fields</a></h4>
<div class="paragraph">
<p>Initially the form config will not consider <strong>any</strong> of the form fields to be complete. The idea of field "completion" is
so that you can prevent validation on a field until you feel it is a good time. No one wants to see error messages about
fields that they have yet to interact with!</p>
</div>
<div class="paragraph">
<p>However, depending on what you are editing, you may have different ideas about when fields should be considered complete.
For example, if you just loaded a saved entity from a server, then all of the fields are probably complete by definition,
meaning that you need a way to mark all fields (recursively) complete.</p>
</div>
<div class="paragraph">
<p>When you <strong>first</strong> add form config to an entity, all fields are "incomplete". You can iteratively mark fields
complete as the user interacts with them, or trigger a completion "event" all at once. There is a support function
and a mutation for this.</p>
</div>
<div class="paragraph">
<p>The <code>mark-complete*</code> is meant to be used from within mutations against the app state database. It requires the
state map (not atom), the entity&#8217;s ident, and which field you want to mark complete.  If you omit the field, then
it marks everything (recursively) complete form that form down.</p>
</div>
<div class="paragraph">
<p>So, in our earlier example of loading a person for editing, we&#8217;d augment that mutation like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation use-person-as-form [{<span class="symbol">:keys</span> [person-id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                   (<span class="keyword">-&gt;</span> s
                     (fs/add-form-config* PersonForm [<span class="symbol">:person/id</span> person-id])
                     <span class="comment">;; MUST come after the config is added. Mark all fields complete (since they came from existing entity)</span>
                     (fs/mark-complete* [<span class="symbol">:person/id</span> person-id])
                     <span class="comment">;; add it to some editor as the target</span>
                     (<span class="keyword">assoc-in</span> [<span class="symbol">:component</span> <span class="symbol">:person-editor</span> <span class="symbol">:person-to-edit</span>] [<span class="symbol">:person/id</span> person-id]))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and all validations will immediately apply in the UI.</p>
</div>
<div class="paragraph">
<p>The <code>mark-complete!</code> mutation can be used for the exact same purpose from the UI. Typically, it is used in things like
<code>:onBlur</code> handlers to indicate that a field is ready for validation. It takes an <code>:entity-ident</code> and <code>:field</code>.
The <code>:entity-ident</code> is optional if the transaction is invoked on the form component of that field, and if the <code>:field</code> is
not supplied it means to affect the entire form recursively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc PersonForm [this {<span class="symbol">:keys</span> [db/id person/name]}]
  <span class="keyword">..</span><span class="keyword">.</span> <span class="comment">; as before</span>

  <span class="comment">;; uses the ident of the current instance as the entity-ident</span>
  (dom/input {<span class="symbol">:value</span> <span class="keyword">name</span>
              <span class="symbol">:onBlur</span> #(comp/transact! this `[(fs/mark-complete! {<span class="symbol">:field</span> <span class="symbol">:person/name</span>})])})
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The inverse operations are <code>clear-complete!</code> and <code>clear-complete*</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="CustomValidators"><a class="anchor" href="#CustomValidators"></a><a class="link" href="#CustomValidators">18.3.2. Using non-spec Validators</a></h4>
<div class="paragraph">
<p>You may not wish to use the longer names of properties that are required in order to get stable Clojure Spec support
simply for form validation. In this case you&#8217;d still like to use the idea of field completion and validation, but
you&#8217;ll want to supply the mechanism whereby validity is determined.</p>
</div>
<div class="paragraph">
<p>The form traversal code for validation is already in the form state code, and a helper function is provided so
you can leverage it to create your own form validation system. It is quite simple:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a function <code>(fn [form field] &#8230;&#8203;)</code> that returns true if the given field (a keyword) is valid on the given form
(a map of the props for the form that contains that field).</p>
</li>
<li>
<p>Generate a validator with <code>fs/make-validator</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The returned validator works identically to <code>get-spec-validity</code>, but it uses your custom function instead of specs to
determine validity.</p>
</div>
<div class="paragraph">
<p>For example, you might want to make a simple new user form validation that looks something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">new-user-form-valid</span> [form field]
  (<span class="keyword">let</span> [v (<span class="keyword">get</span> form field)]
    (<span class="keyword">case</span> field
      <span class="symbol">:username</span> (<span class="keyword">and</span> (<span class="keyword">string?</span> v) (<span class="keyword">seq</span> (str/trim v))) <span class="comment">; not empty</span>
      <span class="symbol">:password</span> (<span class="keyword">&gt;</span> (<span class="keyword">count</span> v) <span class="integer">8</span>)                      <span class="comment">; longer than 8</span>
      <span class="symbol">:password-2</span> (<span class="keyword">=</span> v (<span class="symbol">:password</span> form)))))          <span class="comment">; passwords match</span>

(<span class="keyword">def</span> <span class="function">validator</span> (fs/make-validator new-user-form-valid))

(defsc NewUser [this {<span class="symbol">:keys</span> [username password password-2] <span class="symbol">:as</span> props}]
   <span class="keyword">..</span><span class="keyword">.</span>
   (dom/input {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">password-2</span><span class="delimiter">&quot;</span></span> <span class="symbol">:value</span> password-2 <span class="symbol">:onBlur</span> #(comp/transact! this `[(fs/mark-complete <span class="keyword">..</span><span class="keyword">.</span>)]) <span class="keyword">..</span><span class="keyword">.</span>})
   (<span class="keyword">when</span> (<span class="keyword">=</span> <span class="symbol">:invalid</span> (validator props <span class="symbol">:password-2</span>))
      (dom/span <span class="string"><span class="delimiter">&quot;</span><span class="content">Passwords do not match!</span><span class="delimiter">&quot;</span></span>)
   <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As before: you won&#8217;t see the error message on an invalid entry until your code has marked the field complete. This moves
a decent amount of clutter out of the primary UI code and into the form support itself.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_submitting_data"><a class="anchor" href="#_submitting_data"></a><a class="link" href="#_submitting_data">18.4. Submitting Data</a></h3>
<div class="paragraph">
<p>Once your form is valid and the user indicates a desire to save, then your interest shifts to sending that data to the
server. The <code>dirty-fields</code> function should be used from the UI in order to calculate this and pass it as a parameter
to a mutation. The mutation can then update the local pristine state of form config and indicate a remote operation.</p>
</div>
<div class="paragraph">
<p>The <code>dirty-fields</code> function returns a map from ident to fields that have changed. If the ident includes a temporary ID,
then all fields for that form will be included. If the ID is not a temp id, then it will only include those fields that
differ from the pristine copy of the original. This will include subform references as to-one or to-many idents (to
indicate the addition or removal of subform instances).</p>
</div>
<div class="paragraph">
<p>You can ask <code>dirty-fields</code> to either send the explicit new values (only), or a before/after picture of each field. The
latter is particularly useful for easily deriving the addition/removal of references, but is also quite useful if you
would like to do optimistic concurrency (e.g. not apply a change to a server where the old value wasn&#8217;t still in the
database).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation submit-person [{<span class="symbol">:keys</span> [id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state fs/entity-&gt;pristine* [<span class="symbol">:person/id</span> id])) <span class="comment">; updates form state to think the form is now in pristine shape</span>
  (remote [env] <span class="predefined-constant">true</span>)) <span class="comment">; diff goes over the network as a parameter from the UI layer</span>

(defsc Person [this props]
   <span class="keyword">..</span><span class="keyword">.</span> <span class="comment">; as before</span>
   (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(submit-person ~{<span class="symbol">:id</span> id <span class="symbol">:diff</span> (fs/dirty-fields props <span class="predefined-constant">true</span>)})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Submit</span><span class="delimiter">&quot;</span></span>)
   <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;d like to wait until the server indicates everything is ok, then you can use <code>ptransact!</code> and <code>returning</code> to get back
some submission information, and move the <code>entity&#8594;pristine*</code> step to a later mutation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; Exists purely as a way to return a value into a normalized state database...</span>
(defsc SubmissionStatus [_ _]
  {<span class="symbol">:query</span> [<span class="symbol">:id</span> <span class="symbol">:status</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:submission-status/id</span> <span class="symbol">:id</span>]})

(defmutation submit-person [{<span class="symbol">:keys</span> [id]}]
  (remote [{<span class="symbol">:keys</span> [ast state]] (com.fulcrologic.fulcro.mutations/returning ast @state SubmissionStatus))

(defmutation finish-person-submission [{<span class="symbol">:keys</span> [id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
     (<span class="keyword">if</span> (<span class="keyword">=</span> <span class="symbol">:ok</span> (<span class="keyword">get-in</span> @state [<span class="symbol">:submission-status/id</span> id <span class="symbol">:status</span>]))
       (<span class="keyword">swap!</span> state fs/entity-&gt;pristine* [<span class="symbol">:person/id</span> id])
       <span class="keyword">..</span><span class="keyword">.</span>))) <span class="comment">; else show some error</span>

<span class="keyword">..</span><span class="keyword">.</span>

(ptransact! this `[(submit-person ~{<span class="symbol">:id</span> id <span class="symbol">:diff</span> (fs/dirty-fields props <span class="predefined-constant">true</span>)})
                   (finish-person-submission ~{<span class="symbol">:id</span> id})])</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#PTransact">pessimistic transactions</a> for more details.</p>
</div>
<div class="paragraph">
<p>Of course, the behavior of the UI is up to you, and all of the examples above assume that the mutations in question would
also be changing other things in your form/editor to show status to the user as you go.  It should be relatively straightforward
to combine the form state maintenance functions with your own support functions and mutations to create your "standard" look
for form interactions across your application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_form_state_demos"><a class="anchor" href="#_form_state_demos"></a><a class="link" href="#_form_state_demos">18.5. Form State Demos</a></h3>
<div class="paragraph">
<p>The following two fully-functional demos show you complete code for two scenarios.</p>
</div>
<div class="sect3">
<h4 id="_selecting_an_entity_for_edit"><a class="anchor" href="#_selecting_an_entity_for_edit"></a><a class="link" href="#_selecting_an_entity_for_edit">18.5.1. Selecting an Entity for Edit</a></h4>
<div class="paragraph">
<p>A very common use case is the scenario where the entities are already loaded and are displayed in the UI. The user
clicks on an entry, and you take them to a form where they can edit the item.</p>
</div>
<div class="paragraph">
<p>This demo lists some phone numbers. Clicking on one:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adds form configuration to the entity</p>
</li>
<li>
<p>Switches the UI to the form editor</p>
</li>
<li>
<p>Switches back to the (updated) list on save</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 40. <a id="EditingExistingData"></a><a href="#EditingExistingData">Editing Existing Data</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('form-state-demo-1')">Focus Inspector</button>
<div class="short narrow example" id="form-state-demo-1"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.forms.form-state-demo-1</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.semantic-ui.modules.dropdown.ui-dropdown <span class="symbol">:as</span> dropdown]
    [book.elements <span class="symbol">:as</span> ele]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.algorithms.form-state <span class="symbol">:as</span> fs]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [cljs.spec.alpha <span class="symbol">:as</span> s]
    [taoensso.timbre <span class="symbol">:as</span> log]))

(<span class="keyword">declare</span> <span class="function">Root</span> PhoneForm)

(<span class="keyword">defn</span> <span class="function">field-attrs</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">A helper function for getting aspects of a particular field.</span><span class="delimiter">&quot;</span></span>
  [component field]
  (<span class="keyword">let</span> [form         (comp/props component)
        entity-ident (comp/get-ident component form)
        id           (<span class="keyword">str</span> (<span class="keyword">first</span> entity-ident) <span class="string"><span class="delimiter">&quot;</span><span class="content">-</span><span class="delimiter">&quot;</span></span> (<span class="keyword">second</span> entity-ident))
        is-dirty?    (fs/dirty? form field)
        clean?       (<span class="keyword">not</span> is-dirty?)
        validity     (fs/get-spec-validity form field)
        is-invalid?  (<span class="keyword">=</span> <span class="symbol">:invalid</span> validity)
        value        (<span class="keyword">get</span> form field <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)]
    {<span class="symbol">:dirty?</span>   is-dirty?
     <span class="symbol">:ident</span>    entity-ident
     <span class="symbol">:id</span>       id
     <span class="symbol">:clean?</span>   clean?
     <span class="symbol">:validity</span> validity
     <span class="symbol">:invalid?</span> is-invalid?
     <span class="symbol">:value</span>    value}))

(s/def <span class="symbol">:phone/number</span> #(<span class="keyword">re-matches</span> <span class="regexp"><span class="delimiter">#&quot;</span><span class="content">\(</span><span class="content">?[0-9]{3}[-.)]? *[0-9]{3}-?[0-9]{4}</span><span class="delimiter">&quot;</span></span> %))

(defmutation abort-phone-edit [{<span class="symbol">:keys</span> [id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                   (<span class="keyword">-&gt;</span> s
                     <span class="comment">; stop editing</span>
                     (<span class="keyword">dissoc</span> <span class="symbol">:root/phone</span>)
                     <span class="comment">; revert to the pristine state</span>
                     (fs/pristine-&gt;entity* [<span class="symbol">:phone/id</span> id])))))
  (refresh [env] [<span class="symbol">:root/phone</span>]))

(defmutation submit-phone [{<span class="symbol">:keys</span> [id delta]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                   (<span class="keyword">-&gt;</span> s
                     <span class="comment">; stop editing</span>
                     (<span class="keyword">dissoc</span> <span class="symbol">:root/phone</span>)
                     <span class="comment">; update the pristine state</span>
                     (fs/entity-&gt;pristine* [<span class="symbol">:phone/id</span> id])))))
  (remote [env] <span class="predefined-constant">true</span>)
  (refresh [env] [<span class="symbol">:root/phone</span> [<span class="symbol">:phone/id</span> id]]))

(<span class="keyword">defn</span> <span class="function">input-with-label</span>
  [component field label validation-message input]
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [dirty? invalid?]} (field-attrs component field)]
    (comp/fragment
      (dom/div <span class="symbol">:.</span>field {<span class="symbol">:classes</span> [(<span class="keyword">when</span> invalid? <span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>) (<span class="keyword">when</span> dirty? <span class="string"><span class="delimiter">&quot;</span><span class="content">warning</span><span class="delimiter">&quot;</span></span>)]}
        (dom/label {<span class="symbol">:htmlFor</span> (<span class="keyword">str</span> field)} label)
        input)
      (<span class="keyword">when</span> invalid?
        (dom/div <span class="symbol">:.</span>ui.error.message {} validation-message))
      (<span class="keyword">when</span> dirty?
        (dom/div <span class="symbol">:.</span>ui.warning.message {} <span class="string"><span class="delimiter">&quot;</span><span class="content">(dirty)</span><span class="delimiter">&quot;</span></span>)))))

(defsc PhoneForm [this {<span class="symbol">:phone/keys</span> [id <span class="keyword">type</span> number] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span>       [<span class="symbol">:phone/id</span> <span class="symbol">:phone/type</span> <span class="symbol">:phone/number</span> fs/form-config-join]
   <span class="symbol">:form-fields</span> #{<span class="symbol">:phone/number</span> <span class="symbol">:phone/type</span>}
   <span class="symbol">:ident</span>       <span class="symbol">:phone/id</span>}
  (<span class="keyword">let</span> [dirty?   (fs/dirty? props)
        invalid? (<span class="keyword">=</span> <span class="symbol">:invalid</span> (fs/get-spec-validity props))]
    (dom/div <span class="symbol">:.</span>ui.form {<span class="symbol">:classes</span> [(<span class="keyword">when</span> invalid? <span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>) (<span class="keyword">when</span> dirty? <span class="string"><span class="delimiter">&quot;</span><span class="content">warning</span><span class="delimiter">&quot;</span></span>)]}
      (input-with-label this <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Phone:</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">10-digit phone number is required.</span><span class="delimiter">&quot;</span></span>
        (dom/input {<span class="symbol">:value</span>    (<span class="keyword">or</span> (<span class="keyword">str</span> number) <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
                    <span class="symbol">:onChange</span> #(m/set-string! this <span class="symbol">:phone/number</span> <span class="symbol">:event</span> %)}))
      (input-with-label this <span class="symbol">:phone/type</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Type:</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>
        (dropdown/ui-dropdown {<span class="symbol">:value</span>     (<span class="keyword">name</span> <span class="keyword">type</span>)
                               <span class="symbol">:selection</span> <span class="predefined-constant">true</span>
                               <span class="symbol">:options</span>   [{<span class="symbol">:text</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Home</span><span class="delimiter">&quot;</span></span> <span class="symbol">:value</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">home</span><span class="delimiter">&quot;</span></span>}
                                           {<span class="symbol">:text</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Work</span><span class="delimiter">&quot;</span></span> <span class="symbol">:value</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">work</span><span class="delimiter">&quot;</span></span>}]
                               <span class="symbol">:onChange</span>  (<span class="keyword">fn</span> [_ v]
                                            (<span class="keyword">when-let</span> [v (some-&gt; (<span class="keyword">.</span>-value v) <span class="keyword">keyword</span>)]
                                              (m/set-value! this <span class="symbol">:phone/type</span> v)))}))
      (dom/button <span class="symbol">:.</span>ui.button {<span class="symbol">:onClick</span> #(comp/transact! this [(abort-phone-edit {<span class="symbol">:id</span> id})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Cancel</span><span class="delimiter">&quot;</span></span>)
      (dom/button <span class="symbol">:.</span>ui.button {<span class="symbol">:disabled</span> (<span class="keyword">or</span> (<span class="keyword">not</span> (fs/checked? props)) (fs/invalid-spec? props))
                               <span class="symbol">:onClick</span>  #(comp/transact! this [(submit-phone {<span class="symbol">:id</span> id <span class="symbol">:delta</span> (fs/dirty-fields props <span class="predefined-constant">true</span>)})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Commit!</span><span class="delimiter">&quot;</span></span>))))

(<span class="keyword">def</span> <span class="function">ui-phone-form</span> (comp/factory PhoneForm {<span class="symbol">:keyfn</span> <span class="symbol">:phone/id</span>}))

(defsc PhoneNumber [this {<span class="symbol">:phone/keys</span> [id <span class="keyword">type</span> number]} {<span class="symbol">:keys</span> [onSelect]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:phone/id</span> <span class="symbol">:phone/number</span> <span class="symbol">:phone/type</span>]
   <span class="symbol">:initial-state</span> {<span class="symbol">:phone/id</span> <span class="symbol">:param/id</span> <span class="symbol">:phone/number</span> <span class="symbol">:param/number</span> <span class="symbol">:phone/type</span> <span class="symbol">:param/type</span>}
   <span class="symbol">:ident</span>         <span class="symbol">:phone/id</span>}
  (dom/li <span class="symbol">:.</span>ui.item
    (dom/a {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> [] (onSelect id))}
      (<span class="keyword">str</span> number <span class="string"><span class="delimiter">&quot;</span><span class="content"> (</span><span class="delimiter">&quot;</span></span> (<span class="keyword">get</span> {<span class="symbol">:home</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Home</span><span class="delimiter">&quot;</span></span> <span class="symbol">:work</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Work</span><span class="delimiter">&quot;</span></span> <span class="predefined-constant">nil</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown</span><span class="delimiter">&quot;</span></span>} <span class="keyword">type</span>) <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>))))

(<span class="keyword">def</span> <span class="function">ui-phone-number</span> (comp/factory PhoneNumber {<span class="symbol">:keyfn</span> <span class="symbol">:phone/id</span>}))

(defsc PhoneBook [this {<span class="symbol">:phonebook/keys</span> [id phone-numbers]} {<span class="symbol">:keys</span> [onSelect]}]
  {<span class="symbol">:query</span>         [<span class="symbol">:phonebook/id</span> {<span class="symbol">:phonebook/phone-numbers</span> (comp/get-query PhoneNumber)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:phonebook/id</span>            <span class="symbol">:main</span>
                   <span class="symbol">:phonebook/phone-numbers</span> [{<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">541-555-1212</span><span class="delimiter">&quot;</span></span> <span class="symbol">:type</span> <span class="symbol">:home</span>}
                                             {<span class="symbol">:id</span> <span class="integer">2</span> <span class="symbol">:number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">541-555-5533</span><span class="delimiter">&quot;</span></span> <span class="symbol">:type</span> <span class="symbol">:work</span>}]}
   <span class="symbol">:ident</span>         <span class="symbol">:phonebook/id</span>}
  (dom/div
    (dom/h4 <span class="string"><span class="delimiter">&quot;</span><span class="content">Phone Book (click a number to edit)</span><span class="delimiter">&quot;</span></span>)
    (dom/ul
      (<span class="keyword">map</span> (<span class="keyword">fn</span> [n] (ui-phone-number (comp/computed n {<span class="symbol">:onSelect</span> onSelect}))) phone-numbers))))

(<span class="keyword">def</span> <span class="function">ui-phone-book</span> (comp/factory PhoneBook {<span class="symbol">:keyfn</span> <span class="symbol">:phonebook/id</span>}))

(defmutation edit-phone-number [{<span class="symbol">:keys</span> [id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">let</span> [phone-type (<span class="keyword">get-in</span> @state [<span class="symbol">:phone/id</span> id <span class="symbol">:phone/type</span>])]
      (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                     (<span class="keyword">-&gt;</span> s
                       <span class="comment">; make sure the form config is with the entity</span>
                       (fs/add-form-config* PhoneForm [<span class="symbol">:phone/id</span> id])
                       <span class="comment">; since we're editing an existing thing, we should start it out complete (validations apply)</span>
                       (fs/mark-complete* [<span class="symbol">:phone/id</span> id])
                       <span class="comment">; tell the root UI that we're editing a phone number by linking it in</span>
                       (<span class="keyword">assoc</span> <span class="symbol">:root/phone</span> [<span class="symbol">:phone/id</span> id])))))))

(defsc Root [this {<span class="symbol">:keys</span> [<span class="symbol">:root/phone</span> <span class="symbol">:root/phonebook</span>]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:root/phonebook</span> (comp/get-query PhoneBook)}
                   {<span class="symbol">:root/phone</span> (comp/get-query PhoneForm)}]
   <span class="symbol">:initial-state</span> {<span class="symbol">:root/phonebook</span> {}
                   <span class="symbol">:root/phone</span>     {}}}
  (ele/ui-iframe {<span class="symbol">:frameBorder</span> <span class="integer">0</span> <span class="symbol">:width</span> <span class="integer">500</span> <span class="symbol">:height</span> <span class="integer">400</span>}
    (dom/div
      (dom/link {<span class="symbol">:rel</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">stylesheet</span><span class="delimiter">&quot;</span></span> <span class="symbol">:href</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css</span><span class="delimiter">&quot;</span></span>})
      (<span class="keyword">if</span> (<span class="keyword">contains?</span> phone <span class="symbol">:phone/number</span>)
        (ui-phone-form phone)
        (ui-phone-book (comp/computed phonebook {<span class="symbol">:onSelect</span> (<span class="keyword">fn</span> [id] (comp/transact! this [(edit-phone-number {<span class="symbol">:id</span> id})]))}))))))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_loading_or_creating_something_new"><a class="anchor" href="#_loading_or_creating_something_new"></a><a class="link" href="#_loading_or_creating_something_new">18.5.2. Loading or Creating Something New</a></h4>
<div class="paragraph">
<p>This example shows the case where a graph of entities (a person and multiple phone numbers) are to be
created in a UI, or are to be loaded from a server. This is a full-stack example, though it doesn&#8217;t actually persist
the data (it just prints what the server receives in the Javascript console).</p>
</div>
<div class="paragraph">
<p>There are two buttons. One will load an existing entity into the editor, and of course submissions will send a minimal
delta. The other button will create a new person, and submissions will send all fields.</p>
</div>
<div class="paragraph">
<p>The load case, as you can see in the code, is very similar to the prior example, but just includes some extra
code to show you how to put it together with a load interaction.</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. <a id="NetworkInteractionsandForms"></a><a href="#NetworkInteractionsandForms">Network Interactions and Forms</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('form-state-demo-2')">Focus Inspector</button>
<div class="short narrow example" id="form-state-demo-2"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.forms.form-state-demo-2</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.semantic-ui.modules.dropdown.ui-dropdown <span class="symbol">:as</span> dropdown]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.algorithms.form-state <span class="symbol">:as</span> fs]
    [com.fulcrologic.fulcro.algorithms.tempid <span class="symbol">:as</span> tempid]
    [clojure.string <span class="symbol">:as</span> <span class="keyword">str</span>]
    [cljs.spec.alpha <span class="symbol">:as</span> s]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [book.elements <span class="symbol">:as</span> ele]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; Server Code</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="comment">; a simple query for any person, that will return valid-looking data</span>
(pc/defresolver person-resolver [env {<span class="symbol">:person/keys</span> [id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/name</span> <span class="symbol">:person/age</span> <span class="symbol">:person/phone-numbers</span>]}
  {<span class="symbol">:person/id</span>            id
   <span class="symbol">:person/name</span>          (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">User </span><span class="delimiter">&quot;</span></span> id)
   <span class="symbol">:person/age</span>           <span class="integer">56</span>
   <span class="symbol">:person/phone-numbers</span> [{<span class="symbol">:phone/id</span> <span class="integer">1</span> <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">555-111-1212</span><span class="delimiter">&quot;</span></span> <span class="symbol">:phone/type</span> <span class="symbol">:work</span>}
                          {<span class="symbol">:phone/id</span> <span class="integer">2</span> <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">555-333-4444</span><span class="delimiter">&quot;</span></span> <span class="symbol">:phone/type</span> <span class="symbol">:home</span>}]})

(<span class="keyword">defonce</span> <span class="function">id</span> (<span class="keyword">atom</span> <span class="integer">1000</span>))
(<span class="keyword">defn</span> <span class="function">next-id</span> [] (<span class="keyword">swap!</span> id <span class="keyword">inc</span>))

<span class="comment">; Server submission...just prints delta for demo, and remaps tempids (forms with tempids are always considered dirty)</span>
(pc/defmutation submit-person-mutation [env inputs]
  {<span class="symbol">::pc/sym</span> `submit-person}
  (<span class="keyword">let</span> [params (<span class="keyword">-&gt;</span> env <span class="symbol">:ast</span> <span class="symbol">:params</span>)]
    (js/console.log <span class="string"><span class="delimiter">&quot;</span><span class="content">Server received form submission with content: </span><span class="delimiter">&quot;</span></span>)
    (cljs.pprint/pprint params)
    (<span class="keyword">let</span> [ids    (<span class="keyword">map</span> (<span class="keyword">fn</span> [[k v]] (<span class="keyword">second</span> k)) (<span class="symbol">:diff</span> params))
          remaps (<span class="keyword">into</span> {} (keep (<span class="keyword">fn</span> [v] (<span class="keyword">when</span> (tempid/tempid? v) [v (next-id)])) ids))]
      {<span class="symbol">:tempids</span> remaps})))

(<span class="keyword">def</span> <span class="function">resolvers</span> [person-resolver submit-person-mutation])

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; Client Code</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(s/def <span class="symbol">:person/name</span> (s/and <span class="keyword">string?</span> #(<span class="keyword">seq</span> (str/trim %))))
(s/def <span class="symbol">:person/age</span> #(s/int-in-range? <span class="integer">1</span> <span class="integer">120</span> %))

(<span class="keyword">defn</span> <span class="function">field-attrs</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">A helper function for getting aspects of a particular field.</span><span class="delimiter">&quot;</span></span>
  [component field]
  (<span class="keyword">let</span> [form         (comp/props component)
        entity-ident (comp/get-ident component form)
        id           (<span class="keyword">str</span> (<span class="keyword">first</span> entity-ident) <span class="string"><span class="delimiter">&quot;</span><span class="content">-</span><span class="delimiter">&quot;</span></span> (<span class="keyword">second</span> entity-ident))
        is-dirty?    (fs/dirty? form field)
        clean?       (<span class="keyword">not</span> is-dirty?)
        validity     (fs/get-spec-validity form field)
        is-invalid?  (<span class="keyword">=</span> <span class="symbol">:invalid</span> validity)
        value        (<span class="keyword">get</span> form field <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)]
    {<span class="symbol">:dirty?</span>   is-dirty?
     <span class="symbol">:ident</span>    entity-ident
     <span class="symbol">:id</span>       id
     <span class="symbol">:clean?</span>   clean?
     <span class="symbol">:validity</span> validity
     <span class="symbol">:invalid?</span> is-invalid?
     <span class="symbol">:value</span>    value}))

(<span class="keyword">def</span> <span class="function">integer-fields</span> #{<span class="symbol">:person/age</span>})

(<span class="keyword">defn</span> <span class="function">input-with-label</span>
  [component field label validation-message input]
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [dirty? invalid?]} (field-attrs component field)]
    (comp/fragment
      (dom/div <span class="symbol">:.</span>field {<span class="symbol">:classes</span> [(<span class="keyword">when</span> invalid? <span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>) (<span class="keyword">when</span> dirty? <span class="string"><span class="delimiter">&quot;</span><span class="content">warning</span><span class="delimiter">&quot;</span></span>)]}
        (dom/label {<span class="symbol">:htmlFor</span> (<span class="keyword">str</span> field)} label)
        input)
      (<span class="keyword">when</span> invalid?
        (dom/div <span class="symbol">:.</span>ui.error.message {} validation-message))
      (<span class="keyword">when</span> dirty?
        (dom/div <span class="symbol">:.</span>ui.warning.message {} <span class="string"><span class="delimiter">&quot;</span><span class="content">(dirty)</span><span class="delimiter">&quot;</span></span>)))))

(s/def <span class="symbol">:phone/number</span> #(<span class="keyword">re-matches</span> <span class="regexp"><span class="delimiter">#&quot;</span><span class="content">\(</span><span class="content">?[0-9]{3}[-.)]? *[0-9]{3}-?[0-9]{4}</span><span class="delimiter">&quot;</span></span> %))

(defsc PhoneForm [this {<span class="symbol">:phone/keys</span> [id number <span class="keyword">type</span>] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span>       [<span class="symbol">:phone/id</span> <span class="symbol">:phone/number</span> <span class="symbol">:phone/type</span> fs/form-config-join]
   <span class="symbol">:form-fields</span> #{<span class="symbol">:phone/number</span> <span class="symbol">:phone/type</span>}
   <span class="symbol">:ident</span>       <span class="symbol">:phone/id</span>}
  (dom/div <span class="symbol">:.</span>ui.segment
    (dom/div <span class="symbol">:.</span>ui.form
      (input-with-label this <span class="symbol">:phone/number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Phone:</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">10-digit phone number is required.</span><span class="delimiter">&quot;</span></span>
        (dom/input {<span class="symbol">:value</span>    (<span class="keyword">or</span> (<span class="keyword">str</span> number) <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
                    <span class="symbol">:onBlur</span>   #(comp/transact! this [(fs/mark-complete! {<span class="symbol">:entity-ident</span> [<span class="symbol">:phone/id</span> id]
                                                                         <span class="symbol">:field</span>        <span class="symbol">:phone/number</span>})])
                    <span class="symbol">:onChange</span> #(m/set-string! this <span class="symbol">:phone/number</span> <span class="symbol">:event</span> %)}))
      (input-with-label this <span class="symbol">:phone/type</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Type:</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>
        (dropdown/ui-dropdown {<span class="symbol">:value</span>     (<span class="keyword">name</span> <span class="keyword">type</span>)
                               <span class="symbol">:selection</span> <span class="predefined-constant">true</span>
                               <span class="symbol">:options</span>   [{<span class="symbol">:text</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Home</span><span class="delimiter">&quot;</span></span> <span class="symbol">:value</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">home</span><span class="delimiter">&quot;</span></span>}
                                           {<span class="symbol">:text</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Work</span><span class="delimiter">&quot;</span></span> <span class="symbol">:value</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">work</span><span class="delimiter">&quot;</span></span>}]
                               <span class="symbol">:onChange</span>  (<span class="keyword">fn</span> [_ v]
                                            (<span class="keyword">when-let</span> [v (some-&gt; (<span class="keyword">.</span>-value v) <span class="keyword">keyword</span>)]
                                              (m/set-value! this <span class="symbol">:phone/type</span> v)
                                              (comp/transact! this [(fs/mark-complete! {<span class="symbol">:field</span> <span class="symbol">:phone/type</span>})])))})))))

(<span class="keyword">def</span> <span class="function">ui-phone-form</span> (comp/factory PhoneForm {<span class="symbol">:keyfn</span> <span class="symbol">:phone/id</span>}))

(<span class="keyword">defn</span> <span class="function">add-phone*</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Add the given phone info to a person.</span><span class="delimiter">&quot;</span></span>
  [state-map phone-id person-id <span class="keyword">type</span> number]
  (<span class="keyword">let</span> [phone-ident      [<span class="symbol">:phone/id</span> phone-id]
        new-phone-entity {<span class="symbol">:phone/id</span> phone-id <span class="symbol">:phone/type</span> <span class="keyword">type</span> <span class="symbol">:phone/number</span> number}]
    (<span class="keyword">-&gt;</span> state-map
      (<span class="keyword">update-in</span> [<span class="symbol">:person/id</span> person-id <span class="symbol">:person/phone-numbers</span>] (fnil <span class="keyword">conj</span> []) phone-ident)
      (<span class="keyword">assoc-in</span> phone-ident new-phone-entity))))

(defmutation add-phone
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Mutation: Add a phone number to a person, and initialize it as a working form.</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [person-id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">let</span> [phone-id (tempid/tempid)]
      (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                     (<span class="keyword">-&gt;</span> s
                       (add-phone* phone-id person-id <span class="symbol">:home</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
                       (fs/add-form-config* PhoneForm [<span class="symbol">:phone/id</span> phone-id])))))))

(defsc PersonForm [this {<span class="symbol">:person/keys</span> [id <span class="keyword">name</span> age phone-numbers]}]
  {<span class="symbol">:query</span>       [<span class="symbol">:person/id</span> <span class="symbol">:person/name</span> <span class="symbol">:person/age</span>
                 {<span class="symbol">:person/phone-numbers</span> (comp/get-query PhoneForm)}
                 fs/form-config-join]
   <span class="symbol">:form-fields</span> #{<span class="symbol">:person/name</span> <span class="symbol">:person/age</span> <span class="symbol">:person/phone-numbers</span>} <span class="comment">; phone-numbers here becomes a subform because it is a join in the query.</span>
   <span class="symbol">:ident</span>       <span class="symbol">:person/id</span>}
  (dom/div <span class="symbol">:.</span>ui.form
    (input-with-label this <span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Name:</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Name is required.</span><span class="delimiter">&quot;</span></span>
      (dom/input {<span class="symbol">:value</span> (<span class="keyword">or</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)}))
    (input-with-label this <span class="symbol">:person/age</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Age:</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Age must be between 1 and 120</span><span class="delimiter">&quot;</span></span>
      (dom/input {<span class="symbol">:value</span> (<span class="keyword">or</span> age <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)}))
    (dom/h4 <span class="string"><span class="delimiter">&quot;</span><span class="content">Phone numbers:</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">when</span> (<span class="keyword">seq</span> phone-numbers)
      (<span class="keyword">map</span> ui-phone-form phone-numbers))
    (dom/button <span class="symbol">:.</span>ui.button {<span class="symbol">:onClick</span> #(comp/transact! this `[(add-phone {<span class="symbol">:person-id</span> ~id})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">+</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">def</span> <span class="function">ui-person-form</span> (comp/factory PersonForm {<span class="symbol">:keyfn</span> <span class="symbol">:person/id</span>}))

(<span class="keyword">defn</span> <span class="function">add-person*</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Add a person with the given details to the state database.</span><span class="delimiter">&quot;</span></span>
  [state-map id <span class="keyword">name</span> age]
  (<span class="keyword">let</span> [person-ident [<span class="symbol">:person/id</span> id]
        person       {<span class="symbol">:db/id</span> id <span class="symbol">:person/name</span> <span class="keyword">name</span> <span class="symbol">:person/age</span> age}]
    (<span class="keyword">assoc-in</span> state-map person-ident person)))

(defmutation edit-new-person [_]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">let</span> [person-id    (tempid/tempid)
          person-ident [<span class="symbol">:person/id</span> person-id]
          phone-id     (tempid/tempid)]
      (<span class="keyword">swap!</span> state
        (<span class="keyword">fn</span> [s] (<span class="keyword">-&gt;</span> s
                  (add-person* person-id <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> <span class="integer">0</span>)
                  (add-phone* phone-id person-id <span class="symbol">:home</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
                  (<span class="keyword">assoc</span> <span class="symbol">:root/person</span> person-ident)         <span class="comment">; join it into the UI as the person to edit</span>
                  (fs/add-form-config* PersonForm [<span class="symbol">:person/id</span> person-id])))))))

(defmutation edit-existing-person
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Turn an existing person with phone numbers into an editable form with phone subforms.</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [person-id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state
      (<span class="keyword">fn</span> [s] (<span class="keyword">-&gt;</span> s
                (<span class="keyword">assoc</span> <span class="symbol">:root/person</span> [<span class="symbol">:person/id</span> person-id])
                (fs/add-form-config* PersonForm [<span class="symbol">:person/id</span> person-id]) <span class="comment">; will not re-add config to entities that were present</span>
                (fs/entity-&gt;pristine* [<span class="symbol">:person/id</span> person-id]) <span class="comment">; in case we're re-loading it, make sure the pristine copy it up-to-date</span>
                <span class="comment">;; it just came from server, so all fields should be valid</span>
                (fs/mark-complete* [<span class="symbol">:person/id</span> person-id]))))))

(defmutation submit-person [{<span class="symbol">:keys</span> [id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state fs/entity-&gt;pristine* [<span class="symbol">:person/id</span> id]))
  (remote [env] <span class="predefined-constant">true</span>))

(defsc Root [this {<span class="symbol">:keys</span> [root/person]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:root/person</span> (comp/get-query PersonForm)}]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {})}
  (ele/ui-iframe {<span class="symbol">:frameBorder</span> <span class="integer">0</span> <span class="symbol">:width</span> <span class="integer">800</span> <span class="symbol">:height</span> <span class="integer">820</span>}
    (dom/div <span class="symbol">:.</span>ui.container.segments
      (dom/link {<span class="symbol">:rel</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">stylesheet</span><span class="delimiter">&quot;</span></span> <span class="symbol">:href</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css</span><span class="delimiter">&quot;</span></span>})
      (dom/button <span class="symbol">:.</span>ui.button
        {<span class="symbol">:onClick</span> #(df/load! this [<span class="symbol">:person/id</span> <span class="integer">21</span>] PersonForm {<span class="symbol">:target</span>               [<span class="symbol">:root/person</span>]
                                                              <span class="symbol">:marker</span>               <span class="predefined-constant">false</span>
                                                              <span class="symbol">:post-mutation</span>        `edit-existing-person
                                                              <span class="symbol">:post-mutation-params</span> {<span class="symbol">:person-id</span> <span class="integer">21</span>}})}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Simulate Edit (existing) Person from Server</span><span class="delimiter">&quot;</span></span>)
      (dom/button <span class="symbol">:.</span>ui.buton {<span class="symbol">:onClick</span> #(comp/transact! this `[(edit-new-person {})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Simulate New Person Creation</span><span class="delimiter">&quot;</span></span>)

      (<span class="keyword">when</span> (<span class="symbol">:person/name</span> person)
        (dom/div <span class="symbol">:.</span>ui.segment
          (ui-person-form person)))

      (dom/div <span class="symbol">:.</span>ui.segment
        (dom/button <span class="symbol">:.</span>ui.button {<span class="symbol">:onClick</span>  #(comp/transact! this `[(fs/reset-form! {<span class="symbol">:form-ident</span> [<span class="symbol">:person/id</span> ~(<span class="symbol">:db/id</span> person)]})])
                                 <span class="symbol">:disabled</span> (<span class="keyword">not</span> (fs/dirty? person))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Reset</span><span class="delimiter">&quot;</span></span>)
        (dom/button <span class="symbol">:.</span>ui.button {<span class="symbol">:onClick</span>  #(comp/transact! this `[(submit-person {<span class="symbol">:id</span> ~(<span class="symbol">:db/id</span> person) <span class="symbol">:diff</span> ~(fs/dirty-fields person <span class="predefined-constant">false</span>)})])
                                 <span class="symbol">:disabled</span> (<span class="keyword">or</span>
                                             (fs/invalid-spec? person)
                                             (<span class="keyword">not</span> (fs/dirty? person)))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Submit</span><span class="delimiter">&quot;</span></span>)))))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_full_stack_form_demo"><a class="anchor" href="#_full_stack_form_demo"></a><a class="link" href="#_full_stack_form_demo">18.6. Full Stack Form Demo</a></h3>
<div class="paragraph">
<p>TODO: Rewrite to use form-state</p>
</div>
<div class="sect3">
<h4 id="_application_load"><a class="anchor" href="#_application_load"></a><a class="link" href="#_application_load">18.6.1. Application Load</a></h4>
<div class="paragraph">
<p>When the application loads it uses <code>data-fetch/load</code> to query the server for
<code>:all-numbers</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load app <span class="symbol">:all-numbers</span> PhoneDisplayRow {<span class="symbol">:target</span> [<span class="symbol">:screen/phone-list</span> <span class="symbol">:tab</span> <span class="symbol">:phone-numbers</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have a very simple database that looks like this on the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">make-phone-number</span> [id <span class="keyword">type</span> <span class="keyword">num</span>]
  {<span class="symbol">:db/id</span> id <span class="symbol">:phone/type</span> <span class="keyword">type</span> <span class="symbol">:phone/number</span> <span class="keyword">num</span>})

(<span class="keyword">defonce</span> <span class="function">server-state</span> (<span class="keyword">atom</span> {<span class="symbol">:all-numbers</span> [(make-phone-number <span class="integer">1</span> <span class="symbol">:home</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">555-1212</span><span class="delimiter">&quot;</span></span>)
                                           (make-phone-number <span class="integer">2</span> <span class="symbol">:home</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">555-1213</span><span class="delimiter">&quot;</span></span>)
                                           (make-phone-number <span class="integer">3</span> <span class="symbol">:home</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">555-1214</span><span class="delimiter">&quot;</span></span>)
                                           (make-phone-number <span class="integer">4</span> <span class="symbol">:home</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">555-1215</span><span class="delimiter">&quot;</span></span>)]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The server query handler is just:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; TODO: PATHOM</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_ui"><a class="anchor" href="#_the_ui"></a><a class="link" href="#_the_ui">18.6.2. The UI</a></h4>
<div class="paragraph">
<p>We&#8217;re using a UI router via defsc-router to create two screens: A phone list and phone editor screen.</p>
</div>
<div class="paragraph">
<p>The basic UI tree looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">           Root
             <span class="error">|</span>
       TopLevelRouter
         <span class="keyword">/</span>          <span class="char">\\</span>
  PhoneEditor     PhoneList
      <span class="error">|</span>               <span class="keyword">/</span> <span class="error">|</span> <span class="char">\\</span>
  PhoneForm       PhoneDisplayRow.<span class="keyword">..</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The UI starts out showing PhoneList. Clicking on an element leads to editing.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_mutations"><a class="anchor" href="#_the_mutations"></a><a class="link" href="#_the_mutations">18.6.3. The Mutations</a></h4>
<div class="paragraph">
<p>Note: PhoneForm and PhoneDisplayRow share the same ident since they render two differing views
of the same entity in our database.</p>
</div>
<div class="sect4">
<h5 id="_editing"><a class="anchor" href="#_editing"></a><a class="link" href="#_editing">Editing</a></h5>
<div class="paragraph">
<p>Since the phone numbers were loaded from raw data on a server, they are not form capable yet.</p>
</div>
<div class="paragraph">
<p>Thus, the application must do a few things in order for editing to work:</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_commit_and_reset"><a class="anchor" href="#_commit_and_reset"></a><a class="link" href="#_commit_and_reset">18.6.4. Commit and Reset</a></h4>
<div class="paragraph">
<p>TODO: example</p>
</div>
<div class="paragraph">
<p>;; ================================================================================
;; TODO: SSR Needs review:
;; ================================================================================</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_server_side_rendering"><a class="anchor" href="#_server_side_rendering"></a><a class="link" href="#_server_side_rendering">19. Server-side Rendering</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Single-page applications have a couple of concerns when it comes to how they behave on the internet at large.</p>
</div>
<div class="paragraph">
<p>The first is size. It is not unusual for a SPA to be several megabytes in size. This means that users on
slow networks may wait a while before they see anything useful. Network speeds are continually on the rise
(from less than 1kbps in the 80&#8217;s to an average of about 10Mbps today). This is becoming less and less of an issue,
and if this is your only concern, then it might be poor accounting to complicate your application just to shave
a few ms off the initial load. After all, with proper serving you can get their browser to cache the js file
for all but the first load of your site.</p>
</div>
<div class="paragraph">
<p>The second more important concern is SEO. If you have pages on your application that do not require login and you
would like to have in search engines, then a blank HTML page with a javascript file isn&#8217;t going to cut it.</p>
</div>
<div class="paragraph">
<p>Fortunately, Fulcro has you covered! Server-side rendering not only works well in Fulcro, the central mechanisms of
Fulcro (a client-side database with mutations) and the fact that you&#8217;re writing in one language actually make
server-side rendering shockingly simple, even for pages that require data from a server-side store! After all,
all of the functions and UI component queries needed to normalize the tree that you already know how to generate on
your server can be in CLJC files and can be used without writing anything new!</p>
</div>
<div class="paragraph">
<p>If you&#8217;re writing your UI in CLJC files in 2.5 to support server-side rendering then you need to make sure you use a conditional
reader to pull in the proper server DOM functions for Clojure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.ui</span>
  (<span class="symbol">:require</span> <span class="error">#</span>?(<span class="symbol">:clj</span> [com.fulcrologic.fulcro.dom-server <span class="symbol">:as</span> dom] <span class="symbol">:cljs</span> [fulcro.client.dom <span class="symbol">:as</span> dom]))</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_recommendations"><a class="anchor" href="#_recommendations"></a><a class="link" href="#_recommendations">19.1. Recommendations</a></h3>
<div class="paragraph">
<p>In order to get the most out of your code base when supporting server-side rendering, here are some general recommendations
about how to write your application. These are pretty much what we recommend for all applications, but they&#8217;re particularly
important for server-side rendering:</p>
</div>
<div class="sect3">
<h4 id="_use_initial_state_on_components_that_appear_on_client_start"><a class="anchor" href="#_use_initial_state_on_components_that_appear_on_client_start"></a><a class="link" href="#_use_initial_state_on_components_that_appear_on_client_start">19.1.1. Use Initial State on Components That Appear on Client Start</a></h4>
<div class="paragraph">
<p>This is true for every application. We always encourage it. It helps with refactoring, initial startup, etc. When
doing server-side rendering you won&#8217;t need this initial state on the client (the server will push a built-up state);
however, the server does need the base minimum database on which it will build the state for the page that will
be rendered.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
For SSR you will <strong>move</strong> initial state from <strong>just</strong> your <code>Root</code> node to a function. The reason for this
is that Fulcro ignores explicit application state at startup if it can find initial state on the root node, and
we want to force state into the client.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This will become clearer when we get to examples.</p>
</div>
</div>
<div class="sect3">
<h4 id="_write_mutations_via_helper_functions_on_state_maps"><a class="anchor" href="#_write_mutations_via_helper_functions_on_state_maps"></a><a class="link" href="#_write_mutations_via_helper_functions_on_state_maps">19.1.2. Write Mutations via Helper Functions on State Maps</a></h4>
<div class="paragraph">
<p>When writing a mutation, first write a helper function. Perhaps end its name with <code>-impl</code> or even <code><strong></code>. The
helper function should take the application database state map (*not</strong> atom) and any arguments needed to accomplish the
task. It should then return the updated state map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; in a CLJC file!</span>
(<span class="keyword">defn</span> <span class="function">todo-set-checked-impl</span> [state-map todo-id checked?]
   (<span class="keyword">assoc-in</span> state-map [<span class="symbol">:todo/id</span> todo-id <span class="symbol">:item/checked?</span>] checked?))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then write your mutation using that function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; CLJS-only, either separate file or conditionally in CLJC</span>
(defmutation todo-set-checked [{<span class="symbol">:keys</span> [id checked?]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state todo-set-checked-impl id checked?)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This has a very positive effect on your code: composition and re-use!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; composition</span>
(defmutation do-things [params]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s] (<span class="keyword">-&gt;</span> s
                             (do-thing-1-impl)
                             (do-thing-2-impl)
                             <span class="keyword">..</span><span class="keyword">.</span>))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course composition is re-use, but now that your client db mutation implementation is available in clj and cljs you
can use it to initialize state for your server-side render!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The new mutation <code>^:intern</code> support also gives you a way to get a function that applies the mutations actions
on a state atom.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_use_html5_routing"><a class="anchor" href="#_use_html5_routing"></a><a class="link" href="#_use_html5_routing">19.1.3. Use HTML5 Routing</a></h4>
<div class="paragraph">
<p>You have to be able to detect the different pages via URL, and your application also needs to respond to them. As a
result you will need to make all of the pages that are capable of server-side also have some distinct URI representation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_overall_structure"><a class="anchor" href="#_overall_structure"></a><a class="link" href="#_overall_structure">19.2. Overall Structure</a></h3>
<div class="paragraph">
<p>Here&#8217;s how to structure your application to support SSR:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Follow the above recommendations for the base code</p>
</li>
<li>
<p>The server will use the client initial app state plus a sequence of mutation implementations to build a normalized database</p>
</li>
<li>
<p>The server will serve the same basic HTML page (from code) that has the following:</p>
<div class="ulist">
<ul>
<li>
<p>The CSS and other head-related stuff and the div on which your app will mount.</p>
</li>
<li>
<p>A div with the ID of your SPA&#8217;s target mount, which will contain the HTML of the server-rendered application state</p>
</li>
<li>
<p>A script at the top that embeds the normalized db as a transit-encoded string on <code>js/window</code>.</p>
</li>
<li>
<p>A script tag at the bottom that loads your client SPA code</p>
</li>
</ul>
</div>
</li>
<li>
<p>The client will look for initial state via a var set on <code>js/window</code> (transit-encoded string) and start</p>
</li>
<li>
<p>The client will do an initial render, which will cause react to hook up to the existing DOM</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_building_the_app_state_on_the_server"><a class="anchor" href="#_building_the_app_state_on_the_server"></a><a class="link" href="#_building_the_app_state_on_the_server">19.2.1. Building the App State on the Server</a></h4>
<div class="paragraph">
<p>The <code>fulcro.server-render</code> namespace has a function called <code>build-initial-state</code> that takes the root component
and an initial state tree. It normalizes this and plugs in any union branch data that was not in the tree itself
(by walking the query and looking for components that have initial state and are union branches). It returns
a <strong>normalized</strong> client application db that would be what you&#8217;d have on the client at initial startup if you&#8217;d
started the client normally.</p>
</div>
<div class="paragraph">
<p>So, now all you need to do is run any combination of operations on that map to bring it to the proper state. Here&#8217;s the
super-cool thing: your renderer is pure! It will render exactly what the state says the application is in!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [base-state (ssr/build-initial-state (my-app/get-initial-state) my-app/Root)
      user       (get-current-user (<span class="symbol">:session</span> req))
      user-ident (util/get-ident my-app/User user)]
   (<span class="keyword">-&gt;</span> base-state
     (todo-check-item-impl <span class="integer">3</span> <span class="predefined-constant">true</span>) <span class="comment">; some combo of mutation impls</span>
     (<span class="keyword">assoc</span> <span class="symbol">:current-user</span> user-ident) <span class="comment">; put normalized user into root</span>
     (<span class="keyword">assoc-in</span> user-ident user)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>So now you&#8217;ve got the client-side db on the server. Now all you need to do is pre-render it, and also
get this generated state to the client!</p>
</div>
</div>
<div class="sect3">
<h4 id="_rendering_with_initial_state"><a class="anchor" href="#_rendering_with_initial_state"></a><a class="link" href="#_rendering_with_initial_state">19.2.2. Rendering with Initial State</a></h4>
<div class="paragraph">
<p>Of course, the whole point is to pre-render the page. Now that you have a complete client database this is
trivial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [props                (comp/db-&gt;tree (comp/get-query app/Root normalized-db) state-map state-map)
      root-factory         (comp/factory app/Root)]
  (dom/render-to-str (root-factory props)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>will generate a string that contains the current HTML rendering of that database state!</p>
</div>
</div>
<div class="sect3">
<h4 id="_send_the_completed_package"><a class="anchor" href="#_send_the_completed_package"></a><a class="link" href="#_send_the_completed_package">19.2.3. Send The Completed Package!</a></h4>
<div class="paragraph">
<p>Now, while you have the correct initial look, you will still need to get this database state into the client.
While you could technically try loading your UI&#8217;s initial state, it would make the UI flicker because when React
mounts it needs to see the exact DOM that is already there. So, you must pass the server-side generated-database
as initial-state to your client.
The function <code>fulcro.server-render/initial-state&#8594;script-tag</code> will give you a <code>&lt;script&gt;</code> tag that includes
a string-encoded EDN data structure (using transit).</p>
</div>
<div class="paragraph">
<p>We now combine what we learned about generating the application&#8217;s rendering with this to get the overall
response from the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">top-html</span> [normalized-db root-component-class]
  (<span class="keyword">let</span> [props                (db-&gt;tree (get-query root-component-class) normalized-db normalized-db)
        root-factory         (factory root-component-class)
        app-html             (dom/render-to-str (root-factory props))
        initial-state-script (ssr/initial-state-&gt;script-tag normalized-db)]
    (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;!DOCTYPE) html&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;html lang='en'&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;head&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;meta charset='UTF-8'&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;meta name='viewport' content='width=device-width, initial-scale=1'&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      initial-state-script
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;title&gt;Home Page&lt;/title&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/head&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;body&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;div id='app'&gt;</span><span class="delimiter">&quot;</span></span>
      app-html
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/div&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;script src='js/app.js' type='text/javascript'&gt;&lt;/script&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/body&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/html&gt;</span><span class="content">\n</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s move on to the client.</p>
</div>
</div>
<div class="sect3">
<h4 id="_client_side_use_initial_state"><a class="anchor" href="#_client_side_use_initial_state"></a><a class="link" href="#_client_side_use_initial_state">19.2.4. Client-Side – Use Initial State</a></h4>
<div class="paragraph">
<p>When creating your client, you will now be explicit about initial state and use a helper function (provided)
to decode the server-sent state:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defonce</span> <span class="function">app</span> (<span class="keyword">atom</span> (fc/make-fulcro-client {<span class="symbol">:initial-state</span> (fulcro.server-render/get-SSR-initial-state}))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, you could use <code>:client-did-mount</code> to do various other bits (like start your HTML5 routing), but this
completes the essential pattern. No other client modifications need to be made!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_complete_working_example"><a class="anchor" href="#_a_complete_working_example"></a><a class="link" href="#_a_complete_working_example">19.3. A Complete Working Example</a></h3>
<div class="paragraph">
<p>There is a complete working example of these techniques (including the HTML5 routing) in the
[fulcro-template](<a href="https://github.com/fulcrologic/fulcro-template" class="bare">https://github.com/fulcrologic/fulcro-template</a>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[Server-side logic](<a href="https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/server.clj" class="bare">https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/server.clj</a>)</p>
</li>
<li>
<p>[HTML5 Routing](<a href="https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/ui/html5_routing.cljc" class="bare">https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/ui/html5_routing.cljc</a>)</p>
</li>
<li>
<p>[Client-side Initial State Generation and Modifications](<a href="https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/ui/root.cljc" class="bare">https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/ui/root.cljc</a>) (see <code>initial-app-state-tree</code>)</p>
</li>
<li>
<p>[Client Start-up](<a href="https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/client.cljs" class="bare">https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/client.cljs</a>) Note this example tolerates a failure of the server to send
initial state, so it runs initial startup steps if it detects that.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_rendering_via_node_js"><a class="anchor" href="#_rendering_via_node_js"></a><a class="link" href="#_rendering_via_node_js">19.4. Rendering via Node.js</a></h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
This section is a Fulcro 2 example. TODO: Needs porting to version 3.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since node.js is powered by V8, the same javascript engine that powers chrome web browser getting isomorphic support including fulcro networking is really easy.</p>
</div>
<div class="paragraph">
<p>For fulcro networking to work in nodejs you need to provide a substitute for the browser&#8217;s XMLHttpRequest that is used by xhrio.
You can install the <a href="https://www.npmjs.com/package/xmlhttprequest" class="bare">https://www.npmjs.com/package/xmlhttprequest</a> npm package and then set it globally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.server</span>
 (<span class="symbol">:require</span>
    [<span class="string"><span class="delimiter">&quot;</span><span class="content">xmlhttprequest</span><span class="delimiter">&quot;</span></span> <span class="symbol">:as</span> npm-xmlhttprequest]))

(set! js/global.XMLHttpRequest (<span class="keyword">.</span>-XMLHttpRequest npm-xmlhttprequest))</code></pre>
</div>
</div>
<div class="paragraph">
<p>One approach for getting SSR on node.js with the data loaded from the network is to create a fulcro headless client and use the built-in helper <code>fulcro.server-render/defer-until-network-idle</code> (available as of fulcro 2.6.10) for deferring the server request until fulcro has finished loading all network data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.server</span>
  (<span class="symbol">:require</span>
   [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
   [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
   [fulcro.client <span class="symbol">:as</span> fc]
   [fulcro.client.network <span class="symbol">:as</span> fcn]
   [fulcro.server-render <span class="symbol">:refer</span> [defer-until-network-idle]]
   [<span class="string"><span class="delimiter">&quot;</span><span class="content">react-dom/server</span><span class="delimiter">&quot;</span></span> <span class="symbol">:as</span> rdom <span class="symbol">:refer</span> (render)]
   [<span class="string"><span class="delimiter">&quot;</span><span class="content">xmlhttprequest</span><span class="delimiter">&quot;</span></span> <span class="symbol">:as</span> npm-xmlhttprequest]))

(<span class="keyword">defn</span> <span class="function">ssr-enpdpoint</span> [req resp]
  (<span class="keyword">let</span> [client-did-mount (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [reconciler]}]
                           (df/load reconciler <span class="keyword">..</span><span class="keyword">.</span>))
        fulcro-client    (fc/make-fulcro-client
                          {<span class="symbol">:client-did-mount</span> client-did-mount
                           <span class="symbol">:networking</span> {<span class="symbol">:remote</span> (fcn/fulcro-http-remote {<span class="symbol">:url</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:3000/api</span><span class="delimiter">&quot;</span></span>}})})
        mounted-app      (fc/mount fulcro-client root/Root <span class="predefined-constant">nil</span>) <span class="comment">; nil as the last argument creates a headless client</span>
        reconciler       (<span class="symbol">:reconciler</span> mounted-app)]
    (defer-until-network-idle
     reconciler
     (<span class="keyword">fn</span> []
       (<span class="keyword">let</span> [app-state      (<span class="keyword">-&gt;</span> reconciler <span class="keyword">deref</span>)
             app-state-tree (comp/db-&gt;tree (comp/get-query root/Root app-state) app-state app-state)]
         (<span class="keyword">.</span><span class="keyword">send</span> resp (get-html (rdom/renderToString (ui-root app-state-tree)) app-state)))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>A minimal example app with fulcro &amp; nodejs server side rendering can be found at <a href="https://github.com/claudiu-apetrei/fulcro-nodejs-ssr-example" class="bare">https://github.com/claudiu-apetrei/fulcro-nodejs-ssr-example</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Networking"><a class="anchor" href="#Networking"></a><a class="link" href="#Networking">20. Client Networking with Fulcro HTTP Remote</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fulcro allows you to define any number of remote handlers for talking to any number of remote servers. If
unspecified it defaults to using an HTTP remote named <code>:remote</code> that talks to your js origin server through
HTTP POST at the <code>/api</code> URI, and uses JSON-encoded transit to communicate requests and interpret responses.</p>
</div>
<div class="paragraph">
<p>You can create additional remotes of your own implementation or instances of Fulcro&#8217;s built-in HTTP remote, which
is written to be customizable.</p>
</div>
<div class="paragraph">
<p>It has the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It uses middleware for the request and response so you can customize the entire communication pipeline without having
to deal with low-level networking. A remote can now manipulate everything from the request headers to the URL and even
the raw data on the wire.</p>
</li>
<li>
<p>It supports Fulcro&#8217;s <code>app/abort!</code>.</p>
</li>
<li>
<p>It reports progress, so the <code>progress-action</code> of your mutations can update the UI as the operation runs.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_creating_a_remote"><a class="anchor" href="#_creating_a_remote"></a><a class="link" href="#_creating_a_remote">20.1. Creating a Remote</a></h3>
<div class="paragraph">
<p>A remote with these new features requires very little code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(http-remote/fulcro-http-remote {<span class="symbol">:url</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may include a <code>:url</code> parameter to specify what the server endpoint is (defaults to "/api"), and you may also
provide middleware.</p>
</div>
</div>
<div class="sect2">
<h3 id="_request_middleware"><a class="anchor" href="#_request_middleware"></a><a class="link" href="#_request_middleware">20.2. Request Middleware</a></h3>
<div class="paragraph">
<p>The request will, by default, be sent through pre-written middleware <code>fulcro.client.network/wrap-fulcro-request</code>. This
middleware will convert the body to a json-encoded transit form and add content-type headers. If you specify request
middleware you will want to compose that middleware in or normal API requests won&#8217;t work.</p>
</div>
<div class="paragraph">
<p>Additional middleware can do any number of things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Re-route requests to an alternate URI</p>
</li>
<li>
<p>Change the content type and encode the body</p>
</li>
<li>
<p>Short-circuit the result of the middleware stack</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Middleware is just a function <code>(fn [handler] (fn [req] &#8230;&#8203;))</code>. The inner function can choose to modify the request
and pass it through the remaining <code>handler</code>, or just return a request as the final thing to process. This is
similar to Ring middleware on the server.</p>
</div>
<div class="paragraph">
<p>Fulcro will supply the middleware with a request that contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:body</code> - The EDN transaction to send (query or mutations).</p>
</li>
<li>
<p><code>:headers</code> - An empty map.</p>
</li>
<li>
<p><code>:url</code> - The default URL this remote talks to.</p>
</li>
<li>
<p><code>:method</code> - The HTTP verb as a keyword. All Fulcro requests default to <code>:post</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Middleware should return a map with the same keys that is passed on to the next layer. It may
add any keys it wishes. The final result of the middleware stack will be used as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:body</code> - The raw data that will be given to XhrIO send</p>
</li>
<li>
<p><code>:headers</code> - A clj map from string to string. It will be converted to a jsobj and given as the headers to the request.</p>
</li>
<li>
<p><code>:url</code> - The network target. Can be relative or a complete URL, assuming you have security set to allow you to talk to the given server.</p>
</li>
<li>
<p><code>:method</code> - Converted to an upper-case HTTP verb as a string.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_client_response_middleware"><a class="anchor" href="#_client_response_middleware"></a><a class="link" href="#_client_response_middleware">20.3. Client Response Middleware</a></h3>
<div class="paragraph">
<p>The response will, by default, be sent through the pre-written middleware function <code>fulcro.client.network/wrap-fulcro-response</code>
which contains the logic to properly decode an API response (which is essentially just a transit decode). If you specify
response middleware you will want to compose that middleware in or normal API responses won&#8217;t work.</p>
</div>
<div class="paragraph">
<p>Raw responses from the remote will include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:body</code> - The data that will be given back to Fulcro as the response from the server</p>
</li>
<li>
<p><code>:transaction</code> - The transaction that body is a response to. If you modify this for queries you can manipulate the final merge.</p>
</li>
<li>
<p><code>:status-code</code> - The HTTP status code</p>
</li>
<li>
<p><code>:status-text</code> - The HTTP status text</p>
</li>
<li>
<p><code>:error</code> - An error code. Typically one of <code>:network-error</code>, <code>:http-error</code>, <code>:timeout</code>, etc.</p>
</li>
<li>
<p><code>:error-text</code> - A string describing the error</p>
</li>
<li>
<p><code>:outgoing-request</code> - The request that this is a response to.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The final response body and transaction combo will be given to Fulcro for merge. If you modify
the transaction be sure to use a query from components so that normalization is done properly.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Response middleware is allowed to rewrite an errant response to an OK one (by clearing the error fields and
setting :status-code to 200). This would allow you, for example, to merge
specific errors into state as you see fit instead of relying on Fulcro&#8217;s built-in error handling model.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_merging_state"><a class="anchor" href="#_merging_state"></a><a class="link" href="#_merging_state">20.3.1. Merging State</a></h4>
<div class="paragraph">
<p>TODO: REVIEW this section</p>
</div>
<div class="paragraph">
<p>As mentioned above: the final response body and transaction combo will be given to Fulcro for merge. The basic pipeline
is like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You run a transact that goes remote. E.g. <code>(transact! this '[(f {:x 1})])</code>. <code>transaction</code> is <code>[(f {:x 1})]</code></p>
</li>
<li>
<p>The response is received from the server. This <strong>can</strong> be anything you want to return, but typically for mutations is just <code>:tempids</code>.
For example <code>{'f {:tempids {1 2}}}</code>. This is the <code>body</code>.</p>
</li>
<li>
<p>Merge is a two-part affair:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Any mutation keys in the response are pulled off and run through migrate to get tempid migrations.</p>
</li>
<li>
<p>The remainder of the k/v pairs in the map are then run through normal merge (which requires a query, assumed to be in <code>transaction</code>).</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, this gives you a <strong>ton</strong> of power in your response middleware to customize everything from error handling to doing post-operations
on mutations.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you want to write response middleware that does the following: If there is an error, skip Fulcro&#8217;s error
pipeline and instead put the information in <code>:my-error</code> key at root (which perhaps you have set up to pop a modal in your
UI code).</p>
</div>
<div class="paragraph">
<p>So, your desired merge transaction is <code>[:my-error]</code> (rewriting the transaction "as if" you had "asked" for the error),
and the body is <code>{:my-error {&#8230;&#8203;data for error&#8230;&#8203;}}</code>!  The entire middleware component is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">wrap-errors</span> [handler]
  (<span class="keyword">fn</span> [resp]
    (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [error status-code]} resp]
      (handler
        (<span class="keyword">if</span> (<span class="keyword">not</span><span class="keyword">=</span> <span class="integer">200</span> status-code) <span class="comment">; when there are errors, rewrite them &quot;as-if&quot; we had asked for it</span>
          (<span class="keyword">-&gt;</span> resp
            (<span class="keyword">assoc</span> <span class="symbol">:body</span> {<span class="symbol">:my-error</span> {<span class="symbol">:error</span> error}} <span class="symbol">:transaction</span> [<span class="symbol">:my-error</span>] <span class="symbol">:status-code</span> <span class="integer">200</span>)
            (<span class="keyword">dissoc</span> <span class="symbol">:error</span>))
          resp)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>installed with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; Resulting middleware (evaluates right to left because of nested composition)</span>
(<span class="keyword">def</span> <span class="function">middleware</span> (<span class="keyword">-&gt;</span> (net/wrap-fulcro-response) (wrap-errors)))

<span class="keyword">..</span><span class="keyword">.</span>

(<span class="keyword">def</span> <span class="function">client</span> (fc/make-fulcro-client {<span class="symbol">:networking</span> {<span class="symbol">:remote</span> (net/fulcro-http-remote {<span class="symbol">:url</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span> <span class="symbol">:response-middleware</span> middleware})}})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_your_own_remote_implementation"><a class="anchor" href="#_writing_your_own_remote_implementation"></a><a class="link" href="#_writing_your_own_remote_implementation">20.4. Writing Your Own Remote Implementation</a></h3>
<div class="paragraph">
<p>If you do not want to use the networking code provided in Fulcro then you may write your own. You could use the
code in <code>http_remote.cljs</code> as a starting point. Here are the basics:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A remote is just a map. The map can contain anything you want, but <strong>MUST</strong> contain a <code>:transmit!</code> key
whose value is a <code>(fn [send-node] )</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A <code>send-node</code> has the following spec:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(s/def <span class="symbol">:com.fulcrologic.fulcro.algorithms.tx-processing/send-node</span>
  (s/keys
    <span class="symbol">:req</span> [<span class="symbol">:com.fulcrologic.fulcro.algorithms.tx-processing/id</span>
          <span class="symbol">:com.fulcrologic.fulcro.algorithms.tx-processing/idx</span>
          <span class="symbol">:com.fulcrologic.fulcro.algorithms.tx-processing/ast</span>
          <span class="symbol">:com.fulcrologic.fulcro.algorithms.tx-processing/result-handler</span>
          <span class="symbol">:com.fulcrologic.fulcro.algorithms.tx-processing/update-handler</span>
          <span class="symbol">:com.fulcrologic.fulcro.algorithms.tx-processing/active?</span>]
    <span class="symbol">:opt</span> [<span class="symbol">:com.fulcrologic.fulcro.algorithms.tx-processing/options</span>]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ast</code> is the AST of the request that Fulcro wants to make. The <code>result-handler</code> and <code>update-handler</code> are functions
you call to report the result (once and only once) or send updates. The <code>options</code> map will include things like the
<code>abort-id</code>.</p>
</div>
<div class="paragraph">
<p>This book implements a remote that uses a cljs pathom parser to respond (no network). You could define a "remote"
that talks to browser local storage. There are really no limitations beside the fact that you must
call <code>result-handler</code> once and only once.</p>
</div>
<div class="paragraph">
<p>What you pass to the result handler is <strong>also</strong> up to you. If you send a "normal" Fulcro result it will have the
basic form of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:body</span> some-edn
 <span class="symbol">:transaction</span> original-tx-or-query
 <span class="symbol">:status-code</span> n}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but since you can define what happens to this data via <code>default-result-action</code> or directly in mutations it is really
wide open to your own invention. If you follow the standard result format, then you can expect the default load
and mutation return merging to work, and error/ok processing to function as well.  If you deviate from the standard
format then those functions will not work without additional intervention on your part.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interfacing_with_alternate_network_protocols"><a class="anchor" href="#_interfacing_with_alternate_network_protocols"></a><a class="link" href="#_interfacing_with_alternate_network_protocols">20.5. Interfacing with Alternate Network Protocols</a></h3>
<div class="sect3">
<h4 id="FileUpload"><a class="anchor" href="#FileUpload"></a><a class="link" href="#FileUpload">20.5.1. File Uploads</a></h4>
<div class="paragraph">
<p>TODO: This section needs to be rewritten, and should include a basic full example.</p>
</div>
<div class="paragraph">
<p>Fulcro may soon include pre-written software to accomplish file uploads for you. In the meantime you
can just copy code from <a href="http://github.com/awkay/file-upload-demo">the file upload demo project</a>
as a basis for your own projects.</p>
</div>
<div class="paragraph">
<p>The basic scheme is as follows (and is well-documented in that project):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Attach a <code>js/File</code> object to a mutation&#8217;s parameters (typically as metadata to avoid various tool overhead)</p>
</li>
<li>
<p>Include a tempid in the parameters</p>
</li>
<li>
<p>The mutation should using an network object that has custom middleware for file upload/error handling</p>
</li>
<li>
<p>The local side of the mutation puts the file information into app state with a tempid</p>
</li>
<li>
<p>The remote&#8217;s middleware encodes the headers/body into a proper multipart form upload, and
includes the tempid</p>
</li>
<li>
<p>Progress reports are handled as usual. The parameters of the progress mutation should include the tempid so that
progress can be written to the file&#8217;s state.</p>
</li>
<li>
<p>The remote uses normal Fulcro response middleware (which can decode tempid remappings)</p>
</li>
<li>
<p>The server accepts the file, assigns it a real ID, and returns a transit response with tempid
remapping to that real ID.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When complete, the UI has an ID for the uploaded file, and can interact with the server via that ID
(e.g. for generating file serving URLs for images, send delete mutations, etc.).</p>
</div>
<div class="paragraph">
<p>The server for this would need middleware watching for file uploads at <code>/file-uploads</code> that
returns a transit+json encoded map for the mutation (the mutation name is irrelevant in the response):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{`upload-file {<span class="symbol">:tempids</span> {file-temp-id newly-assigned-id}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fulcro&#8217;s pluggable remotes make it relatively easy to plug in alternate communication methods.  You can interface
with things like REST or GraphQL servers with relative ease, especially if you use the
<a href="https://wilkerlucio.github.io/pathom/DevelopersGuide.html">Pathom</a> parser library.</p>
</div>
<div class="sect4">
<h5 id="_a_rest_example"><a class="anchor" href="#_a_rest_example"></a><a class="link" href="#_a_rest_example">A REST Example</a></h5>
<div class="paragraph">
<p>Here&#8217;s a simple example to give you an idea of how simple it can be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.rest-remote</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.fulcro.network <span class="symbol">:as</span> pn]
            [clojure.core.async <span class="symbol">:as</span> async]
            [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span>]
            [fulcro.client.network <span class="symbol">:as</span> net]))

(<span class="keyword">defmulti</span> <span class="function">resolver-fn</span> pc/resolver-dispatch)
(<span class="keyword">defonce</span> <span class="function">indexes</span> (<span class="keyword">atom</span> {}))
(<span class="keyword">defonce</span> <span class="function">defresolver</span> (pc/resolver-factory resolver-fn indexes))

(<span class="keyword">defn</span> <span class="function">rest-parser</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Create a REST parser. Make sure you've required all nses that define rest resolvers. The given app-atom will be available
  to all resolvers in `env` as `:app-atom`.</span><span class="delimiter">&quot;</span></span>
  [extra-env]
  (p/async-parser
    {<span class="symbol">::p/plugins</span> [(p/env-plugin
                    (<span class="keyword">merge</span> extra-env
                      {<span class="symbol">::p/reader</span>             [p/map-reader
                                               pc/all-async-readers]
                       <span class="symbol">:app-atom</span>              app-atom
                       <span class="symbol">::pc/resolver-dispatch</span> resolver-fn
                       <span class="symbol">::pc/indexes</span>           @indexes}))
                  p/request-cache-plugin
                  (p/post-process-parser-plugin p/elide-not-found)]}))

(<span class="keyword">defn</span> <span class="function">rest-remote</span> [extra-env]
  (pn/pathom-remote (rest-parser extra-env)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>rest-remote</code> function creates a remote that can resolve REST requests via Pathom resolvers. It is written to
take an atom that will hold your Fulcro app, so that resolvers for REST can interact with your database.</p>
</div>
<div class="paragraph">
<p>Simply add the remote into your networking on the client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fc/make-fulcro-client
  {<span class="symbol">:networking</span> {<span class="symbol">:remote</span>     (fulcro-http-remote <span class="keyword">..</span><span class="keyword">.</span>)
                <span class="symbol">:rest</span>       (rr/rest-remote app)}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>and you can use the newly defined <code>defresolver</code> to define Pathom resolvers for satisfying REST API requests, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defresolver `ofac
{<span class="symbol">::pc/output</span> [<span class="symbol">:rest/thing</span>]}
(<span class="keyword">fn</span> [env _]
  (<span class="keyword">let</span> [<span class="keyword">name</span>    (<span class="keyword">-&gt;</span> env <span class="symbol">:ast</span> <span class="symbol">:params</span> <span class="symbol">:name</span>)
        params  {<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>      <span class="keyword">name</span>}]
    (go
      (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [body]} (&lt;!
       (http/get <span class="string"><span class="delimiter">&quot;</span><span class="content">https://myrest.com/search</span><span class="delimiter">&quot;</span></span> {<span class="symbol">:query-params</span>      params}))]
        {<span class="symbol">:rest/thing</span> body})))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>which can then be used with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load this <span class="symbol">:rest/thing</span> <span class="predefined-constant">nil</span> {<span class="symbol">:params</span> {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Simon</span><span class="delimiter">&quot;</span></span>}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>and can be targeted, use load markers, etc.</p>
</div>
<div class="paragraph">
<p>Of course, you can also define resolvers that "compute" derived data with normal resolver tricks. See Pathom
documentation.</p>
</div>
</div>
<div class="sect4">
<h5 id="_graphql"><a class="anchor" href="#_graphql"></a><a class="link" href="#_graphql">GraphQL</a></h5>
<div class="paragraph">
<p>The Pathom library also includes a pre-built GraphQL remote for Fulcro, along with tools that allow you to combine
resolvers with GraphQL servers easily.  Pathom&#8217;s connect feature can be combined in, which allows you to morph
your perception of the server&#8217;s graph in ways that are more convenient for your application. This results in a remote
for Fulcro that is far more powerful than standard GraphQL, even when GraphQL is what the server is providing!</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Security"><a class="anchor" href="#Security"></a><a class="link" href="#Security">21. Security</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Full production Fulco apps, just like any other web-based software need some additional attention to ensure that there
are no security holes that can be exploited.  Fulcro can do nothing for you if you trust user strings in SQL string
composition or make any of the other "old school" errors like those in
<a href="https://www.owasp.org/index.php/OWASP_Proactive_Controls#tab=OWASP_Proactive_Controls_2018">The OWASP Top 10 Proactive Controls</a>.</p>
</div>
<div class="paragraph">
<p>The most critical part of your application to secure is your network-based API.  This involves low-level network
security measures, authentication, and then often some additional authorization.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re using unmodified Fulcro server code and client remotes then it is likely that you have not done enough to
ensure your user&#8217;s safety.  Here are the minimum measures (also note that I am not a security expert, and you system
may have additional needs.  You should do your homework.):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use HTTPS for all authenticated access.  Most people put something like nginx in front of thier webapp for this.</p>
</li>
<li>
<p>Use secure cookies for authenticated sessions, to ensure you don&#8217;t accidentally send an authenticated session cookie over a non-secure connection.</p>
<div class="ulist">
<ul>
<li>
<p>If you&#8217;re using <code>wrap-session</code> and assign a cookie to your user on pre-login HTTP access and then "upgrade" it on login you
are opening your users to man-in-the-middle attacks.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Add middleware that checks for unexpected cross-origin requests.</p>
</li>
<li>
<p>Add code to prevent websocket hijacking (if you use websockets). Sente with its built-in CSRF is <strong>not</strong> sufficient.</p>
</li>
<li>
<p>Add code to do proper cross-site scripting prevention.</p>
<div class="ulist">
<ul>
<li>
<p>If you can <strong>see</strong> the CSRF token go across <strong>any</strong> AJAX interaction as payload data that requires nothing more than the session
cookie (or less), then your security is broken.
See <a href="https://stackoverflow.com/questions/20504846/why-is-it-common-to-put-csrf-prevention-tokens-in-cookies">this Stack Overflow Discussion</a>
for more information on correct ways to use CSRF tokens, and their relative pros/cons.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Fulcro 2.6.8+ includes some built-in support that implement <strong>some</strong> of these.  Your application auth logic and
server deployment matter, so <strong>do not trust</strong> that any web application (using Fulcro or any other library) is
secure.  You should always go through a complete security checklist and penetration testing.</p>
</div>
<div class="sect2">
<h3 id="_low_level_network_security"><a class="anchor" href="#_low_level_network_security"></a><a class="link" href="#_low_level_network_security">21.1. Low-Level Network Security</a></h3>
<div class="paragraph">
<p>First, start by reviewing your server middleware.  You should read through
<a href="https://github.com/ring-clojure/ring-defaults/blob/master/src/ring/middleware/defaults.clj">Ring Defaults</a> and understand
what each one of the recommended middleware bits does, and add the ones that apply for you.  Pay particular attention
to any related to SSL and cross-site things (<code>wrap-frame-options</code>, <code>wrap-xss-protection</code>, <code>wrap-content-type-options</code>, etc.).</p>
</div>
<div class="paragraph">
<p>Fulcro is not involved in your cookie/session/auth/SSL story.  You will need to design, add, and configure that middleware
and logic yourself.  Do <strong>not</strong> trust Fulcro templates for security.  They are meant to be starting points, and
not production-ready code.  These, by necessity, do not force SSL for example.</p>
</div>
<div class="paragraph">
<p>The <code>ring.middleware.ssl</code> has a few things you should throw in once you&#8217;ve got SSL working.  If you&#8217;re forcing all access
to HTTPS before <code>wrap-session</code> can assign a cookie, then you won&#8217;t have to <strong>re</strong>-assign a different cookie for authenticated
access, and it also allows you to add the <code>:secure true</code> option to <code>wrap-session</code> so that you can stop worrying about
that mess.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://github.com/ring-clojure/ring/wiki/Sessions">Ring wrap-session documentation</a> for more details
about things like how to handle cookie regeneration on privilege escalation if you started out (i.e. need) a non-secure cookie
for pre-authenticated session things.</p>
</div>
<div class="sect3">
<h4 id="_csrf"><a class="anchor" href="#_csrf"></a><a class="link" href="#_csrf">21.1.1. CSRF</a></h4>
<div class="paragraph">
<p>The most difficult and intricate thing to secure in your application is cross-site API requests.  Much of the "official"
documentation on the web about XSS is about form submission, and <code>wrap-anti-forgery</code> middleware is built to allow you
to secure form POST in exactly this scenario.</p>
</div>
<div class="paragraph">
<p>Fulcro <strong>does</strong> use POST for both <strong>queries and mutations</strong>, so adding this middleware will "work", in that all of your API
requests will fail everywhere!  This is probably stronger security than your users will find useful.</p>
</div>
<div class="paragraph">
<p>There are a number of approaches you can take to correct this.  The easiest is to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Configure your deployment for <strong>SSL always</strong>.  Development mode can be configurable to turn off the middleware redirects and
the secure marker on cookies, but you might want to have a careful deployment test to ensure non-SSL requests are always redirected
in production and cookies are secure.</p>
</li>
<li>
<p>Put the CSRF token in a secure (but js-accessible) cookie <strong>or</strong> embed it in the HTML of the page of your
Fulcro application.  This will allow the startup code to access it.  Make sure you understand the security around
the generation of this token and how it works.</p>
</li>
<li>
<p>Add the CSRF to the headers of your Fulcro remote(s) as <code>X-CSRF-Token</code>.  This will allow your POSTs to get past
the <code>wrap-anti-forgery</code> middleware.</p>
</li>
<li>
<p>I also recommend that you enforce an origin header check just before the API handler.  As you expand your software
you might add endpoints that make you want to open up things with <code>Access-Control-Allow-Origin</code> on your server, but you
probably don&#8217;t want those requests ever making it to your API as possible cross-site attacks. Fulcro comes
with (as of 2.6.8) <code>fulcro.server/wrap-protect-origins</code> for this purpose.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_example_securing_a_normal_remote"><a class="anchor" href="#_example_securing_a_normal_remote"></a><a class="link" href="#_example_securing_a_normal_remote">21.1.2. Example Securing a Normal Remote</a></h4>
<div class="paragraph">
<p>When deploying to production you should stop using the "easy" server and roll your own. This section will cover the steps
you need to do so, and you can also clone the <a href="https://github.com/fulcrologic/fulcro-security-demo">complete source of this example</a>.</p>
</div>
<div class="sect4">
<h5 id="_the_server_config_and_middleware"><a class="anchor" href="#_the_server_config_and_middleware"></a><a class="link" href="#_the_server_config_and_middleware">The Server Config and Middleware</a></h5>
<div class="paragraph">
<p>Our demo app is going to take the approach of embedding the CSRF token in the HTML page that serves our Fulcro app.  This
is relatively easy to understand, and is as secure as form-based CSRF embedding.  Hiccup makes short work of generating
such a page:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">generate-index</span> [{<span class="symbol">:keys</span> [anti-forgery-token]}]
  (timbre/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Embedding CSRF token in index page</span><span class="delimiter">&quot;</span></span>)
  (<span class="keyword">-&gt;</span> (h.page/html5 {}
        [<span class="symbol">:head</span> {<span class="symbol">:lang</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">en</span><span class="delimiter">&quot;</span></span>}
         [<span class="symbol">:meta</span> {<span class="symbol">:charset</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">UTF-8</span><span class="delimiter">&quot;</span></span>}]
         [<span class="symbol">:script</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">var fulcro_network_csrf_token = '</span><span class="delimiter">&quot;</span></span> anti-forgery-token <span class="string"><span class="delimiter">&quot;</span><span class="content">';</span><span class="delimiter">&quot;</span></span>)]]
        [<span class="symbol">:body</span>
         [<span class="symbol">:div#app</span>]
         [<span class="symbol">:script</span> {<span class="symbol">:src</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/js/main/app.js</span><span class="delimiter">&quot;</span></span>}]
         [<span class="symbol">:script</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">security_demo.client.init()</span><span class="delimiter">&quot;</span></span>]])
    response/response
    (response/content-type <span class="string"><span class="delimiter">&quot;</span><span class="content">text/html</span><span class="delimiter">&quot;</span></span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>For middleware we can adopt <code>ring-defaults</code> to get most of the bits we need.
You want to be able to work in development, and also safely deploy to production, and since
ring-defaults needs a number of config options we&#8217;d like to be able to tweak between the two we&#8217;ll
put a secure set of those into our Fulcro <code>defaults.edn</code> config file as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:http-kit/config</span>
 {<span class="symbol">:port</span> <span class="integer">3000</span>}

 <span class="symbol">:legal-origins</span>
 #{<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">security-demo.lvh.me</span><span class="delimiter">&quot;</span></span>}

 <span class="symbol">:ring.middleware/defaults-config</span>
 {<span class="symbol">:params</span>    {<span class="symbol">:keywordize</span> <span class="predefined-constant">true</span>
              <span class="symbol">:multipart</span>  <span class="predefined-constant">true</span>
              <span class="symbol">:nested</span>     <span class="predefined-constant">true</span>
              <span class="symbol">:urlencoded</span> <span class="predefined-constant">true</span>}
  <span class="symbol">:cookies</span>   <span class="predefined-constant">true</span>
  <span class="symbol">:responses</span> {<span class="symbol">:absolute-redirects</span>     <span class="predefined-constant">true</span>
              <span class="symbol">:content-types</span>          <span class="predefined-constant">true</span>
              <span class="symbol">:default-charset</span>        <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>
              <span class="symbol">:not-modified-responses</span> <span class="predefined-constant">true</span>}
  <span class="symbol">:session</span>   {<span class="symbol">:cookie-attrs</span> {<span class="symbol">:http-only</span> <span class="predefined-constant">true</span>, <span class="symbol">:same-site</span> <span class="symbol">:strict</span>}}
  <span class="symbol">:static</span>    {<span class="symbol">:resources</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>}
  <span class="symbol">:security</span>  {<span class="symbol">:anti-forgery</span>   <span class="predefined-constant">true</span>
              <span class="symbol">:hsts</span>           <span class="predefined-constant">true</span>
              <span class="symbol">:ssl-redirect</span>   <span class="predefined-constant">true</span>
              <span class="symbol">:frame-options</span>  <span class="symbol">:deny</span>
              <span class="symbol">:xss-protection</span> {<span class="symbol">:enable?</span> <span class="predefined-constant">true</span>
                               <span class="symbol">:mode</span>    <span class="symbol">:block</span>}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then create a middleware stack like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">security-demo.components.middleware</span>
  (<span class="symbol">:require</span>
    [clojure.pprint <span class="symbol">:refer</span> [pprint]]
    [fulcro.server <span class="symbol">:as</span> server]
    [hiccup.page <span class="symbol">:as</span> h.page]
    [mount.core <span class="symbol">:refer</span> [defstate]]
    [ring.middleware.defaults <span class="symbol">:refer</span> [wrap-defaults]]
    [ring.middleware.gzip <span class="symbol">:refer</span> [wrap-gzip]]
    [ring.util.response <span class="symbol">:as</span> response]
    [ring.util.response <span class="symbol">:refer</span> [response file-response resource-response]]
    [security-demo.api.mutations]                           <span class="comment">;; ensure reads/mutations are loaded</span>
    [security-demo.api.read]
    [security-demo.components.config <span class="symbol">:refer</span> [config]]
    [security-demo.components.server-parser <span class="symbol">:refer</span> [server-parser]]
    [taoensso.timbre <span class="symbol">:as</span> timbre]
    [clojure.string <span class="symbol">:as</span> <span class="keyword">str</span>]))

(<span class="keyword">def</span> ^<span class="symbol">:private</span> not-found-handler
  (<span class="keyword">fn</span> [_]
    {<span class="symbol">:status</span>  <span class="integer">404</span>
     <span class="symbol">:headers</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">Content-Type</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain</span><span class="delimiter">&quot;</span></span>}
     <span class="symbol">:body</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">NOPE</span><span class="delimiter">&quot;</span></span>}))

(<span class="keyword">defn</span> <span class="function">wrap-api</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Fulcro's API handler</span><span class="delimiter">&quot;</span></span>
  [handler]
  (<span class="keyword">fn</span> [request]
    (<span class="keyword">if</span> (<span class="keyword">=</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span> (<span class="symbol">:uri</span> request))
      (server/handle-api-request
        server-parser
        {<span class="symbol">:config</span> config}
        (<span class="symbol">:transit-params</span> request))
      (handler request))))

(<span class="keyword">defn</span> <span class="function">generate-index</span> [{<span class="symbol">:keys</span> [anti-forgery-token]}]
  (timbre/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Embedding CSRF token in index page</span><span class="delimiter">&quot;</span></span>)
  (<span class="keyword">-&gt;</span> (h.page/html5 {}
        [<span class="symbol">:head</span> {<span class="symbol">:lang</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">en</span><span class="delimiter">&quot;</span></span>}
         [<span class="symbol">:meta</span> {<span class="symbol">:charset</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">UTF-8</span><span class="delimiter">&quot;</span></span>}]
         [<span class="symbol">:script</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">var fulcro_network_csrf_token = '</span><span class="delimiter">&quot;</span></span> anti-forgery-token <span class="string"><span class="delimiter">&quot;</span><span class="content">';</span><span class="delimiter">&quot;</span></span>)]]
        [<span class="symbol">:body</span>
         [<span class="symbol">:div#app</span>]
         [<span class="symbol">:script</span> {<span class="symbol">:src</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/js/main/app.js</span><span class="delimiter">&quot;</span></span>}]
         [<span class="symbol">:script</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">security_demo.client.init()</span><span class="delimiter">&quot;</span></span>]])
    response/response
    (response/content-type <span class="string"><span class="delimiter">&quot;</span><span class="content">text/html</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">defn</span> <span class="function">wrap-uris</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Wrap the given request URIs to a generator function.</span><span class="delimiter">&quot;</span></span>
  [handler uri-map]
  (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [uri] <span class="symbol">:as</span> req}]
    (<span class="keyword">if-let</span> [generator (<span class="keyword">get</span> uri-map uri)]
      (generator req)
      (handler req))))

(defstate middleware
  <span class="symbol">:start</span>
  (<span class="keyword">let</span> [defaults-config (<span class="symbol">:ring.middleware/defaults-config</span> config)
        legal-origins   (<span class="keyword">get</span> config <span class="symbol">:legal-origins</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>})]
    (timbre/debug <span class="string"><span class="delimiter">&quot;</span><span class="content">Configuring middleware-defaults with</span><span class="delimiter">&quot;</span></span> (<span class="keyword">with-out-str</span> (pprint defaults-config)))
    (timbre/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Restricting origins to </span><span class="delimiter">&quot;</span></span> legal-origins)
    (<span class="keyword">when-not</span> (<span class="keyword">get-in</span> defaults-config [<span class="symbol">:security</span> <span class="symbol">:ssl-redirect</span>])
      (timbre/warn <span class="string"><span class="delimiter">&quot;</span><span class="content">SSL IS NOT ENFORCED: YOU ARE RUNNING IN AN INSECURE MODE (only ok for development)</span><span class="delimiter">&quot;</span></span>))
    (<span class="keyword">-&gt;</span> not-found-handler
      wrap-api
      server/wrap-transit-params
      server/wrap-transit-response
      (server/wrap-protect-origins {<span class="symbol">:allow-when-origin-missing?</span> <span class="predefined-constant">true</span>
                                    <span class="symbol">:legal-origins</span>              legal-origins})
      (wrap-uris {<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>           generate-index
                  <span class="string"><span class="delimiter">&quot;</span><span class="content">/index.html</span><span class="delimiter">&quot;</span></span> generate-index})
      (wrap-defaults defaults-config)
      wrap-gzip)))</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We delete <code>index.html</code> from our public resources, so that the <code>wrap-uris</code> middleware can dynamically generate it.  This
is also handy for embedding things like hashed javascript names (e.g. from a shadow-cljs manifest.edn file).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Really, there is no change to how you set up APIs, but by putting it behind the CSRF protection of <code>ring-defaults</code> all
POSTs will be rejected before they reach it.  The <code>wrap-protect-origins</code> is really paranoia, since a cross-site script
would never know the token; however, the paranoia could be nice if the token was somehow exposed (or guessed).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
When you deploy this to production behind a proxy server, you&#8217;ll want to set the <code>:proxy</code> option in Ring
or you&#8217;ll get infinite redirects.  The production EDN config file for this example is shown below:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:http-kit/config</span>                 {<span class="symbol">:port</span> <span class="integer">8080</span>}
 <span class="symbol">:ring.middleware/defaults-config</span> {<span class="symbol">:proxy</span> <span class="predefined-constant">true</span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, now your client won&#8217;t be able to run queries or mutations against the server (since it isn&#8217;t
sending the CSRF token)!  Let&#8217;s fix that.</p>
</div>
</div>
<div class="sect4">
<h5 id="_securing_the_client"><a class="anchor" href="#_securing_the_client"></a><a class="link" href="#_securing_the_client">Securing the Client</a></h5>
<div class="paragraph">
<p>Really all the client has to do is add CSRF headers to the request.  You can do this with a very simple bit of
Fulcro client middleware (supplied in 2.6.8+, but trivial to write):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; in fulcro.client.network as of 2.6.8</span>
(<span class="keyword">defn</span> <span class="function">wrap-csrf-token</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Client remote request middleware. This middleware can be added to add an X-CSRF-Token header to the request.</span><span class="delimiter">&quot;</span></span>
  ([csrf-token] (wrap-csrf-token <span class="keyword">identity</span> csrf-token))
  ([handler csrf-token]
    (<span class="keyword">fn</span> [request]
      (handler (update request <span class="symbol">:headers</span> <span class="keyword">assoc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">X-CSRF-Token</span><span class="delimiter">&quot;</span></span> csrf-token)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The client should be changed to look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">secured-request-middleware</span>
  (<span class="keyword">-&gt;</span>
    (net/wrap-csrf-token (<span class="keyword">or</span> js/fulcro_network_csrf_token <span class="string"><span class="delimiter">&quot;</span><span class="content">TOKEN-NOT-IN-HTML!</span><span class="delimiter">&quot;</span></span>))
    (net/wrap-fulcro-request)))

<span class="keyword">..</span><span class="keyword">.</span>

(fc/make-fulcro-client
  {<span class="symbol">:networking</span> {<span class="symbol">:remote</span> (net/fulcro-http-remote {<span class="symbol">:url</span>                <span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span>
                                                 <span class="symbol">:request-middleware</span> secured-request-middleware})}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The client simply pulls the token out of the js var, and puts it in the correct header.</p>
</div>
<div class="paragraph">
<p>You could also use a js-accessible cookie for this step, which would let you go back to static HTML serving. See the
earlier comments and links about CSRF.</p>
</div>
</div>
<div class="sect4">
<h5 id="_securing_sente_websockets_fulcro_2_7_with_sente_1_14"><a class="anchor" href="#_securing_sente_websockets_fulcro_2_7_with_sente_1_14"></a><a class="link" href="#_securing_sente_websockets_fulcro_2_7_with_sente_1_14">Securing Sente Websockets (Fulcro 2.7+ with Sente 1.14+)</a></h5>
<div class="paragraph">
<p>Older versions of Sente had a CSRF security hole, for which we had the <a href="#OldSenteCSRF">documented workaround</a>.
 New versions of Sente have a fix, so the implementation is much easier:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure to include <code>wrap-anti-forgery</code> (or enable it in <code>wrap-defaults</code>) in your middleware.</p>
</li>
<li>
<p>Embed the CSRF token in your HTML as a js var or in the DOM itself.  Serving the CSRF token in the HTML is an
accepted security practice that prevents external discovery.</p>
</li>
<li>
<p>Send the CSRF token you find in cljs to the websocket constructor.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The websocket remote need only be passed the CSRF token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [csrf-token js/embedded_csrf_token]
  (fulcro.websockets/make-websocket-networking {<span class="symbol">:uri</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/chsk</span><span class="delimiter">&quot;</span></span>
                                                <span class="symbol">:csrf-token</span> csrf-token
                                                <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the documentation on general websockets for more information on their server-side setup other general options, but
be sure to include the anti-forgery middleware so it runs before your API if you want to enforce CSRF protections.</p>
</div>
</div>
<div class="sect4">
<h5 id="OldSenteCSRF"><a class="anchor" href="#OldSenteCSRF"></a><a class="link" href="#OldSenteCSRF">Securing Sente Websockets (Fulcro 2.6.x and Sente Prior to 1.14)</a></h5>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Do not use this approach for new apps!  Upgrade Fulcro and sente instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sente has an internal CSRF support, which it uses to deal with augmenting the POST requests it might make (it supports
alternate network techniques to get around missing websocket support).  Unfortunately,
it exchanges the CSRF from <code>wrap-anti-forgery</code> within a (js-accessible) handshake.  This <strong>can</strong> be ok <strong>as long as that
handshake never happens without CSRF protection *already in place</strong>.  Otherwise you are open to websocket hijacking, and
also exposing the CSRF token and compromising your <strong>other</strong> remote processing as well!  (This was a reported issue
on Sente, and is fixed in 1.14.0-RC1)</p>
</div>
<div class="paragraph">
<p>Fulcro&#8217;s websocket contruction function allows you to pass a parameters through sente, and you can use these to
include the CSRF token, and then add a bit of additional middleware to require that in front of your websocket setup
code on the server. This ensures that Sente cannot do a handshake (and expose the token) without proving that
the source page <strong>already knows</strong> the token.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
I know I&#8217;ve said this more than once now, but here it is a different way: Sente will stop warning about the
lack of CSRF as <strong>soon</strong> as you add the anti-forgery middleware; however, that does not secure your app.  You must verify
that the client talking to you is valid before starting the handshake or you are open to websocket hijacking attacks.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The code to do this all is very similar to the normal remotes, so we&#8217;ll just show the differences.</p>
</div>
<div class="paragraph">
<p>Of course, you need websocket middleware, and it needs to do CSRF checks <strong>before</strong> the Sente handshake:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="keyword">..</span><span class="keyword">.</span>

(<span class="keyword">defn-</span> <span class="function">is-wsrequest?</span> [{<span class="symbol">:keys</span> [uri]}] (<span class="keyword">=</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/chsk</span><span class="delimiter">&quot;</span></span> uri))

(<span class="keyword">defn</span> <span class="function">enforce-csrf!</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Checks the CSRF token. If it is ok, runs the `ok-response-handler`; otherwise returns a 403 response
  and logs the CSRF violation.</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [anti-forgery-token params]} ok-response-handler]
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [csrf-token]} params
        token-matches? (<span class="keyword">and</span> (<span class="keyword">seq</span> csrf-token) (<span class="keyword">=</span> csrf-token anti-forgery-token))]
    (timbre/debug <span class="string"><span class="delimiter">&quot;</span><span class="content">Setting up websocket request. Incoming security token is: </span><span class="delimiter">&quot;</span></span> csrf-token)
    (timbre/debug <span class="string"><span class="delimiter">&quot;</span><span class="content">Expected CSRF token is </span><span class="delimiter">&quot;</span></span> anti-forgery-token)
    (<span class="keyword">if</span> token-matches?
      (ok-response-handler)
      (<span class="keyword">do</span>
        (timbre/error <span class="string"><span class="delimiter">&quot;</span><span class="content">CSRF FAILURE. The token received does not match the expected value.</span><span class="delimiter">&quot;</span></span>)
        (<span class="keyword">-&gt;</span> (response/response <span class="string"><span class="delimiter">&quot;</span><span class="content">Cross site requests are not supported.</span><span class="delimiter">&quot;</span></span>)
          (response/status <span class="integer">403</span>))))))

(<span class="keyword">defn</span> <span class="function">wrap-websockets</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Add websocket middleware.  This middleware does a CSRF check on the GET (normal Ring only checks POSTS)
  to ensure we don't start a Sente handshake unless the client has already proven it knows the CSRF token.</span><span class="delimiter">&quot;</span></span>
  [base-request-handler]
  (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [request-method] <span class="symbol">:as</span> req}]
    (<span class="keyword">if</span> (is-wsrequest? req)
      (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [ring-ajax-post ring-ajax-get-or-ws-handshake]} websockets]
        <span class="comment">;; The enforcement is really on GET, which ring's middleware won't block,</span>
        <span class="comment">;; but which exposes the token in the handshake</span>
        (enforce-csrf! req (<span class="keyword">fn</span> []
                             (<span class="keyword">case</span> request-method
                               <span class="symbol">:get</span> (ring-ajax-get-or-ws-handshake req)
                               <span class="symbol">:post</span> (ring-ajax-post req)))))
      (base-request-handler req))))

<span class="keyword">..</span><span class="keyword">.</span>

(defstate middleware
  <span class="symbol">:start</span>
  (<span class="keyword">let</span> [defaults-config (<span class="symbol">:ring.middleware/defaults-config</span> config)
        legal-origins   (<span class="keyword">get</span> config <span class="symbol">:legal-origins</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>})]
    (timbre/debug <span class="string"><span class="delimiter">&quot;</span><span class="content">Configuring middleware-defaults with</span><span class="delimiter">&quot;</span></span> (<span class="keyword">with-out-str</span> (pprint defaults-config)))
    (timbre/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Restricting origins to </span><span class="delimiter">&quot;</span></span> legal-origins)
    (<span class="keyword">when-not</span> (<span class="keyword">get-in</span> defaults-config [<span class="symbol">:security</span> <span class="symbol">:ssl-redirect</span>])
      (timbre/warn <span class="string"><span class="delimiter">&quot;</span><span class="content">SSL IS NOT ENFORCED: YOU ARE RUNNING IN AN INSECURE MODE (only ok for development)</span><span class="delimiter">&quot;</span></span>))
    (<span class="keyword">-&gt;</span> not-found-handler
      wrap-websockets
      server/wrap-transit-params
      server/wrap-transit-response
      (server/wrap-protect-origins {<span class="symbol">:allow-when-origin-missing?</span> <span class="predefined-constant">true</span>
                                    <span class="symbol">:legal-origins</span>              legal-origins})
      (wrap-uris {<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>           generate-index
                  <span class="string"><span class="delimiter">&quot;</span><span class="content">/index.html</span><span class="delimiter">&quot;</span></span> generate-index})
      (wrap-defaults defaults-config)
      wrap-gzip)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only thing different in the stack itself is switching from normal remoting to websockets.</p>
</div>
<div class="paragraph">
<p>The client change is also quite small: switch over to using websockets and send the page-embedded token with the
websocket startup request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fc/make-fulcro-client
      {<span class="symbol">:networking</span> {<span class="symbol">:remote</span>
                    (fws/make-websocket-networking
                      {<span class="symbol">:websockets-uri</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/chsk</span><span class="delimiter">&quot;</span></span>
                       <span class="symbol">:push-handler</span>   push-handler
                       <span class="comment">;; we use params instead of Sente's ajax-options (which would be nice for setting headers)</span>
                       <span class="comment">;; because Sente doesn't use those for the initial socket request :(</span>
                       <span class="comment">;; Not ideal, since the CSRF token might end up stored in browser caches, proxy servers, etc.</span>
                       <span class="comment">;; Perhaps someone would make a PR to Sente?</span>
                       <span class="symbol">:req-params</span>     {<span class="symbol">:csrf-token</span> (<span class="keyword">or</span> js/fulcro_network_csrf_token <span class="string"><span class="delimiter">&quot;</span><span class="content">TOKEN-NOT-IN-HTML!</span><span class="delimiter">&quot;</span></span>)}})}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can play with this by cloning the <a href="https://github.com/fulcrologic/security-websockets-demo">complete source for this demo</a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dev_cards_and_workspaces"><a class="anchor" href="#_dev_cards_and_workspaces"></a><a class="link" href="#_dev_cards_and_workspaces">22. Dev Cards <a id="DevCards"></a> and Workspaces</a></h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Not yet working/ported.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Devcards is an external library by Bruce Hauman that is also good for working up components,
active documentation, or even complete applications piece by piece. Fulcro comes with a macro
that makes embedding Fulcro Applications into a devcard trivial.</p>
</div>
<div class="paragraph">
<p>The Fulcro template now include Workspaces instead, but both are quite good. This chapter&#8217;s
concepts apply equally to both.</p>
</div>
<div class="sect2">
<h3 id="_the_project_setup"><a class="anchor" href="#_the_project_setup"></a><a class="link" href="#_the_project_setup">22.1. The Project Setup</a></h3>
<div class="paragraph">
<p>Simply include devcards in your dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[devcards <span class="string"><span class="delimiter">&quot;</span><span class="content">0.2.4</span><span class="delimiter">&quot;</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>and follow the basic setup instructions from that project&#8217;s documentation. Typically, a build
configuration like this when using shadow-cljs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"> <span class="symbol">:cards</span>    {<span class="symbol">:target</span>           <span class="symbol">:browser</span>
            <span class="symbol">:output-dir</span>       <span class="string"><span class="delimiter">&quot;</span><span class="content">resources/public/js/cards</span><span class="delimiter">&quot;</span></span>
            <span class="symbol">:asset-path</span>       <span class="string"><span class="delimiter">&quot;</span><span class="content">/js/cards</span><span class="delimiter">&quot;</span></span>
            <span class="symbol">:compiler-options</span> {<span class="symbol">:devcards</span> <span class="predefined-constant">true</span>}
            <span class="symbol">:modules</span>          {<span class="symbol">:main</span> {<span class="symbol">:entries</span> [app.cards]}}
            <span class="symbol">:devtools</span>         {<span class="symbol">:after-load</span> app.cards/refresh
                               <span class="symbol">:preloads</span> [fulcro.inspect.preload]
                               <span class="symbol">:http-root</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">resources/public</span><span class="delimiter">&quot;</span></span>
                               <span class="symbol">:http-port</span> <span class="integer">8023</span>}}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_developing_component_ui"><a class="anchor" href="#_developing_component_ui"></a><a class="link" href="#_developing_component_ui">22.2. Developing Component UI</a></h3>
<div class="paragraph">
<p>Developing simple components is done as described in the Devcard documentation. Fulcro encourages you to
use pure rendering, so that means it is quick and easy to make cards that display UI components in
all of their valid states. This is quite helpful when working out the data model and look of a component.
If you use component-local CSS this can be an extremely effective way to quickly build up
components for use in your application.</p>
</div>
<div class="sect3">
<h4 id="_visual_regression_testing"><a class="anchor" href="#_visual_regression_testing"></a><a class="link" href="#_visual_regression_testing">22.2.1. Visual Regression Testing</a></h4>
<div class="paragraph">
<p>Developing components in cards allows you to also do a form of visual regression testing. The basic idea is
to render the valid UI states for components, then have an automated script snapshot each card into an
image that can be compared with later CI runs.</p>
</div>
<div class="paragraph">
<p>See <a href="https://medium.com/adstage-engineering/how-we-test-our-full-stack-clojure-app-b18d79ee9e00">AdStage&#8217;s blog</a>
for a detailed example of this with the code necessary to make it work.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_developing_active_screens"><a class="anchor" href="#_developing_active_screens"></a><a class="link" href="#_developing_active_screens">22.3. Developing Active Screens</a></h3>
<div class="paragraph">
<p>The <code>defcard-fulcro</code> macro can embed a Fulcro application in a card. It allows any client options
to be passed to the client, but generates the mount into the card internally. It looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">my-cards</span>
  (<span class="symbol">:require</span>
            [devcards.core <span class="symbol">:as</span> dc <span class="symbol">:refer-macros</span> [defcard defcard-doc]]
            [fulcro.client.cards <span class="symbol">:refer</span> [defcard-fulcro]]))

(defcard-fulcro symbol-for-card
   AppRootUIComponent
   {}  <span class="comment">; initial state. Leave empty to use :initial-state from root component</span>
   {<span class="symbol">:inspect-data</span> <span class="predefined-constant">false</span> <span class="comment">; normal devcard options</span>
    <span class="symbol">:fulcro</span> { <span class="symbol">:client-did-mount</span> (<span class="keyword">fn</span> [app] <span class="keyword">..</span><span class="keyword">.</span>)} <span class="comment">; fulcro client options</span>
   })</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_running_devcards_against_a_real_server"><a class="anchor" href="#_running_devcards_against_a_real_server"></a><a class="link" href="#_running_devcards_against_a_real_server">22.3.1. Running Devcards Against a Real Server</a></h4>
<div class="paragraph">
<p>Shadow-cljs and figwheel embed the hot loading websocket code into the compiled Javascript. This means
that you can serve devcards <strong>from your real application server</strong> simply by making
sure the HTML and Javascript for it are accessible through your server.</p>
</div>
<div class="paragraph">
<p>The Fulcro template even serves a dynamic <code>/wslive.html</code> to embed the CSRF token so that this works under the
security restrictions of your server.</p>
</div>
<div class="paragraph">
<p>This means that full-stack operations against your real application are trivial
from within cards.</p>
</div>
</div>
<div class="sect3">
<h4 id="_splitting_your_application"><a class="anchor" href="#_splitting_your_application"></a><a class="link" href="#_splitting_your_application">22.3.2. Splitting Your Application</a></h4>
<div class="paragraph">
<p>Hopefully you see that the ability to embed a full-stack Fulcro client inside
of a card is much more powerful than just embedding your <strong>entire</strong> application.</p>
</div>
<div class="paragraph">
<p>Remember, we have component <strong>normalization</strong>! The mutations and loads for any given part of
your application work independent of how your UI is nested. This means that you
can easily write your application in a way that allows you to factor it apart and embed just
portions into devcards for localized development and testing!</p>
</div>
<div class="paragraph">
<p>We think this can be quite revolutionary to development, since it allows you
to build up the application in completely dijoint steps and join them
together once they&#8217;re ready!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc ScreenOne [this props]
  {<span class="symbol">:ident</span> (<span class="keyword">fn</span> [] [<span class="symbol">:screens/id</span> <span class="symbol">:screen1</span>])}
  <span class="keyword">..</span><span class="keyword">.</span>)

(defmutation do-screen-1-thing [params]
  (action [env]
    <span class="comment">; operations relative to ident of ScreenOne</span>
    <span class="keyword">..</span><span class="keyword">.</span>)

(defcard-fulcro screen-1
   ScreenOne
   {}
   {<span class="symbol">:fulcro</span> {<span class="symbol">:client-did-mount</span>
              (<span class="keyword">fn</span> [app]
                 <span class="comment">; code to establish the context (preloads) that the real application would have done for this screen</span>
                 )}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Composition of the pieces can be as simple as dropping them into your UI router at the appropriate place!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="IFrames"><a class="anchor" href="#IFrames"></a><a class="link" href="#IFrames">22.4. Using External CSS via IFrames</a></h3>
<div class="paragraph">
<p>If you need to have the content of a devcard use external CSS, then you can use the <code>fulcro.client.elements/iframe</code>
to do so. This cool little tool creates an iframe, but then uses React to render into <strong>from</strong> the parent page. This
gives you the <strong>isolation</strong> of an iframe with the <strong>convenience</strong> of single-page reasoning!</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a quick function that can be used within a card to wrap UI that wants to use Bootstrap CSS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">render-example</span> [width height &amp; children]
  (ele/ui-iframe {<span class="symbol">:frameBorder</span> <span class="integer">0</span> <span class="symbol">:height</span> height <span class="symbol">:width</span> width}
    (<span class="keyword">apply</span> dom/div {<span class="symbol">:key</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">example-frame-key</span><span class="delimiter">&quot;</span></span>}
      (dom/link {<span class="symbol">:rel</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">stylesheet</span><span class="delimiter">&quot;</span></span> <span class="symbol">:href</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/css/bootstrap.min.css</span><span class="delimiter">&quot;</span></span>})
      children)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>this function can then be used to put a pre-sized iframe into a component like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc NavRoot [this props]
  { <span class="symbol">:query</span>         [<span class="symbol">:boo</span>]}
  (render-example <span class="string"><span class="delimiter">&quot;</span><span class="content">100%</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">150px</span><span class="delimiter">&quot;</span></span>
    (dom/div { <span class="symbol">:className</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">row</span><span class="delimiter">&quot;</span></span> }
      (dom/div {<span class="symbol">:className</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">col-md-1</span><span class="delimiter">&quot;</span></span>}
         <span class="keyword">..</span><span class="keyword">.</span>))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>this can then be used within a devcard, keeping the external CSS from messing with
the card layout or other cards.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_support_viewer"><a class="anchor" href="#_support_viewer"></a><a class="link" href="#_support_viewer">23. Support Viewer</a></h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Not yet ported/supported.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Fulcro automatically tracks the sequence of steps in the UI in history, including what transactions ran to move your
application from state to state. This enables you to do time travel for things like debugging and
error handling, but also allows you to serialize the history and send it to your servers for debugging sessions against
real user interactions!</p>
</div>
<div class="paragraph">
<p>The viewer is already written for you, and is in the <code>fulcro.support-viewer</code> namespace. There are a few things you
have to do in order to make it work.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
You must be careful to follow the rule that "only data goes in the database". Things like anonymous functions
are not serializable, and therefore if you store them in app state you will break your ability to use history for
things like support viewer. See the documentation on <a href="https://github.com/cognitect/transit-format">Transit</a> for a
description of the default types that are serializable and
for some hints on how you can extend transit to support additional types.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_sending_a_support_request"><a class="anchor" href="#_sending_a_support_request"></a><a class="link" href="#_sending_a_support_request">23.1. Sending a Support Request</a></h3>
<div class="paragraph">
<p>There is a built-in mutation that can do this called <code>com.fulcrologic.fulcro.mutations/send-history</code>. It can accept anything
as parameters, and will send the support request to <code>:remote</code>. All you have to do is run it via UI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(transact! this `[(m/send-history {<span class="symbol">:support-id</span> ~(comp/tempid)})])</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_storing_the_support_request"><a class="anchor" href="#_storing_the_support_request"></a><a class="link" href="#_storing_the_support_request">23.2. Storing the Support Request</a></h3>
<div class="paragraph">
<p>Basically you just have to write something to handle the <code>com.fulcrologic.fulcro.mutations/send-history</code> mutation, save the
data, and return a tempid remapping (optional, since the client itself won&#8217;t care):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(server/defmutation com.fulcrologic.fulcro.mutations/send-history [params]
  (action [env]
     <span class="keyword">..</span><span class="keyword">.</span>save the history from params.<span class="keyword">..</span>
     <span class="keyword">..</span><span class="keyword">.</span><span class="keyword">send</span> an email to a developer with the saved id?.<span class="keyword">..</span>))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_support_viewer"><a class="anchor" href="#_using_the_support_viewer"></a><a class="link" href="#_using_the_support_viewer">23.3. Using the Support Viewer</a></h3>
<div class="paragraph">
<p>The support viewer is a simple UI that is pre-programmed in the <code>fulcro.support-viewer</code> namespace. When started, it
will issue a load in order to obtain the history you saved in the prior step. It will then run the application
(which you also have to point to) with that history in a DVR-style playback.</p>
</div>
<div class="paragraph">
<p>You can see how simple the
[client setup](<a href="https://github.com/fulcrologic/fulcro-todomvc/blob/master/src/main/fulcro_todomvc/support_viewer.cljs" class="bare">https://github.com/fulcrologic/fulcro-todomvc/blob/master/src/main/fulcro_todomvc/support_viewer.cljs</a>) is here, and
look at the defmutation for the <code>send-history</code> and query for <code>:support-request</code> in this file:
[Server API](<a href="https://github.com/fulcrologic/fulcro-todomvc/blob/master/src/main/fulcro_todomvc/api.clj" class="bare">https://github.com/fulcrologic/fulcro-todomvc/blob/master/src/main/fulcro_todomvc/api.clj</a>)</p>
</div>
</div>
<div class="sect2">
<h3 id="_compressible_transactions"><a class="anchor" href="#_compressible_transactions"></a><a class="link" href="#_compressible_transactions">23.4. Compressible Transactions</a></h3>
<div class="paragraph">
<p>The <code>compressible-transact!</code> function support compressing transactions that would be otherwise annoying to step through. It works
as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use <code>compressible-transact!</code> instead of <code>transact!</code></p>
</li>
<li>
<p>If more than one adjacent transaction is marked compressible in history then only the <strong>last</strong> of them is kept.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The built-in mutations that set a value (e.g. <code>m/set-value!</code>) are meant to be used with user inputs and already mark their
transactions this way. This is quite useful when you don&#8217;t want to pollute (or overflow) history with keystrokes that
are not interesting.</p>
</div>
</div>
<div class="sect2">
<h3 id="_demo"><a class="anchor" href="#_demo"></a><a class="link" href="#_demo">23.5. Demo</a></h3>
<div class="paragraph">
<p>See <a href="https://github.com/fulcrologic/fulcro-todomvc/tree/master/src/main/fulcro_todomvc">Fulcro TodoMVC</a> for an example.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_code_splitting_modules"><a class="anchor" href="#_code_splitting_modules"></a><a class="link" href="#_code_splitting_modules">24. Code Splitting (modules)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO: This chapter could use some updates, even though what it says will "work".</p>
</div>
<div class="paragraph">
<p>Clojurescript 1.9.854+ has expanded support for code splitting (older versions do too, but require a bit more code). The
main things you need to do to accomplish code splitting are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure your main app doesn&#8217;t accidentally refer to things in the module. Hard dependencies make it
impossible to split the code.</p>
</li>
<li>
<p>Define a mechanism whereby your loaded code can find and install itself into the application.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Since you&#8217;re working with a data-driven application with components that have queries, this typically means that you&#8217;re
going to need to have the newly loaded components somehow modify the main application&#8217;s query to tie them in. Also,
since parents technically render children, you&#8217;re going to need to have an extensible mechanism for that as well.</p>
</div>
<div class="paragraph">
<p>To demonstrate one technique we&#8217;ll assume that what you load is a "section" of the application that can be routed to. The
main application knows to provide the link, but it does not yet have the rendering factory, class, or query.</p>
</div>
<div class="sect2">
<h3 id="_dynamic_routing_and_code_splitting"><a class="anchor" href="#_dynamic_routing_and_code_splitting"></a><a class="link" href="#_dynamic_routing_and_code_splitting">24.1. Dynamic Routing and Code Splitting</a></h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
There was a bug in dynamic queries prior to 2.6.0, which are used by dynamic routers.  Make sure you&#8217;re using
a newer version of Fulcro for this support.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>com.fulcrologic.fulcro.routing.legacy-ui-routers</code> namespace includes a second kind of UI router that can be used with the routing tree: <code>DynamicRouter</code>.</p>
</div>
<div class="paragraph">
<p>A <code>DynamicRouter</code> uses a dynamic query to change routes instead of a union, and it can derive the details of the target
component at runtime, meaning that it can be used to route to screens that were not in the loaded application code base
at start-time.</p>
</div>
<div class="paragraph">
<p>Furthermore, the routing tree has been designed to trigger the proper dynamic module loads for your dynamically loaded
routes so that code splitting your application can be a fairly simple exercise. Here are the basic steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Pick a keyword for the name of a given screen. Say <code>:main</code></p>
</li>
<li>
<p>Write the <code>defsc</code> for that screen, and design it so that the TYPE (first element) of the ident is the keyword from (1).</p>
<div class="ulist">
<ul>
<li>
<p>The initial state must be defined, and it must have the name (1) under the key r/dynamic-route-key</p>
</li>
<li>
<p>The bottom of the file that defines the target screen <strong>must</strong> include a <code>defmethod</code> that associates the keyword (1) with the component (2). This
is how the dynamic router finds the initial state of the screen, and the query to route to.</p>
</li>
<li>
<p>IMPORTANT: Your dynamically loaded screen <strong>MUST</strong> have a call to <code>(cljs.loader/set-loaded! KW)</code> at the bottom of the file (where KW is from (1)).</p>
</li>
</ul>
</div>
</li>
<li>
<p>Configure your cljs build to use modules. Place the screen from (2) into a module with the name from (1).</p>
</li>
<li>
<p>Use a DynamicRouter for the router that will route to the screen (2). This means you won&#8217;t have to explicitly refer to the class of the component.</p>
<div class="ulist">
<ul>
<li>
<p>The Query that composes in the router must use the special <code>get-dynamic-router-query</code> to join in the DynamicRouter&#8217;s query.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Create your routing tree as usual. Remember that a routing tree is just routing instructions (keywords).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you are routing through a DynamicRouter as part of your initial startup, then there are a few more steps. See Pre-loaded routes below.</p>
</div>
<div class="paragraph">
<p>Trigger routing via the <code>route-to</code> mutation. That&#8217;s it! The module rooted at the screen will be automatically loaded
when needed.</p>
</div>
<div class="paragraph">
<p>The <code>defsc</code> and <code>defmethod</code> needed for step 2 look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(comp/defsc Main [this {<span class="symbol">:keys</span> [label]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {r/dynamic-route-key <span class="symbol">:main</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">MAIN</span><span class="delimiter">&quot;</span></span>})
   <span class="symbol">:ident</span> (<span class="keyword">fn</span> [] [<span class="symbol">:main</span> <span class="symbol">:singleton</span>])
   <span class="symbol">:query</span> [r/dynamic-route-key <span class="symbol">:label</span>]}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>}}
        label))

(<span class="keyword">defmethod</span> <span class="function">r/get-dynamic-router-target</span> <span class="symbol">:main</span> [k] Main)
(cljs.loader/set-loaded! <span class="symbol">:main</span>)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_pre_loaded_routes"><a class="anchor" href="#_pre_loaded_routes"></a><a class="link" href="#_pre_loaded_routes">24.1.1. Pre-loaded Routes</a></h4>
<div class="paragraph">
<p>Screens used with DynamicRouter that are loaded at start-time are written identically to the dynamically loaded screen,
but you will have to make sure their state and multimethod are set up at load time. This can be done
via the mutation <code>r/install-route</code>. This mutation adds the screen&#8217;s state <strong>and</strong> multimethod component dispatch.</p>
</div>
<div class="paragraph">
<p>The demo application includes two such pre-installed routes (<code>Login</code> and <code>NewUser</code>), and one dynamically loaded one (main).
The code (called at application startup via <code>:client-did-mount</code>) to set up the pre-loaded routes and
is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">application-loaded!</span> [{<span class="symbol">:keys</span> [reconciler]}]
  <span class="comment">; Let the dynamic router know that two of the routes are already loaded.</span>
  (comp/transact! reconciler `[(r/install-route {<span class="symbol">:target-kw</span> <span class="symbol">:new-user</span> <span class="symbol">:component</span> ~NewUser})
                               (r/install-route {<span class="symbol">:target-kw</span> <span class="symbol">:login</span> <span class="symbol">:component</span> ~Login})
                               (r/route-to {<span class="symbol">:handler</span> <span class="symbol">:login</span>})])
  <span class="comment">; Clojurescript requires you call this on every successfully &quot;loaded&quot; module:</span>
  (loader/set-loaded! <span class="symbol">:entry-point</span>))

<span class="keyword">..</span><span class="keyword">.</span>
(make-fulcro-client Root {<span class="symbol">:client-did-mount</span> application-loaded!})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_demo"><a class="anchor" href="#_the_demo"></a><a class="link" href="#_the_demo">24.1.2. The Demo</a></h4>
<div class="paragraph">
<p>Notice on initial load that the <code>[:main :singleton]</code> path in app state is not present. You could use the console to
verify that <code>cards.dynamic_ui_main.Main</code> is not present (via Javascript) either. Once you route to <code>Main</code>, both will be present.
You should see the network load of the code when you route as well. The <code>book</code> build configuration in <code>project.clj</code> has the module
definitions, and looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:id</span>           <span class="string"><span class="delimiter">&quot;</span><span class="content">book</span><span class="delimiter">&quot;</span></span>
                <span class="symbol">:source-paths</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">src/main</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">src/book</span><span class="delimiter">&quot;</span></span>]
                <span class="symbol">:compiler</span>     {<span class="symbol">:output-dir</span>     <span class="string"><span class="delimiter">&quot;</span><span class="content">resources/public/js/book</span><span class="delimiter">&quot;</span></span>
                               <span class="symbol">:asset-path</span>     <span class="string"><span class="delimiter">&quot;</span><span class="content">js/book</span><span class="delimiter">&quot;</span></span>
                               <span class="symbol">:modules</span>        {<span class="symbol">:entry-point</span> {<span class="symbol">:output-to</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">resources/public/js/book/book.js</span><span class="delimiter">&quot;</span></span>
                                                              <span class="symbol">:entries</span>   #{book.main}}
                                                <span class="comment">; For the dynamic code splitting demo</span>
                                                <span class="symbol">:main</span>        {<span class="symbol">:output-to</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">resources/public/js/book/main-ui.js</span><span class="delimiter">&quot;</span></span>
                                                              <span class="symbol">:entries</span>   #{book.demos.dynamic-ui-main}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The HTML file to start this up must load the base CLJS module (<code>js/book/cljs_base.js</code>) and the entry point <code>book.js</code> file.
The other code will be in <code>main-ui.js</code> and will be loaded when you route to that screen.</p>
</div>
<div class="paragraph">
<p>The file <code>dynamic_ui_main.cljs</code> is the code that will be dynamically loaded. It looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.dynamic-ui-main</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    cljs.loader
    [taoensso.timbre <span class="symbol">:as</span> log]))

<span class="comment">; This is a &quot;screen&quot; that we want to load with code-splitting modules. See the &quot;demos&quot; build in project.clj. The name</span>
<span class="comment">; of the module needs to match the first element of the ident, as that's how the dynamic router figures out what module</span>
<span class="comment">; to load.</span>
(defsc Main [this {<span class="symbol">:keys</span> [label main-prop]}]
  {<span class="symbol">:query</span>         [r/dynamic-route-key <span class="symbol">:label</span> <span class="symbol">:main-prop</span>]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {r/dynamic-route-key <span class="symbol">:ui-main</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">MAIN</span><span class="delimiter">&quot;</span></span> <span class="symbol">:main-prop</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">main page data</span><span class="delimiter">&quot;</span></span>})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:ui-main</span> <span class="symbol">:singleton</span>])}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>}}
    (<span class="keyword">str</span> label <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> main-prop)))

(<span class="keyword">defn</span> ^<span class="symbol">:export</span> init []
  (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">dynamic ui main loaded</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">defmethod</span> <span class="function">r/get-dynamic-router-target</span> <span class="symbol">:ui-main</span> [k] Main)
(cljs.loader/set-loaded! <span class="symbol">:ui-main</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main entry point code is in the code below the demo:</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. <a id="DynamicUIRouting"></a><a href="#DynamicUIRouting">Dynamic UI Routing</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('dynamic-ui-routing')">Focus Inspector</button>
<div class="short narrow example" id="dynamic-ui-routing"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.dynamic-ui-routing</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [cljs.loader <span class="symbol">:as</span> loader]
    [taoensso.timbre <span class="symbol">:as</span> log]))

(defsc Login [this {<span class="symbol">:keys</span> [label login-prop]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {r/dynamic-route-key <span class="symbol">:login</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">LOGIN</span><span class="delimiter">&quot;</span></span> <span class="symbol">:login-prop</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">login data</span><span class="delimiter">&quot;</span></span>})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:login</span> <span class="symbol">:singleton</span>])
   <span class="symbol">:query</span>         [r/dynamic-route-key <span class="symbol">:label</span> <span class="symbol">:login-prop</span>]}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">green</span><span class="delimiter">&quot;</span></span>}}
    (<span class="keyword">str</span> label <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> login-prop)))

(defsc NewUser [this {<span class="symbol">:keys</span> [label new-user-prop]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {r/dynamic-route-key <span class="symbol">:new-user</span> <span class="symbol">:label</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">New User</span><span class="delimiter">&quot;</span></span> <span class="symbol">:new-user-prop</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">new user data</span><span class="delimiter">&quot;</span></span>})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:new-user</span> <span class="symbol">:singleton</span>])
   <span class="symbol">:query</span>         [r/dynamic-route-key <span class="symbol">:label</span> <span class="symbol">:new-user-prop</span>]}
  (dom/div {<span class="symbol">:style</span> {<span class="symbol">:backgroundColor</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">skyblue</span><span class="delimiter">&quot;</span></span>}}
    (<span class="keyword">str</span> label <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> new-user-prop)))

(defsc Root [this {<span class="symbol">:keys</span> [top-router <span class="symbol">:com.fulcrologic.fulcro.routing.legacy-ui-routers/pending-route</span>]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] (<span class="keyword">merge</span>
                                 (r/routing-tree
                                   (r/make-route <span class="symbol">:ui-main</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:ui-main</span> <span class="symbol">:singleton</span>])])
                                   (r/make-route <span class="symbol">:login</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:login</span> <span class="symbol">:singleton</span>])])
                                   (r/make-route <span class="symbol">:new-user</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:new-user</span> <span class="symbol">:singleton</span>])]))
                                 {<span class="symbol">:top-router</span> (comp/get-initial-state r/DynamicRouter {<span class="symbol">:id</span> <span class="symbol">:top-router</span>})}))
   <span class="symbol">:query</span>         [<span class="symbol">:ui/react-key</span> {<span class="symbol">:top-router</span> (r/get-dynamic-router-query <span class="symbol">:top-router</span>)}
                   <span class="symbol">:com.fulcrologic.fulcro.routing.legacy-ui-routers/pending-route</span>
                   r/routing-tree-key]}
  (dom/div <span class="predefined-constant">nil</span>
    <span class="comment">; Sample nav mutations</span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:ui-main</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Main</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:new-user</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">New User</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/a {<span class="symbol">:onClick</span> #(comp/transact! this `[(r/route-to {<span class="symbol">:handler</span> <span class="symbol">:login</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Login</span><span class="delimiter">&quot;</span></span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>
    (dom/div (<span class="keyword">if</span> pending-route <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Done</span><span class="delimiter">&quot;</span></span>))
    (r/ui-dynamic-router top-router)))

<span class="comment">; Use this as started-callback. These would happen as a result of module loads:</span>
(<span class="keyword">defn</span> <span class="function">application-loaded</span> [app]
  <span class="comment">; Let the dynamic router know that two of the routes are already loaded.</span>
  (comp/transact! app `[(r/install-route {<span class="symbol">:target-kw</span> <span class="symbol">:new-user</span> <span class="symbol">:component</span> ~NewUser})
                        (r/install-route {<span class="symbol">:target-kw</span> <span class="symbol">:login</span> <span class="symbol">:component</span> ~Login})
                        (r/route-to {<span class="symbol">:handler</span> <span class="symbol">:login</span>})]))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_code_splitting_and_server_side_rendering"><a class="anchor" href="#_code_splitting_and_server_side_rendering"></a><a class="link" href="#_code_splitting_and_server_side_rendering">24.2. Code Splitting and Server-Side Rendering</a></h3>
<div class="paragraph">
<p>Version 2.5.2 of Fulcro added the support functions necessary to support server-side rendering of dynamic routes. The
basics can be see in this example below:</p>
</div>
<div class="paragraph">
<p>One screen is defined in <code>other.cljc</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">ssr-dynamic-routing.ui.other</span>
  (<span class="symbol">:require</span>
    <span class="error">#</span>?(<span class="symbol">:cljs</span> [cljs.loader <span class="symbol">:as</span> loader])
    <span class="error">#</span>?(<span class="symbol">:cljs</span> [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom] <span class="symbol">:clj</span>
        [com.fulcrologic.fulcro.dom-server <span class="symbol">:as</span> dom])
        [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
        [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r]))

(defsc Other [this {<span class="symbol">:keys</span> [x]}]
  {<span class="symbol">:query</span>         [r/dynamic-route-key <span class="symbol">:x</span>]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:other</span> <span class="symbol">:singleton</span>])
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {<span class="symbol">:x</span>                  <span class="integer">1</span>
                           r/dynamic-route-key <span class="symbol">:other</span>})}
  (dom/div <span class="predefined-constant">nil</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Other:</span><span class="delimiter">&quot;</span></span> x)))

(<span class="keyword">defmethod</span> <span class="function">r/get-dynamic-router-target</span> <span class="symbol">:other</span> [_] Other)
<span class="error">#</span>?(<span class="symbol">:cljs</span> (loader/set-loaded! <span class="symbol">:other</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another (with Root and the routing tree) is in <code>main.cljc</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">ssr-dynamic-routing.ui.root</span>
  (<span class="symbol">:require</span>
    <span class="error">#</span>?(<span class="symbol">:cljs</span> [cljs.loader <span class="symbol">:as</span> loader])
    <span class="error">#</span>?(<span class="symbol">:cljs</span> [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom] <span class="symbol">:clj</span>
        [com.fulcrologic.fulcro.dom-server <span class="symbol">:as</span> dom])
        [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
        [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r]))

(<span class="keyword">def</span> <span class="function">routing-tree</span> (r/routing-tree
                    (r/make-route <span class="symbol">:main</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:main</span> <span class="symbol">:singleton</span>])])
                    (r/make-route <span class="symbol">:other</span> [(r/router-instruction <span class="symbol">:top-router</span> [<span class="symbol">:other</span> <span class="symbol">:singleton</span>])])))

(defsc Main [this {<span class="symbol">:keys</span> [y]}]
  {<span class="symbol">:query</span>         [r/dynamic-route-key <span class="symbol">:y</span>]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {r/dynamic-route-key <span class="symbol">:main</span>
                           <span class="symbol">:y</span>                  <span class="integer">3</span>})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:main</span> <span class="symbol">:singleton</span>])}
  (dom/div (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">MAIN </span><span class="delimiter">&quot;</span></span> y)))

(<span class="keyword">def</span> <span class="function">ui-main</span> (comp/factory Main))

(defsc Root [this {<span class="symbol">:keys</span> [top-router]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:top-router</span> (r/get-dynamic-router-query <span class="symbol">:top-router</span>)}]
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] (<span class="keyword">merge</span>
                            routing-tree
                            {r/dynamic-route-key <span class="symbol">:main</span>
                             <span class="symbol">:top-router</span>         (comp/get-initial-state r/DynamicRouter {<span class="symbol">:id</span> <span class="symbol">:top-router</span>})}))}
  (r/ui-dynamic-router top-router))

(<span class="keyword">defmethod</span> <span class="function">r/get-dynamic-router-target</span> <span class="symbol">:main</span> [_] Main)
<span class="error">#</span>?(<span class="symbol">:cljs</span> (loader/set-loaded! <span class="symbol">:main</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that these look pretty much like what was described in the normal client stuff.</p>
</div>
<div class="paragraph">
<p>Next, the basic server is then:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">ssr-dynamic-routing.server</span>
  (<span class="symbol">:require</span>
    [ring.util.response <span class="symbol">:as</span> resp]
    [fulcro.easy-server <span class="symbol">:refer</span> [make-fulcro-server]]
    [fulcro.server-render <span class="symbol">:as</span> ssr]
    [ssr-dynamic-routing.ui.other <span class="symbol">:as</span> other]
    [ssr-dynamic-routing.ui.root <span class="symbol">:as</span> root]
    [com.fulcrologic.fulcro.dom-server <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span>]
    [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r]))

(<span class="keyword">defn</span> <span class="function">build-ui-tree</span> [match]
  (<span class="keyword">let</span> [client-db (ssr/build-initial-state (comp/get-initial-state root/Root {}) root/Root)
        final-db  (<span class="keyword">-&gt;</span> client-db
                    <span class="comment">;; CRITICAL: Install the routes, or their state won't be in the db</span>
                    (r/install-route* <span class="symbol">:main</span> root/Main)
                    (r/install-route* <span class="symbol">:other</span> other/Other)
                    (r/route-to* match))]
    <span class="comment">;; CRITICAL: Pass the final database to get-query!!! Or you won't get the updated dynamic query</span>
    (comp/db-&gt;tree (comp/get-query root/Root final-db) final-db final-db)))

(<span class="keyword">defn</span> <span class="function">server-side-render</span> [env {<span class="symbol">:keys</span> [handler] <span class="symbol">:as</span> match}]
  (<span class="keyword">let</span> [ui-tree (build-ui-tree match)
        html    (dom/render-to-str ((comp/factory root/Root) ui-tree))]
    (<span class="keyword">-&gt;</span> (resp/response (<span class="keyword">str</span>
                         <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;html&gt;&lt;body&gt;&lt;div id='app'&gt;</span><span class="delimiter">&quot;</span></span>
                         html
                         <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><span class="delimiter">&quot;</span></span>))
      (resp/content-type <span class="string"><span class="delimiter">&quot;</span><span class="content">text/html</span><span class="delimiter">&quot;</span></span>))))

(<span class="keyword">defn</span> <span class="function">build-server</span>
  [{<span class="symbol">:keys</span> [config] <span class="symbol">:or</span> {config <span class="string"><span class="delimiter">&quot;</span><span class="content">config/dev.edn</span><span class="delimiter">&quot;</span></span>}}]
  (make-fulcro-server
    <span class="symbol">:parser-injections</span> #{<span class="symbol">:config</span>}
    <span class="comment">;; Quick way to hack a couple of pages in with different match handlers</span>
    <span class="symbol">:extra-routes</span> {<span class="symbol">:routes</span>   [<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">main.html</span><span class="delimiter">&quot;</span></span>  <span class="symbol">:main</span>
                                   <span class="string"><span class="delimiter">&quot;</span><span class="content">other.html</span><span class="delimiter">&quot;</span></span> <span class="symbol">:other</span>}]
                   <span class="symbol">:handlers</span> {<span class="symbol">:main</span>  server-side-render
                              <span class="symbol">:other</span> server-side-render}}
    <span class="symbol">:config-path</span> config))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re using the easy server extra routes system to serve the pages. These handlers conveniently return a map in
bidi match format, which can be used with <code>route-to*</code>. The critical pieces are marked:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Install the routes with <code>r/install-route*</code> for each screen</p>
</li>
<li>
<p>Use <code>route-to*</code> to update the database to the correct desired route</p>
</li>
<li>
<p>When you generate the UI tree with <code>db&#8594;tree</code>, be sure to pass the <code>get-query</code> the <strong>final</strong> db state after routing, otherwise
the dynamic queries won&#8217;t be seen, and rendering will be incorrect.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Performance"><a class="anchor" href="#Performance"></a><a class="link" href="#Performance">25. Performance</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fulcro and React behave in a very performant manner for most data-driven applications. There are ways, however,
in which you can negatively affect performance.</p>
</div>
<div class="sect2">
<h3 id="_development_compile_times"><a class="anchor" href="#_development_compile_times"></a><a class="link" href="#_development_compile_times">25.1. Development Compile Times</a></h3>
<div class="paragraph">
<p>One of the most annoying performance problems when building your application is slow compile times. We all want sub-second
rebuilds on our code base so that we can continue to work quickly.  Here are some tips about keeping your compile times
low:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use shadow-cljs instead of the plain CLJS compiler. <strong>Especially</strong> if you plan on using external Javascript libraries from npm.</p>
</li>
<li>
<p>Keep your namespaces small and <code>:require</code> sections pruned. This is about "size of code to compile", but it&#8217;s more
about the dependency graph. Whenever a save happens that new file needs to be compiled along with everything that
<strong>depends</strong> on it, <strong>and</strong> files that depend on those files up the dependency tree. Having large files means
a high false-positive factor in these reloads (reloading files whose code didn&#8217;t really depend on the subsection
you changed). If a file has just a few artifacts (e.g. functions) per file then less code will depend on
it and the recompile tree will be smaller for a given change.</p>
<div class="paragraph">
<p>When you put large amounts of code in a single namespace then many of your other
namespaces will likely depend on it (the probability of needing to <code>require</code> it
goes up with the number of artifacts within it).</p>
</div>
<div class="paragraph">
<p>Changing a single line of code in that large namespace not only will take a long time for that single namespace, but
will trigger tons of unnecessary dependent recompiles. I&#8217;ve adopted this in my recent personal projects, and this successfully keeps
my compile times quite low even as the source grows.  Technically this could probably be solved at the compiler level, but
it is a "hard problem" that may not be solved for some time (if ever).</p>
</div>
</li>
<li>
<p>You might want to use a [linter](<a href="https://github.com/candid82/joker" class="bare">https://github.com/candid82/joker</a>) to detect unused requires.</p>
</li>
<li>
<p>Keep the compiler up-to-date. I&#8217;ve seen 10-20% performance boosts in single releases.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_callbacks_causing_over_rendering"><a class="anchor" href="#_callbacks_causing_over_rendering"></a><a class="link" href="#_callbacks_causing_over_rendering">25.2. Callbacks causing Over-rendering</a></h3>
<div class="paragraph">
<p>A lot of people don&#8217;t realize that placing lambdas in their DOM can cause performance problems of various kinds:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A lambda closes over the surrounding environment, so it is regenerated every time it is executed.</p>
</li>
<li>
<p>The value of a lambda won&#8217;t compare as equal to the new one, meaning <code>shouldComponentUpdate</code> checks end up being useless.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code snippet contains both kinds of problems:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Comp [this props]
  {<span class="symbol">:query</span> <span class="keyword">..</span><span class="keyword">.</span>}
  (dom/div
    <span class="comment">;; computed props affect shouldComponentUpdate. The child will render any time the parent does, even if nothing</span>
    <span class="comment">;; else changed but the lamda</span>
    (ui-child (comp/computed child-props {<span class="symbol">:onDelete</span> #(comp/transact! this [(delete-child {<span class="symbol">:id</span> %})])}))
    <span class="comment">;; The lamda in the on-click will be regenerated on every render</span>
    (dom/button {<span class="symbol">:onClick</span> #(js/alert <span class="string"><span class="delimiter">&quot;</span><span class="content">Click!!!</span><span class="delimiter">&quot;</span></span>))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the time these kinds of functions can be fixed by generating the functions in a different context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; if there is no real data dependency on the component, just use a normal function defn</span>
(<span class="keyword">defn</span> <span class="function">click-alert!</span> []
  (js/alert <span class="string"><span class="delimiter">&quot;</span><span class="content">Click!</span><span class="delimiter">&quot;</span></span>))

(defsc Comp [this props]
  {<span class="symbol">:query</span> <span class="keyword">..</span><span class="keyword">.</span>
   <span class="symbol">:initLocalState</span> (<span class="keyword">fn</span> [this props]
                     <span class="comment">;; put the onDelete (which needs to close over `this`) into component-local state</span>
                     {<span class="symbol">:onDelete</span> #(comp/transact! this [(delete-child {<span class="symbol">:id</span> %})])})}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [onDelete]} (comp/get-state this)]
    (dom/div
      <span class="comment">;; The computed props are no longer changing, so shouldComponentUpdate will be accurate on child-props</span>
      (ui-child (comp/computed child-props {<span class="symbol">:onDelete</span> onDelete}))
      <span class="comment">;; The onClick now points to a pre-calculated value</span>
      (dom/button {<span class="symbol">:onClick</span> click-alert!))))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_poor_query_performance"><a class="anchor" href="#_poor_query_performance"></a><a class="link" href="#_poor_query_performance">25.3. Poor Query Performance</a></h3>
<div class="paragraph">
<p>This is by far the most common source of performance issues in Fulcro UIs. Evaluating the UI query is relatively fast, but <strong>relative</strong> is
the key word. The larger the query, the more work that has to be done to get the data for it. Remember that you compose all
component queries to the root. If you do this with <strong>only</strong> joins and props, then your root query will ask for <strong>everything</strong> that
your UI could <strong>ever</strong> show! This will perform poorly as your application gets large.</p>
</div>
<div class="paragraph">
<p>The solution to this is to ensure that your query contains only the currently relevant things.
There are two primary solutions for this: use union or dynamic queries.</p>
</div>
<div class="paragraph">
<p>The <code>com.fulcrologic.fulcro.routing.legacy-ui-routers</code> namespace includes primitives for building UI routes using unions (the unions are written
for you). It has a number of features, including the ability to nicely integrate with HTML5 history events for full HTML5
routing in your application.</p>
</div>
<div class="paragraph">
<p>In the dynamic query approach you use <code>comp/set-query!</code> to actually change the query of a component at runtime in
response to user events.</p>
</div>
<div class="paragraph">
<p>There are two "dynamic routers" that use dynamic queries to change their current query so it only includes the "current"
route. The older of these is present in the <code>legacy-ui-routers</code> namespace for legacy support, and should probably not be used
for new projects.</p>
</div>
<div class="paragraph">
<p>It is also important to note that you need not normalize things that are really just big blobs of data that you don&#8217;t
intend to mutate. An example of this is large reports where the data is read-only and only displayed in one place.
You could write a big nested bunch of components, normalize all of the parts, and write a query that joins it all back
together; however, that incurs a lot of overhead both in loading the data, and every time you render.</p>
</div>
<div class="paragraph">
<p>Instead, realize that a property query like <code>[:report-data]</code> can pull <strong>any</strong> kind of (serializable, if you want
tools support) value from the application state. You can put a <code>js/Date</code> there. You can put a map there. Anything.
Furthermore, this query is super-fast
since it just pulls that big blob of data from app state and adds it to the result tree. Structural sharing makes that
a very simple and fast operation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_poor_react_performance"><a class="anchor" href="#_poor_react_performance"></a><a class="link" href="#_poor_react_performance">25.4. Poor React Performance</a></h3>
<div class="paragraph">
<p>In general Fulcro should be able to handle a pretty high frame-rate. In fact, the design is meant to provide
60FPS rendering in general-purpose use. Remember, however, that there are a number of stages in rendering, and each of
them has an overhead. Large UIs can have negative performance impacts at both the query and DOM layers.</p>
</div>
<div class="paragraph">
<p>Since React does your rendering it is best to understand how to best optimize it using their suggestions and documentation. Note
that Fulcro already ensures that <code>shouldComponentUpdate</code> is defined to an optimal value that should prevent a regen/diff of VDOM
when data hasn&#8217;t really changed.</p>
</div>
<div class="paragraph">
<p>Some general tips to start with in React are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure your components have a <strong>stable</strong> react key. If the key changes, React will ignore the diff and redo the DOM. This is <strong>very</strong> slow. So,
if you&#8217;ve generated keys using something like random numbers just to get warnings to go away, then you&#8217;re asking for trouble.</p>
</li>
<li>
<p>You&#8217;re generally better off changing CSS classes than DOM structure. For example, having a <code>(when render? (dom/div &#8230;&#8203;))</code> will cause entire
sections to be inserted and removed from the DOM. Using a class is much more efficient: <code>(dom/div {:classes [(when-not render? " hidden")]} &#8230;&#8203;)</code>.</p>
</li>
<li>
<p>Large DOM. React is pretty good with eliminating unnecessary changes, but that is still no reason to try to render
a table with 1000&#8217;s of rows. Paginate.</p>
</li>
<li>
<p>Use <a href="#defscForOptimization">query-free <code>defsc</code> components</a> to break up large UI within a component. In this case the idea is that you may not need
subcomponents for query/normalization, but if you define them they will provide the <code>shouldComponentUpdate</code> optimization
for the props you pass them.</p>
</li>
<li>
<p>DO include empty props maps, even though they are optional. The DOM generators in Fulcro allow you to elide the props
if you don&#8217;t have any, but doing so means the macro cannot do certain compile-time optimizations. <code>(dom/div {} (dom/div {} &#8230;&#8203;))</code>
is about 3x faster at runtime than <code>(dom/div (dom/div &#8230;&#8203;))</code>.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing"><a class="anchor" href="#_testing"></a><a class="link" href="#_testing">26. Testing</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fulcro has a companion library called Fulcro Spec. It is a BDD DSL that wraps Clojure(script) test, and provides you
with a number of helpful features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Outline-based specifications.</p>
</li>
<li>
<p>A Mocking/expectation system.</p>
</li>
<li>
<p>Improved assertions with easier labelling.</p>
</li>
<li>
<p>All of the functions from <code>clojure.test</code> work inside of specifications (e.g. <code>is</code>, <code>are</code>, etc).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the documentation at the <a href="https://github.com/fulcrologic/fulcro-spec">repository</a> for more details.</p>
</div>
<div class="sect2">
<h3 id="_specifications"><a class="anchor" href="#_specifications"></a><a class="link" href="#_specifications">26.1. Specifications</a></h3>
<div class="paragraph">
<p>A specification is just a helpful wrapper around <code>clojure.test/deftest</code>. It looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(specification <span class="string"><span class="delimiter">&quot;</span><span class="content">The thing you're testing</span><span class="delimiter">&quot;</span></span>
   <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may wish to use <code>deftest</code> if your tooling recognizes it better.</p>
</div>
<div class="sect3">
<h4 id="_controlling_which_tests_run"><a class="anchor" href="#_controlling_which_tests_run"></a><a class="link" href="#_controlling_which_tests_run">26.1.1. Controlling Which Tests Run</a></h4>
<div class="paragraph">
<p>Adding keywords after the string name of a specification marks that specification for targeting (it adds metadata with that
keyword set to true to the test). You can define any number of these targeting keywords:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(specification <span class="string"><span class="delimiter">&quot;</span><span class="content">Some Database Operation</span><span class="delimiter">&quot;</span></span> <span class="symbol">:integration</span> <span class="symbol">:focused</span>
   <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_behaviors_components_and_assertions"><a class="anchor" href="#_behaviors_components_and_assertions"></a><a class="link" href="#_behaviors_components_and_assertions">26.2. Behaviors, Components, and Assertions</a></h3>
<div class="paragraph">
<p>These macros assist you in organizing your specification. The <code>behavior</code> and <code>component</code> macros just
increase readability. The <code>assertions</code> macro can add descriptions for each assertion,
and gives a nice human-readable notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(specification <span class="string"><span class="delimiter">&quot;</span><span class="content">Math</span><span class="delimiter">&quot;</span></span>
  (component <span class="string"><span class="delimiter">&quot;</span><span class="content">Addition</span><span class="delimiter">&quot;</span></span>
    (assertions
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Works with positive integers</span><span class="delimiter">&quot;</span></span>
      (<span class="keyword">+</span> <span class="integer">1</span> <span class="integer">1</span>) =&gt; <span class="integer">2</span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Works with negative integers</span><span class="delimiter">&quot;</span></span>
      (<span class="keyword">+</span> <span class="integer">-2</span> <span class="integer">-2</span>) =&gt; <span class="integer">-4</span>)))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions"><a class="anchor" href="#_exceptions"></a><a class="link" href="#_exceptions">26.3. Exceptions</a></h3>
<div class="paragraph">
<p>It is common to want to test error handling code. The <code>assertions</code> macro supports checking for, and pattern-matching
against, exceptions. It supports several notations for the right-hand side.</p>
</div>
<div class="paragraph">
<p>The most platform-neutral syntax for exceptions is to use a map on the right-hand side which can contain the keys (all
optional, but you should supply at least one):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="keyword">..</span><span class="keyword">.</span>
   (assertions
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Throws when arg is nil</span><span class="delimiter">&quot;</span></span>
      (f <span class="predefined-constant">nil</span>) =throws=&gt; ExceptionInfo
      (g <span class="predefined-constant">nil</span>) =throws=&gt; <span class="regexp"><span class="delimiter">#&quot;</span><span class="content">message pattern</span><span class="delimiter">&quot;</span></span>
      <span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using an exception type passes if that kind of exception is thrown. Using a regex passes if the message in the exception
matches.  Of course you can also use <code>is</code> and <code>clojure.test</code> exception facilities for other combinations, if needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_functional_assertions"><a class="anchor" href="#_functional_assertions"></a><a class="link" href="#_functional_assertions">26.4. Functional Assertions</a></h3>
<div class="paragraph">
<p>Often you don&#8217;t need a data comparison as much as you need to run a predicate on the result of a function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="keyword">..</span><span class="keyword">.</span>
   (assertions
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Returns odd numbers</span><span class="delimiter">&quot;</span></span>
      (f) =fn=&gt; <span class="keyword">odd?</span>)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mocking_and_spies"><a class="anchor" href="#_mocking_and_spies"></a><a class="link" href="#_mocking_and_spies">26.5. Mocking and Spies</a></h3>
<div class="paragraph">
<p>One of the most important features of sustainable testing is the ability to test things in isolation. Any kind of coupling
can result in cascading failures that make tests difficult to write/maintain/understand. Fulcro Spec has a mocking
system that is concise and allows you to do a number of advanced things. The basic syntax looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">f</span> [v] <span class="keyword">..</span><span class="keyword">.</span>)
(<span class="keyword">defn</span> <span class="function">g</span> [] (f <span class="integer">1</span>) <span class="integer">33</span>)

(specification <span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>
  (<span class="keyword">let</span> [real-f f] <span class="comment">; save f into a temporary binding</span>
    (when-mocking
      (f arg) =&gt; (<span class="keyword">do</span> <span class="comment">; rebinds `f` to this code</span>
                   (real-f arg) <span class="comment">; spy! Call the real original f</span>
                   (assertions
                     <span class="string"><span class="delimiter">&quot;</span><span class="content">calls f with 1</span><span class="delimiter">&quot;</span></span>
                     arg =&gt; <span class="integer">1</span>))

      (g))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s a lot going on here. The <code>when-mocking</code> macro looks for any number of arrow-separated triples (like <code>(f v) &#8658; 1</code>)
and re-binds the real function to an internally scripted one that captures the arguments and makes them available to the
code on the right-hand side of the triple (see <code>arg</code> above).</p>
</div>
<div class="paragraph">
<p>The form to the right of the <code>&#8658;</code> is run instead of the original function, and it can make assertions on the args
or even invoke the original.</p>
</div>
<div class="paragraph">
<p>If you specify a mock and it isn&#8217;t called, then the specification will fail. Thus, a check that <code>f</code> is actually called
is also implied by this test!</p>
</div>
<div class="sect3">
<h4 id="_specifying_call_count"><a class="anchor" href="#_specifying_call_count"></a><a class="link" href="#_specifying_call_count">26.5.1. Specifying Call Count</a></h4>
<div class="paragraph">
<p>It may be useful (or even necessary) to specify the number of times a function is called when mocking. The default is
"at least once". You can write a more complex scenario simply by adding a multiplier into the arrow!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">f</span> [] <span class="integer">99</span>)
(<span class="keyword">defn</span> <span class="function">g</span> [] (<span class="keyword">+</span> (f) (f))

(specification <span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>
  (assertions
    <span class="string"><span class="delimiter">&quot;</span><span class="content">produces the sum of two calls to f (coupled to the real definition of f)</span><span class="delimiter">&quot;</span></span>
    (g) =&gt; <span class="integer">198</span>))
  (when-mocking
    (f arg) =&gt; <span class="integer">2</span>

    (assertions
      <span class="string"><span class="delimiter">&quot;</span><span class="content">produces the sum of two calls to f (mocking returns same thing over and over)</span><span class="delimiter">&quot;</span></span>
      (g) =&gt; <span class="integer">4</span>))
  (when-mocking
    (f arg) =1x=&gt; <span class="integer">2</span>
    (f arg) =1x=&gt; <span class="integer">4</span>

    (assertions
      <span class="string"><span class="delimiter">&quot;</span><span class="content">produces the sum of two calls to f (called exactly twice is enforced, and different values returned)</span><span class="delimiter">&quot;</span></span>
      (g) =&gt; <span class="integer">6</span>)))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_checking_order"><a class="anchor" href="#_checking_order"></a><a class="link" href="#_checking_order">26.5.2. Checking Order</a></h4>
<div class="paragraph">
<p>When call counts are specified they imply order, and that order is checked as well by the internals of mocking. For
example a <code>1x</code> mock of <code>f</code>, <code>g</code>, <code>f</code> will fail if <code>f</code> is called twice before <code>g</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_limitations"><a class="anchor" href="#_limitations"></a><a class="link" href="#_limitations">26.5.3. Limitations</a></h4>
<div class="paragraph">
<p>Fulcro spec has some limitations that are inherent to the underlying programming language/VM.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It cannot mock inline, protocols, or macros.</p>
</li>
<li>
<p>You&#8217;re always creating "partial mocks". Expanding a function will often invalidate the mocking around it.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_logging"><a class="anchor" href="#_logging"></a><a class="link" href="#_logging">27. Logging</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fulcro 3 uses <a href="https://github.com/ptaoussanis/timbre">Timbre</a>. Read the documentation on that website for changing
logging levels, eliding logging statements, etc.</p>
</div>
<div class="sect2">
<h3 id="_logging_helpers"><a class="anchor" href="#_logging_helpers"></a><a class="link" href="#_logging_helpers">27.1. Logging Helpers</a></h3>
<div class="paragraph">
<p>The logging output of errors in CLJS leaves something to be desired when used with stock Timbre. Fortunately, this
is quite configurable, and Fulcro provides a couple of useful helpers that can make the js console error messages
much more useful and readable.</p>
</div>
<div class="paragraph">
<p>If you use <a href="https://github.com/gnl/ghostwheel">Ghostwheel</a> to spec and instrument your functions, then problems with
parameters and return values will have much better error messages (see also <a href="https://github.com/bhb/expound">expount</a>,
which ghostwheel will help configure).  Unfortunately the logging defaults in cljs will munge these nice error messages
into a very poorly wrapped string format.</p>
</div>
<div class="paragraph">
<p>The <code>com.fulcrologic.fulcro.algorithms.timbre-support</code> namespace includes functions that will make this better.</p>
</div>
<div class="paragraph">
<p>The recommended use of these functions is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make sure you&#8217;re using Binaryage devtools (on classpath. shadow-cljs will auto-add it when detected).</p>
</li>
<li>
<p>IMPORTANT: Enable custom formatters in console settings for Chrome. This will print cljs data as cljs (instead of raw js).</p>
</li>
<li>
<p>Make a development preload cljs file, and tell shadow-cljs to preload it.</p>
</li>
<li>
<p>In the preload file, add something like this:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">app.development-preload</span>
  (<span class="symbol">:require</span>
    [taoensso.timbre <span class="symbol">:as</span> log]
    [com.fulcrologic.fulcro.algorithms.timbre-support <span class="symbol">:refer</span> [console-appender prefix-output-fn]))

(log/set-level! <span class="symbol">:debug</span>)
(log/merge-config! {<span class="symbol">:output-fn</span> prefix-output-fn
                    <span class="symbol">:appenders</span> {<span class="symbol">:console</span> (console-appender)}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>and you&#8217;ll get much more readable error messages in the js console.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
when logging errors, be sure to log the exception first. This is documented in timbre, but easy to miss:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">try</span>
  <span class="keyword">..</span><span class="keyword">.</span>
  (<span class="keyword">catch</span> <span class="symbol">:default</span> ex
    (log/error ex <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_demos"><a class="anchor" href="#_demos"></a><a class="link" href="#_demos">28. Demos</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter includes some additional running demos with source that will give you insight on how to approach various problems. Remember
that the server latency can be set using the controls in the upper-right corner in the live HTML version, so you can
more easily watch state changes during server interactions.</p>
</div>
<div class="sect2">
<h3 id="_autocomplete"><a class="anchor" href="#_autocomplete"></a><a class="link" href="#_autocomplete">28.1. Autocomplete</a></h3>
<div class="paragraph">
<p>A fairly common desire in user interfaces is to try to help the user complete an input by querying the server
or possible completions. Like many of the demos, the UI for this example is intentionally very bare-bones
so that we can primarily concentrate on the data-flow that you&#8217;ll want to use to achieve the effect.</p>
</div>
<div class="paragraph">
<p>Typically you will want to trigger autocomplete on a time interval (e.g. using <code>goog.functions/debounce</code>)
or after some number of characters have been entered into the field. We&#8217;re going to implement it in the
following way:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The autocomplete query will trigger when the input has at least 2 characters of input.</p>
</li>
<li>
<p>The server will be asked for 10 suggestions, and will update on a debounced interval.</p>
</li>
<li>
<p>The autocomplete suggestion list will clear if length goes below 2</p>
</li>
<li>
<p>The user must use the mouse to select the desired completion (we&#8217;re not handling keyboard events)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_basic_operation"><a class="anchor" href="#_basic_operation"></a><a class="link" href="#_basic_operation">28.1.1. Basic Operation</a></h4>
<div class="paragraph">
<p>The basic idea is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make a component that has isolated state, so you can have more than one</p>
</li>
<li>
<p>Decide when to trigger the server query</p>
</li>
<li>
<p>Use load, but target it for a place that is not on the UI</p>
<div class="ulist">
<ul>
<li>
<p>Allows the UI to continue displaying old list while new load is in progress</p>
</li>
<li>
<p>Use a post-mutation to move the finished load into place</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_the_server_query"><a class="anchor" href="#_the_server_query"></a><a class="link" href="#_the_server_query">28.1.2. The Server Query</a></h4>
<div class="paragraph">
<p>For our server we have a simple list of all of the airports in the world that have 3-letter codes. Our
server just grabs 10 that match your search string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">airport-search</span> [s]
  (<span class="keyword">-&gt;&gt;</span> airports
       (<span class="keyword">filter</span> (<span class="keyword">fn</span> [i] (str/includes? (str/lower-case i) (str/lower-case s))))
       (<span class="keyword">take</span> <span class="integer">10</span>)
       <span class="keyword">vec</span>))

(defquery-root <span class="symbol">:autocomplete/airports</span>
  (value [env {<span class="symbol">:keys</span> [search]}] (airport-search search)))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_ui_and_post_mutation"><a class="anchor" href="#_the_ui_and_post_mutation"></a><a class="link" href="#_the_ui_and_post_mutation">28.1.3. The UI and Post Mutation</a></h4>
<div class="paragraph">
<p>We create a helper function so we don&#8217;t have to manually generate the ident for autocomplete wherever we need it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">autocomplete-ident</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Returns the ident for an autocomplete control. Can be passed a map of props, or a raw ID.</span><span class="delimiter">&quot;</span></span>
  [id-or-props]
  (<span class="keyword">if</span> (<span class="keyword">map?</span> id-or-props)
    [<span class="symbol">:autocomplete/id</span> (<span class="symbol">:db/id</span> id-or-props)]
    [<span class="symbol">:autocomplete/id</span> id-or-props]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use Google Closure&#8217;s debounce to generate a function that will not bash the server too hard. Load&#8217;s will run at most
once every 500ms. Notice that the server query itself is for airport suggestions, and we use the <code>:target</code> option
to place the results in our autocomplete&#8217;s field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">get-suggestions</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">A debounced function that will trigger a load of the server suggestions into a temporary locations and fire
   a post mutation when that is complete to move them into the main UI view.</span><span class="delimiter">&quot;</span></span>
  (<span class="keyword">letfn</span> [(load-suggestions [component new-value id]
            (df/load component <span class="symbol">:autocomplete/airports</span> <span class="predefined-constant">nil</span>
              {<span class="symbol">:params</span>               {<span class="symbol">:search</span> new-value}
               <span class="symbol">:post-mutation</span>        `populate-loaded-suggestions
               <span class="symbol">:post-mutation-params</span> {<span class="symbol">:id</span> id}
               <span class="symbol">:target</span>               (<span class="keyword">conj</span> (autocomplete-ident id) <span class="symbol">:autocomplete/loaded-suggestions</span>)}))]
    (gf/debounce load-suggestions <span class="integer">500</span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice when we trigger the load it goes into the auto-complete widget&#8217;s <code>:autocomplete/loaded-suggestions</code> field.
The UI renders the <code>:autocomplete/suggestions</code>. We do this so we can continue filtering the list as they type
independently of the load, but at the end of the load we need to update the suggestions. We do this by running a post
mutation (see the demo source).</p>
</div>
<div class="paragraph">
<p>The running demo (with source) is below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. <a id="Autocomplete"></a><a href="#_autocomplete">Autocomplete</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('autocomplete-demo')">Focus Inspector</button>
<div class="short narrow example" id="autocomplete-demo"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.autocomplete</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [book.demos.airports <span class="symbol">:refer</span> [airports]]
    [clojure.string <span class="symbol">:as</span> <span class="keyword">str</span>]
    [goog.functions <span class="symbol">:as</span> gf]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    ))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
(<span class="keyword">defn</span> <span class="function">airport-search</span> [s]
  (<span class="keyword">-&gt;&gt;</span> airports
    (<span class="keyword">filter</span> (<span class="keyword">fn</span> [i] (str/includes? (str/lower-case i) (str/lower-case s))))
    (<span class="keyword">take</span> <span class="integer">10</span>)
    <span class="keyword">vec</span>))

(pc/defresolver list-resolver [env params]
  {<span class="symbol">::pc/output</span> [<span class="symbol">:autocomplete/airports</span>]}
  (<span class="keyword">let</span> [search (<span class="keyword">get-in</span> env [<span class="symbol">:ast</span> <span class="symbol">:params</span> <span class="symbol">:search</span>])]
    {<span class="symbol">:autocomplete/airports</span> (airport-search search)}))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">defn</span> <span class="function">autocomplete-ident</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Returns the ident for an autocomplete control. Can be passed a map of props, or a raw ID.</span><span class="delimiter">&quot;</span></span>
  [id-or-props]
  (<span class="keyword">if</span> (<span class="keyword">map?</span> id-or-props)
    [<span class="symbol">:autocomplete/by-id</span> (<span class="symbol">:db/id</span> id-or-props)]
    [<span class="symbol">:autocomplete/by-id</span> id-or-props]))

(defsc CompletionList [this {<span class="symbol">:keys</span> [values onValueSelect]}]
  (dom/ul <span class="predefined-constant">nil</span>
    (<span class="keyword">map</span> (<span class="keyword">fn</span> [v]
           (dom/li {<span class="symbol">:key</span> v}
             (dom/a {<span class="symbol">:href</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">javascript:void(0)</span><span class="delimiter">&quot;</span></span> <span class="symbol">:onClick</span> #(onValueSelect v)} v))) values)))

(<span class="keyword">def</span> <span class="function">ui-completion-list</span> (comp/factory CompletionList))

(m/defmutation populate-loaded-suggestions
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Mutation: Autocomplete suggestions are loaded in a non-visible property to prevent flicker. This is
  used as a post mutation to move them to the active UI field so they appear.</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">let</span> [autocomplete-path (autocomplete-ident id)
          source-path       (<span class="keyword">conj</span> autocomplete-path <span class="symbol">:autocomplete/loaded-suggestions</span>)
          target-path       (<span class="keyword">conj</span> autocomplete-path <span class="symbol">:autocomplete/suggestions</span>)]
      (<span class="keyword">swap!</span> state <span class="keyword">assoc-in</span> target-path (<span class="keyword">get-in</span> @state source-path)))))

(<span class="keyword">def</span> <span class="function">get-suggestions</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">A debounced function that will trigger a load of the server suggestions into a temporary locations and fire
   a post mutation when that is complete to move them into the main UI view.</span><span class="delimiter">&quot;</span></span>
  (<span class="keyword">letfn</span> [(load-suggestions [<span class="keyword">comp</span> new-value id]
            (df/load! <span class="keyword">comp</span> <span class="symbol">:autocomplete/airports</span> <span class="predefined-constant">nil</span>
              {<span class="symbol">:params</span>               {<span class="symbol">:search</span> new-value}
               <span class="symbol">:marker</span>               <span class="predefined-constant">false</span>
               <span class="symbol">:post-mutation</span>        `populate-loaded-suggestions
               <span class="symbol">:post-mutation-params</span> {<span class="symbol">:id</span> id}
               <span class="symbol">:target</span>               (<span class="keyword">conj</span> (autocomplete-ident id) <span class="symbol">:autocomplete/loaded-suggestions</span>)}))]
    (gf/debounce load-suggestions <span class="integer">500</span>)))

(defsc Autocomplete [this {<span class="symbol">:keys</span> [db/id autocomplete/suggestions autocomplete/value] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span>         [<span class="symbol">:db/id</span>                                   <span class="comment">; the component's ID</span>
                   <span class="symbol">:autocomplete/loaded-suggestions</span>         <span class="comment">; A place to do the loading, so we can prevent flicker in the UI</span>
                   <span class="symbol">:autocomplete/suggestions</span>                <span class="comment">; the current completion suggestions</span>
                   <span class="symbol">:autocomplete/value</span>]                     <span class="comment">; the current user-entered value</span>
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] (autocomplete-ident props))
   <span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [id]}] {<span class="symbol">:db/id</span> id <span class="symbol">:autocomplete/suggestions</span> [] <span class="symbol">:autocomplete/value</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>})}
  (<span class="keyword">let</span> [field-id             (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">autocomplete-</span><span class="delimiter">&quot;</span></span> id)       <span class="comment">; for html label/input association</span>
        <span class="comment">;; server gives us a few, and as the user types we need to filter it further.</span>
        filtered-suggestions (<span class="keyword">when</span> (<span class="keyword">vector?</span> suggestions)
                               (<span class="keyword">filter</span> #(str/includes? (str/lower-case %) (str/lower-case value)) suggestions))
        <span class="comment">; We want to not show the list if they've chosen something valid</span>
        exact-match?         (<span class="keyword">and</span> (<span class="keyword">=</span> <span class="integer">1</span> (<span class="keyword">count</span> filtered-suggestions)) (<span class="keyword">=</span> value (<span class="keyword">first</span> filtered-suggestions)))
        <span class="comment">; When they select an item, we place it's value in the input</span>
        onSelect             (<span class="keyword">fn</span> [v] (m/set-string! this <span class="symbol">:autocomplete/value</span> <span class="symbol">:value</span> v))]
    (dom/div {<span class="symbol">:style</span> {<span class="symbol">:height</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">600px</span><span class="delimiter">&quot;</span></span>}}
      (dom/label {<span class="symbol">:htmlFor</span> field-id} <span class="string"><span class="delimiter">&quot;</span><span class="content">Airport: </span><span class="delimiter">&quot;</span></span>)
      (dom/input {<span class="symbol">:id</span>       field-id
                  <span class="symbol">:value</span>    value
                  <span class="symbol">:onChange</span> (<span class="keyword">fn</span> [evt]
                              (<span class="keyword">let</span> [new-value (<span class="keyword">..</span> evt -target -value)]
                                <span class="comment">; we avoid even looking for help until they've typed a couple of letters</span>
                                (<span class="keyword">if</span> (<span class="keyword">&gt;=</span> (<span class="keyword">.</span>-length new-value) <span class="integer">2</span>)
                                  (get-suggestions this new-value id)
                                  <span class="comment">; if they shrink the value too much, clear suggestions</span>
                                  (m/set-value! this <span class="symbol">:autocomplete/suggestions</span> []))
                                <span class="comment">; always update the input itself (controlled)</span>
                                (m/set-string! this <span class="symbol">:autocomplete/value</span> <span class="symbol">:value</span> new-value)))})
      <span class="comment">; show the completion list when it exists and isn't just exactly what they've chosen</span>
      (<span class="keyword">when</span> (<span class="keyword">and</span> (<span class="keyword">vector?</span> suggestions) (<span class="keyword">seq</span> suggestions) (<span class="keyword">not</span> exact-match?))
        (ui-completion-list {<span class="symbol">:values</span> filtered-suggestions <span class="symbol">:onValueSelect</span> onSelect})))))

(<span class="keyword">def</span> <span class="function">ui-autocomplete</span> (comp/factory Autocomplete))

(defsc AutocompleteRoot [this {<span class="symbol">:keys</span> [airport-input]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [p] {<span class="symbol">:airport-input</span> (comp/get-initial-state Autocomplete {<span class="symbol">:id</span> <span class="symbol">:airports</span>})})
   <span class="symbol">:query</span>         [{<span class="symbol">:airport-input</span> (comp/get-query Autocomplete)}]}
  (dom/div
    (dom/h4 <span class="string"><span class="delimiter">&quot;</span><span class="content">Airport Autocomplete</span><span class="delimiter">&quot;</span></span>)
    (ui-autocomplete airport-input)))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cascading_dropdowns"><a class="anchor" href="#_cascading_dropdowns"></a><a class="link" href="#_cascading_dropdowns">28.2. Cascading Dropdowns</a></h3>
<div class="paragraph">
<p>A common UI desire is to have dropdowns that cascade. I.e. a dropdown populates in response to a selection in
an earlier dropdown, like Make/Model for cars. This can be done quite easily.</p>
</div>
<div class="paragraph">
<p>The basic implementation is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Define dropdowns that can display the items</p>
</li>
<li>
<p>Don&#8217;t initialize the extra ones with items</p>
</li>
<li>
<p>When the first one is given a selection, load the next one</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A couple of simple implementation details are needed:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We&#8217;re using bootstrap dropdowns, and we need to know where they normalize their data. Looking at the data inspector
for the card makes this easy to see. For example, we can see that items are stored in the
<code>:bootstrap.dropdown/id</code> table, in the <code>:fulcro.ui.bootstrap3/items</code> column.</p>
</li>
<li>
<p>The IDs of the dropdowns (which we generate)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>On the server, we define the query handler as follows (remember you can affect the server latency with the server
controls to watch things happen):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defquery-root <span class="symbol">:models</span>
  (value [env {<span class="symbol">:keys</span> [make]}]
    (<span class="keyword">case</span> make
      <span class="symbol">:ford</span> [(bs/dropdown-item <span class="symbol">:escort</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Escort</span><span class="delimiter">&quot;</span></span>)
             (bs/dropdown-item <span class="symbol">:F-150</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">F-150</span><span class="delimiter">&quot;</span></span>)]
      <span class="symbol">:honda</span> [(bs/dropdown-item <span class="symbol">:civic</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Civic</span><span class="delimiter">&quot;</span></span>)
              (bs/dropdown-item <span class="symbol">:accort</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Accord</span><span class="delimiter">&quot;</span></span>)])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and we define a mutation for showing a "Loading&#8230;&#8203;" item in the dropdown that is loading as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defmutation show-list-loading
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Change the items of the dropdown with the given ID to a single item that indicates Loading...</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [id]}]
  (action [{<span class="symbol">:keys</span> [state]}]
    (<span class="keyword">swap!</span> state <span class="keyword">assoc-in</span>
      [<span class="symbol">:bootstrap.dropdown/id</span> id <span class="symbol">:fulcro.ui.bootstrap3/items</span>]
      [(<span class="keyword">assoc</span> (bs/dropdown-item <span class="symbol">:loading</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>) <span class="symbol">:fulcro.ui.bootstrap3/disabled?</span> <span class="predefined-constant">true</span>)])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main action is in the <code>onSelect</code> of the first dropdown, which just issues the transact to set the loading
visualization, followed by the remote load.</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. <a id="CascadingDropdowns"></a><a href="#CascadingDropdowns">Cascading Dropdowns</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('cascading-dropdowns')">Focus Inspector</button>
<div class="short narrow example" id="cascading-dropdowns"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.cascading-dropdowns</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.semantic-ui.modules.dropdown.ui-dropdown <span class="symbol">:as</span> dropdown]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [book.elements <span class="symbol">:as</span> ele]
    [taoensso.timbre <span class="symbol">:as</span> log]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; Server</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">defn</span> <span class="function">option</span> [value text]
  {<span class="symbol">:text</span> text <span class="symbol">:value</span> value})

(pc/defresolver model-resolver [env _]
  {<span class="symbol">::pc/output</span> [<span class="symbol">:models</span>]}
  (<span class="keyword">let</span> [make (<span class="keyword">-&gt;</span> env <span class="symbol">:ast</span> <span class="symbol">:params</span> <span class="symbol">:make</span>)]
    {<span class="symbol">:models</span> (<span class="keyword">case</span> make
               <span class="symbol">:ford</span> [(option <span class="symbol">:escort</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Escort</span><span class="delimiter">&quot;</span></span>) (option <span class="symbol">:F-150</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">F-150</span><span class="delimiter">&quot;</span></span>)]
               <span class="symbol">:honda</span> [(option <span class="symbol">:civic</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Civic</span><span class="delimiter">&quot;</span></span>) (option <span class="symbol">:accort</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Accord</span><span class="delimiter">&quot;</span></span>)])}))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; Client</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">defn</span> <span class="function">render-example</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Wrap an example in an iframe so we can load external CSS without affecting the containing page.</span><span class="delimiter">&quot;</span></span>
  [width height &amp; children]
  (ele/ui-iframe {<span class="symbol">:frameBorder</span> <span class="integer">0</span> <span class="symbol">:height</span> height <span class="symbol">:width</span> width}
    (<span class="keyword">apply</span> dom/div {<span class="symbol">:key</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">example-frame-key</span><span class="delimiter">&quot;</span></span>}
      (dom/style <span class="string"><span class="delimiter">&quot;</span><span class="content">.boxed {border: 1px solid black}</span><span class="delimiter">&quot;</span></span>)
      (dom/link {<span class="symbol">:rel</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">stylesheet</span><span class="delimiter">&quot;</span></span> <span class="symbol">:href</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css</span><span class="delimiter">&quot;</span></span>})
      children)))

(<span class="keyword">comment</span>

  (defmutation show-list-loading
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Change the items of the dropdown with the given ID to a single item that indicates Loading...</span><span class="delimiter">&quot;</span></span>
    [{<span class="symbol">:keys</span> [id]}]
    (action [{<span class="symbol">:keys</span> [state]}]
      (<span class="keyword">swap!</span> state <span class="keyword">assoc-in</span>
        [<span class="symbol">:bootstrap.dropdown/by-id</span> id <span class="symbol">:fulcro.ui.bootstrap3/items</span>]
        [(<span class="keyword">assoc</span> (bs/dropdown-item <span class="symbol">:loading</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>) <span class="symbol">:fulcro.ui.bootstrap3/disabled?</span> <span class="predefined-constant">true</span>)])))

  (defsc Root [this {<span class="symbol">:keys</span> [make-dropdown model-dropdown]}]
    {<span class="symbol">:initial-state</span> {}
     <span class="symbol">:query</span>         [<span class="comment">; initial state for two Bootstrap dropdowns</span>
                     {<span class="symbol">:make-dropdown</span> (comp/get-query bs/Dropdown)}
                     {<span class="symbol">:model-dropdown</span> (comp/get-query bs/Dropdown)}]}
    (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [<span class="symbol">:fulcro.ui.bootstrap3/items</span>]} model-dropdown]
      (render-example <span class="string"><span class="delimiter">&quot;</span><span class="content">200px</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">200px</span><span class="delimiter">&quot;</span></span>
        (dom/div
          (dropdown/ui-dropdown
            {<span class="symbol">:onSelect</span>  (<span class="keyword">fn</span> [item]
                          <span class="comment">; Update the state of the model dropdown to show a loading indicator</span>
                          (comp/transact! this `[(show-list-loading {<span class="symbol">:id</span> <span class="symbol">:model</span>})])
                          <span class="comment">; Issue the remote load. Note the use of DropdownItem as the query, so we get proper normalization</span>
                          <span class="comment">; The targeting is used to make sure we hit the correct dropdown's items</span>
                          (df/load this <span class="symbol">:models</span> bs/DropdownItem {<span class="symbol">:target</span> [<span class="symbol">:bootstrap.dropdown/by-id</span> <span class="symbol">:model</span> <span class="symbol">:fulcro.ui.bootstrap3/items</span>]
                                                                 <span class="comment">; don't overwrite state with loading markers...we're doing that manually to structure it specially</span>
                                                                 <span class="symbol">:marker</span> <span class="predefined-constant">false</span>
                                                                 <span class="comment">; A server parameter on the query</span>
                                                                 <span class="symbol">:params</span> {<span class="symbol">:make</span> item}}))
             <span class="symbol">:stateful?</span> <span class="predefined-constant">true</span>})
          (dropdown/ui-dropdown model-dropdown
            {<span class="symbol">:onSelect</span>  (<span class="keyword">fn</span> [item] (log/info item))
             <span class="symbol">:stateful?</span> <span class="predefined-constant">true</span>}))))))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loading_due_to_a_ui_event"><a class="anchor" href="#_loading_due_to_a_ui_event"></a><a class="link" href="#_loading_due_to_a_ui_event">28.3. Loading due to a UI Event</a></h3>
<div class="paragraph">
<p>Tabbed interfaces typically use a UI Router (which can be further integrated into HTML5 routing as a routing tree). See
<a href="https://youtu.be/j-_itpXEo6w?list=PLVi9lDx-4C_T_gsmBQ_2gztvk6h_Usw6R">this YouTube video</a> for more details.</p>
</div>
<div class="paragraph">
<p>This example not only shows the basic construction of an interface that allows content (and query) to be switched, it
also demonstrates how one goes about triggering loads of data that some screen might need.</p>
</div>
<div class="paragraph">
<p>If you look at the source for the root component you&#8217;ll see two buttons with transactions on their click handlers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Root [this {<span class="symbol">:keys</span> [current-tab] <span class="symbol">:as</span> props}]
  <span class="comment">; Construction MUST compose to root, just like the query. The resulting tree will automatically be normalized into the</span>
  <span class="comment">; app state graph database.</span>
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:ui/react-key</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">initial</span><span class="delimiter">&quot;</span></span> <span class="symbol">:current-tab</span> (comp/get-initial-state UITabs <span class="predefined-constant">nil</span>)})
   <span class="symbol">:query</span>         [{<span class="symbol">:current-tab</span> (comp/get-query UITabs)}]}
  (dom/div
    <span class="comment">; The selection of tabs can be rendered in a child, but the transact! must be done from the parent (to</span>
    <span class="comment">; ensure proper re-render of the tab body). See comp/computed for passing callbacks.</span>
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(choose-tab {<span class="symbol">:tab</span> <span class="symbol">:main</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Main</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(choose-tab {<span class="symbol">:tab</span> <span class="symbol">:settings</span>})
                                                      <span class="comment">; extra mutation: sample of what you would do to lazy load the tab content</span>
                                                      (lazy-load-tab {<span class="symbol">:tab</span> <span class="symbol">:settings</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Settings</span><span class="delimiter">&quot;</span></span>)
    (ui-tabs current-tab)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first is simple enough: run a mutation that chooses which tab to show. The routing library includes a helper function
for building that, so the mutation just looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(m/defmutation choose-tab [{<span class="symbol">:keys</span> [tab]}]
  (action [{<span class="symbol">:keys</span> [state]}] (<span class="keyword">swap!</span> state r/set-route* <span class="symbol">:ui-router</span> [tab <span class="symbol">:tab</span>])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The transaction to go to the settings tab is more interesting. It switches tabs but also runs another mutation to
load data needed for that screen. The intention is to just load it if it is missing. That mutation looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">missing-tab?</span> [state tab] (<span class="keyword">empty?</span> (<span class="keyword">-&gt;</span> @state <span class="symbol">:settings</span> <span class="symbol">:tab</span> <span class="symbol">:settings</span>)))

(m/defmutation lazy-load-tab [{<span class="symbol">:keys</span> [tab]}]
  (action [{<span class="symbol">:keys</span> [state] <span class="symbol">:as</span> env}]
    (<span class="keyword">when</span> (missing-tab? state tab)
      (df/load-action state <span class="symbol">:all-settings</span> SomeSetting
        {<span class="symbol">:target</span>  [<span class="symbol">:settings</span> <span class="symbol">:tab</span> <span class="symbol">:settings</span>]
         <span class="symbol">:refresh</span> [<span class="symbol">:settings</span>]})))
  (remote [{<span class="symbol">:keys</span> [state] <span class="symbol">:as</span> env}]
    (<span class="keyword">when</span> (missing-tab? state tab) (df/remote-load env))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fairly standard fare at this point: Look at the database to see if it has what you want, and if not trigger a load
with <code>df/load-action</code> (on the action side) and <code>df/remote-load</code> on the remote.</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. <a id="LoadingInResponseToUIRouting"></a><a href="#LoadingInResponseToUIRouting">Loading In Response To UI Routing</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('loading-in-response-to-UI-routing')">Focus Inspector</button>
<div class="short narrow example" id="loading-in-response-to-UI-routing"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.loading-in-response-to-UI-routing</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.routing.legacy-ui-routers <span class="symbol">:as</span> r]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(pc/defresolver all-settings-resolver [env input]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:all-settings</span> [<span class="symbol">:id</span> <span class="symbol">:value</span>]}]}
  {<span class="symbol">:all-settings</span> [{<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:value</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Gorgon</span><span class="delimiter">&quot;</span></span>}
                  {<span class="symbol">:id</span> <span class="integer">2</span> <span class="symbol">:value</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Thraser</span><span class="delimiter">&quot;</span></span>}
                  {<span class="symbol">:id</span> <span class="integer">3</span> <span class="symbol">:value</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Under</span><span class="delimiter">&quot;</span></span>}]})

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(defsc SomeSetting [this {<span class="symbol">:keys</span> [id value]}]
  {<span class="symbol">:query</span> [<span class="symbol">:ui/fetch-state</span> <span class="symbol">:id</span> <span class="symbol">:value</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:setting/by-id</span> <span class="symbol">:id</span>]}
  (dom/p <span class="predefined-constant">nil</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Setting </span><span class="delimiter">&quot;</span></span> id <span class="string"><span class="delimiter">&quot;</span><span class="content"> from server has value: </span><span class="delimiter">&quot;</span></span> value))

(<span class="keyword">def</span> <span class="function">ui-setting</span> (comp/factory SomeSetting {<span class="symbol">:keyfn</span> <span class="symbol">:id</span>}))

(defsc SettingsTab [this {<span class="symbol">:keys</span> [settings-content settings]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:kind</span>             <span class="symbol">:settings</span>
                   <span class="symbol">:settings-content</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Settings Tab</span><span class="delimiter">&quot;</span></span>
                   <span class="symbol">:settings</span>         []}
   <span class="comment">; This query uses a &quot;link&quot;...a special ident with '_ as the ID. This indicates the item is at the database</span>
   <span class="comment">; root, not inside of the &quot;settings&quot; database object. This is not needed as a matter of course...it is only used</span>
   <span class="comment">; for convenience (since it is trivial to load something into the root of the database)</span>
   <span class="symbol">:query</span>         [<span class="symbol">:kind</span> <span class="symbol">:settings-content</span> {<span class="symbol">:settings</span> (comp/get-query SomeSetting)}]}
  (dom/div <span class="predefined-constant">nil</span>
    settings-content
    (<span class="keyword">if</span> (<span class="keyword">seq</span> settings)
      (<span class="keyword">map</span> ui-setting settings)
      (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">No settings.</span><span class="delimiter">&quot;</span></span>))))

(defsc MainTab [this {<span class="symbol">:keys</span> [main-content]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:kind</span> <span class="symbol">:main</span> <span class="symbol">:main-content</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Main Tab</span><span class="delimiter">&quot;</span></span>}
   <span class="symbol">:query</span>         [<span class="symbol">:kind</span> <span class="symbol">:main-content</span>]}
  (dom/div <span class="predefined-constant">nil</span> main-content))

(r/defsc-router UITabs [this props]
  {<span class="symbol">:router-id</span>      <span class="symbol">:ui-router</span>
   <span class="symbol">:ident</span>          (<span class="keyword">fn</span> [] [(<span class="symbol">:kind</span> props) <span class="symbol">:tab</span>])
   <span class="symbol">:default-route</span>  MainTab
   <span class="symbol">:router-targets</span> {<span class="symbol">:main</span>     MainTab
                    <span class="symbol">:settings</span> SettingsTab}})

(<span class="keyword">def</span> <span class="function">ui-tabs</span> (comp/factory UITabs))

(m/defmutation choose-tab [{<span class="symbol">:keys</span> [tab]}]
  (action [{<span class="symbol">:keys</span> [state]}] (<span class="keyword">swap!</span> state r/set-route <span class="symbol">:ui-router</span> [tab <span class="symbol">:tab</span>])))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; LAZY LOADING TAB CONTENT</span>
<span class="comment">;; This is the shape of what to do. We define a method that can examine the</span>
<span class="comment">;; state to decide if we want to trigger a load. Then we define a mutation</span>
<span class="comment">;; that the UI can call during transact (see the transact! call for Settings on Root in ui.cljs).</span>
<span class="comment">;; The mutation itself (app/lazy-load-tab) below uses a data-fetch helper function to</span>
<span class="comment">;; set :remote to the right thing, and can then give one or more load-data-action's to</span>
<span class="comment">;; indicate what should actually be retrieved. The server implementation is trivial in</span>
<span class="comment">;; this case. See api.clj.</span>

<span class="comment">;; When to consider the data missing? Check the state and find out.</span>
(<span class="keyword">defn</span> <span class="function">missing-tab?</span> [state tab]
  (<span class="keyword">let</span> [settings (<span class="keyword">-&gt;</span> @state <span class="symbol">:settings</span> <span class="symbol">:tab</span> <span class="symbol">:settings</span>)]
    (<span class="keyword">or</span> (<span class="keyword">not</span> (<span class="keyword">vector?</span> settings))
      (<span class="keyword">and</span> (<span class="keyword">vector?</span> settings) (<span class="keyword">empty?</span> settings)))))

(m/defmutation lazy-load-tab [{<span class="symbol">:keys</span> [tab]}]
  (action [{<span class="symbol">:keys</span> [app state] <span class="symbol">:as</span> env}]
    <span class="comment">; Specify what you want to load as one or more calls to load-action (each call adds an item to load):</span>
    (<span class="keyword">when</span> (missing-tab? state tab)
      (df/load! app <span class="symbol">:all-settings</span> SomeSetting
        {<span class="symbol">:target</span>  [<span class="symbol">:settings</span> <span class="symbol">:tab</span> <span class="symbol">:settings</span>]
         <span class="symbol">:refresh</span> [<span class="symbol">:settings</span>]}))))

(defsc Root [this {<span class="symbol">:keys</span> [current-tab] <span class="symbol">:as</span> props}]
  <span class="comment">; Construction MUST compose to root, just like the query. The resulting tree will automatically be normalized into the</span>
  <span class="comment">; app state graph database.</span>
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:current-tab</span> (comp/get-initial-state UITabs <span class="predefined-constant">nil</span>)})
   <span class="symbol">:query</span>         [{<span class="symbol">:current-tab</span> (comp/get-query UITabs)}]}
  (dom/div
    <span class="comment">; The selection of tabs can be rendered in a child, but the transact! must be done from the parent (to</span>
    <span class="comment">; ensure proper re-render of the tab body). See comp/computed for passing callbacks.</span>
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(choose-tab {<span class="symbol">:tab</span> <span class="symbol">:main</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Main</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(choose-tab {<span class="symbol">:tab</span> <span class="symbol">:settings</span>})
                                                  <span class="comment">; extra mutation: sample of what you would do to lazy load the tab content</span>
                                                  (lazy-load-tab {<span class="symbol">:tab</span> <span class="symbol">:settings</span>})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Settings</span><span class="delimiter">&quot;</span></span>)
    (ui-tabs current-tab)))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_paginating_large_lists"><a class="anchor" href="#_paginating_large_lists"></a><a class="link" href="#_paginating_large_lists">28.4. Paginating Large Lists</a></h3>
<div class="paragraph">
<p>This demo is showing a (dynamically generated) list of items. The server can generate any number of them, so you
can page ahead as many times as you like. Each page is dynamically loaded if and only if the browser does not already
have it. The demo also ensures you cannot run out of browser memory by removing items and pages that are more than 4 steps away
from your current position. You can demostrate this by moving ahead by more than 4 pages, then page back 5. You should
see a reload of that early page when you go back to it.</p>
</div>
<div class="paragraph">
<p>The UI of this example is a great example of how a complex application behavior remains very very simple at the UI
layer with Fulcro.</p>
</div>
<div class="paragraph">
<p>We represent the list items as you might expect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc ListItem [this {<span class="symbol">:keys</span> [item/id]}]
  {<span class="symbol">:query</span> [<span class="symbol">:item/id</span> <span class="symbol">:ui/fetch-state</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:items/id</span> <span class="symbol">:item/id</span>]}
  (dom/li (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Item </span><span class="delimiter">&quot;</span></span> id)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We then generate a component to represent a page of them. This allows us to associate the items on a page with
a particular component, which makes tracking the page number and items on that page much simpler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc ListPage [this {<span class="symbol">:keys</span> [page/number page/items]}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:page/number</span> <span class="integer">1</span> <span class="symbol">:page/items</span> []}
   <span class="symbol">:query</span>         [<span class="symbol">:page/number</span> {<span class="symbol">:page/items</span> (comp/get-query ListItem)}]
   <span class="symbol">:ident</span>         [<span class="symbol">:page/by-number</span> <span class="symbol">:page/number</span>]}
  (dom/div
    (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">Page number </span><span class="delimiter">&quot;</span></span> number)
    (df/lazily-loaded #(dom/ul (mapv ui-list-item %)) items)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we build a component named <code>LargeList</code> to control which page we&#8217;re on. This component does nothing more than
show the current page, and transact mutations that ask for the specific page. Not that we could easily add a control
to jump to any page, since the mutation itself is <code>goto-page</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc LargeList [this {<span class="symbol">:keys</span> [list/current-page]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:list/current-page</span> (comp/get-initial-state ListPage {})})
   <span class="symbol">:query</span>         [{<span class="symbol">:list/current-page</span> (comp/get-query ListPage)}]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:list/id</span> <span class="integer">1</span>])}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [page/number]} current-page]
    (dom/div
      (dom/button {<span class="symbol">:disabled</span> (<span class="keyword">=</span> <span class="integer">1</span> number)
        <span class="symbol">:onClick</span> #(comp/transact! this `[(goto-page {<span class="symbol">:page-number</span> ~(<span class="keyword">dec</span> number)})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Prior Page</span><span class="delimiter">&quot;</span></span>)
      (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(goto-page {<span class="symbol">:page-number</span> ~(<span class="keyword">inc</span> number)})])}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Next Page</span><span class="delimiter">&quot;</span></span>)
      (ui-list-page current-page))))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_the_goto_page_mutation"><a class="anchor" href="#_the_goto_page_mutation"></a><a class="link" href="#_the_goto_page_mutation">28.4.1. The goto-page Mutation</a></h4>
<div class="paragraph">
<p>So you can infer that all of the complexity of this application is hidden behind a single mutation: <code>goto-page</code>. This
mutation is a complete abstraction to the UI, and the UI designer would need to very little about it.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve decided that this mutation will:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensure the given page exists in app state (with its page number)</p>
</li>
<li>
<p>Check to see if the page has items</p>
<div class="ulist">
<ul>
<li>
<p>If not: it will trigger a server-side query for those items</p>
</li>
</ul>
</div>
</li>
<li>
<p>Update the `LargeList&#8217;s current page to point to the correct page</p>
</li>
<li>
<p>Garbage collect pages/items in the app database that are 5 or more pages away from the current position.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The mutation itself looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(m/defmutation goto-page [{<span class="symbol">:keys</span> [page-number]}]
  (action [{<span class="symbol">:keys</span> [state] <span class="symbol">:as</span> env}]
    (load-if-missing env page-number)
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                   (<span class="keyword">-&gt;</span> s
                     (init-page page-number)
                     (set-current-page page-number)
                     (gc-distant-pages page-number)))))
  (remote [{<span class="symbol">:keys</span> [state] <span class="symbol">:as</span> env}]
    (<span class="keyword">when</span> (<span class="keyword">not</span> (page-exists? @state page-number))
      (df/remote-load env)))) <span class="comment">; trigger load queue processing</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s break this down.</p>
</div>
<div class="sect4">
<h5 id="_the_action"><a class="anchor" href="#_the_action"></a><a class="link" href="#_the_action">The Action</a></h5>
<div class="paragraph">
<p>The <code>load-if-missing</code> function is composed of the following bits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">page-exists?</span> [state-map page-number]
  (<span class="keyword">let</span> [page-items (<span class="keyword">get-in</span> state-map [<span class="symbol">:page/by-number</span> page-number <span class="symbol">:page/items</span>])]
    (<span class="keyword">boolean</span> (<span class="keyword">seq</span> page-items))))

(<span class="keyword">defn</span> <span class="function">load-if-missing</span> [{<span class="symbol">:keys</span> [reconciler state] <span class="symbol">:as</span> env} page-number]
  (<span class="keyword">when-not</span> (page-exists? @state page-number)
    (<span class="keyword">let</span> [start (<span class="keyword">inc</span> (<span class="keyword">*</span> <span class="integer">10</span> (<span class="keyword">dec</span> page-number)))
          end   (<span class="keyword">+</span> start <span class="integer">9</span>)]
      (df/load reconciler <span class="symbol">:paginate/items</span> ListItem {<span class="symbol">:params</span> {<span class="symbol">:start</span> start <span class="symbol">:end</span> end}
                                                    <span class="symbol">:target</span> [<span class="symbol">:page/by-number</span> page-number <span class="symbol">:page/items</span>]}))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and you can see that it just detects if the page is missing its items. If the items are missing, it loads them.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_server_side_code"><a class="anchor" href="#_the_server_side_code"></a><a class="link" href="#_the_server_side_code">28.4.2. The Server-Side Code</a></h4>
<div class="paragraph">
<p>The server in this example is trivial. It is just a query that generates items on the fly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defmethod</span> <span class="function">api/server-read</span> <span class="symbol">:paginate/items</span> [env k {<span class="symbol">:keys</span> [start end]}]
  (<span class="keyword">when</span> (<span class="keyword">&gt;</span> <span class="integer">1000</span> (<span class="keyword">-</span> end start)) <span class="comment">; ensure the server doesn't die if the client does something like use NaN for end</span>
    {<span class="symbol">:value</span> (<span class="keyword">vec</span> (<span class="keyword">for</span> [id (<span class="keyword">range</span> start end)]
                   {<span class="symbol">:item/id</span> id}))}))</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 46. <a id="PaginatingListsFromServer"></a><a href="#PaginatingListsFromServer">Paginating Lists From Server</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('paginating-large-lists-from-server')">Focus Inspector</button>
<div class="short narrow example" id="paginating-large-lists-from-server"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.paginating-large-lists-from-server</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.mutations <span class="symbol">:as</span> m]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span>]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(pc/defresolver infinite-pages [env input]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:paginate/items</span> [<span class="symbol">:item/id</span>]}]}
  (<span class="keyword">let</span> [params (<span class="keyword">-&gt;</span> env <span class="symbol">:ast</span> <span class="symbol">:params</span>)
        {<span class="symbol">:keys</span> [start end]} params]
    {<span class="symbol">:paginate/items</span> (mapv (<span class="keyword">fn</span> [id] {<span class="symbol">:item/id</span> id}) (<span class="keyword">range</span> start end))}))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">defn</span> <span class="function">page-exists?</span> [state-map page-number]
  (<span class="keyword">let</span> [page-items (<span class="keyword">get-in</span> state-map [<span class="symbol">:page/by-number</span> page-number <span class="symbol">:page/items</span>])]
    (<span class="keyword">boolean</span> (<span class="keyword">seq</span> page-items))))

(<span class="keyword">defn</span> <span class="function">init-page</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">An idempotent init function that just ensures enough of a page exists to make the UI work.
   Doesn't affect the items.</span><span class="delimiter">&quot;</span></span>
  [state-map page-number]
  (<span class="keyword">assoc-in</span> state-map [<span class="symbol">:page/by-number</span> page-number <span class="symbol">:page/number</span>] page-number))

(<span class="keyword">defn</span> <span class="function">set-current-page</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Point the current list's current page to the correct page entity in the db (via ident).</span><span class="delimiter">&quot;</span></span>
  [state-map page-number]
  (<span class="keyword">assoc-in</span> state-map [<span class="symbol">:list/by-id</span> <span class="integer">1</span> <span class="symbol">:list/current-page</span>] [<span class="symbol">:page/by-number</span> page-number]))

(<span class="keyword">defn</span> <span class="function">clear-item</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Removes the given item from the item table.</span><span class="delimiter">&quot;</span></span>
  [state-map item-id] (update state-map <span class="symbol">:items/by-id</span> <span class="keyword">dissoc</span> item-id))

(<span class="keyword">defn</span> <span class="function">clear-page</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Clear the given page (and associated items) from the app database.</span><span class="delimiter">&quot;</span></span>
  [state-map page-number]
  (<span class="keyword">let</span> [page        (<span class="keyword">get-in</span> state-map [<span class="symbol">:page/by-number</span> page-number])
        item-idents (<span class="symbol">:page/items</span> page)
        item-ids    (<span class="keyword">map</span> <span class="keyword">second</span> item-idents)]
    (as-&gt; state-map s
      (update s <span class="symbol">:page/by-number</span> <span class="keyword">dissoc</span> page-number)
      (<span class="keyword">reduce</span> (<span class="keyword">fn</span> [acc id] (update acc <span class="symbol">:items/by-id</span> <span class="keyword">dissoc</span> id)) s item-ids))))

(<span class="keyword">defn</span> <span class="function">gc-distant-pages</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Clears loaded items from pages 5 or more steps away from the given page number.</span><span class="delimiter">&quot;</span></span>
  [state-map page-number]
  (<span class="keyword">reduce</span> (<span class="keyword">fn</span> [s n]
            (<span class="keyword">if</span> (<span class="keyword">&lt;</span> <span class="integer">4</span> (Math/abs (<span class="keyword">-</span> page-number n)))
              (clear-page s n)
              s)) state-map (<span class="keyword">keys</span> (<span class="symbol">:page/by-number</span> state-map))))

(<span class="keyword">declare</span> <span class="function">ListItem</span>)

(<span class="keyword">defn</span> <span class="function">load-if-missing</span> [{<span class="symbol">:keys</span> [app state] <span class="symbol">:as</span> env} page-number]
  (<span class="keyword">when-not</span> (page-exists? @state page-number)
    (<span class="keyword">let</span> [start (<span class="keyword">inc</span> (<span class="keyword">*</span> <span class="integer">10</span> (<span class="keyword">dec</span> page-number)))
          end   (<span class="keyword">+</span> start <span class="integer">9</span>)]
      (df/load! app <span class="symbol">:paginate/items</span> ListItem {<span class="symbol">:params</span> {<span class="symbol">:start</span> start <span class="symbol">:end</span> end}
                                              <span class="symbol">:marker</span> <span class="symbol">:page</span>
                                              <span class="symbol">:target</span> [<span class="symbol">:page/by-number</span> page-number <span class="symbol">:page/items</span>]}))))

(m/defmutation goto-page [{<span class="symbol">:keys</span> [page-number]}]
  (action [{<span class="symbol">:keys</span> [state] <span class="symbol">:as</span> env}]
    (load-if-missing env page-number)
    (<span class="keyword">swap!</span> state (<span class="keyword">fn</span> [s]
                   (<span class="keyword">-&gt;</span> s
                     (init-page page-number)
                     (set-current-page page-number)
                     (gc-distant-pages page-number))))))

(defsc ListItem [this {<span class="symbol">:keys</span> [item/id]}]
  {<span class="symbol">:query</span> [<span class="symbol">:item/id</span> <span class="symbol">:ui/fetch-state</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:items/by-id</span> <span class="symbol">:item/id</span>]}
  (dom/li (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Item </span><span class="delimiter">&quot;</span></span> id)))

(<span class="keyword">def</span> <span class="function">ui-list-item</span> (comp/factory ListItem {<span class="symbol">:keyfn</span> <span class="symbol">:item/id</span>}))

(defsc ListPage [this {<span class="symbol">:keys</span> [page/number page/items] <span class="symbol">:as</span> props}]
  {<span class="symbol">:initial-state</span> {<span class="symbol">:page/number</span> <span class="integer">1</span> <span class="symbol">:page/items</span> []}
   <span class="symbol">:query</span>         [<span class="symbol">:page/number</span> {<span class="symbol">:page/items</span> (comp/get-query ListItem)}
                   [df/marker-table <span class="symbol">:page</span>]]
   <span class="symbol">:ident</span>         [<span class="symbol">:page/by-number</span> <span class="symbol">:page/number</span>]}
  (<span class="keyword">let</span> [status (<span class="keyword">get</span> props [df/marker-table <span class="symbol">:page</span>])]
    (dom/div
      (dom/p <span class="string"><span class="delimiter">&quot;</span><span class="content">Page number </span><span class="delimiter">&quot;</span></span> number)
      (<span class="keyword">if</span> (df/loading? status)
        (dom/div <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>)
        (dom/ul (mapv ui-list-item items))))))

(<span class="keyword">def</span> <span class="function">ui-list-page</span> (comp/factory ListPage {<span class="symbol">:keyfn</span> <span class="symbol">:page/number</span>}))

(defsc LargeList [this {<span class="symbol">:keys</span> [list/current-page]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:list/current-page</span> (comp/get-initial-state ListPage {})})
   <span class="symbol">:query</span>         [{<span class="symbol">:list/current-page</span> (comp/get-query ListPage)}]
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">:list/by-id</span> <span class="integer">1</span>])}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [page/number]} current-page]
    (dom/div
      (dom/button {<span class="symbol">:disabled</span> (<span class="keyword">=</span> <span class="integer">1</span> number) <span class="symbol">:onClick</span> #(comp/transact! this `[(goto-page {<span class="symbol">:page-number</span> ~(<span class="keyword">dec</span> number)})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Prior Page</span><span class="delimiter">&quot;</span></span>)
      (dom/button {<span class="symbol">:onClick</span> #(comp/transact! this `[(goto-page {<span class="symbol">:page-number</span> ~(<span class="keyword">inc</span> number)})])} <span class="string"><span class="delimiter">&quot;</span><span class="content">Next Page</span><span class="delimiter">&quot;</span></span>)
      (ui-list-page current-page))))

(<span class="keyword">def</span> <span class="function">ui-list</span> (comp/factory LargeList))

(defsc Root [this {<span class="symbol">:keys</span> [pagination/list]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [params] {<span class="symbol">:pagination/list</span> (comp/get-initial-state LargeList {})})
   <span class="symbol">:query</span>         [{<span class="symbol">:pagination/list</span> (comp/get-query LargeList)}]}
  (dom/div (ui-list <span class="keyword">list</span>)))

(<span class="keyword">defn</span> <span class="function">initialize</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">To be used as started-callback. Load the first page.</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">:keys</span> [app]}]
  (comp/transact! app `[(goto-page {<span class="symbol">:page-number</span> <span class="integer">1</span>})]))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ui_query_security"><a class="anchor" href="#_ui_query_security"></a><a class="link" href="#_ui_query_security">28.5. UI Query Security</a></h3>
<div class="paragraph">
<p>If you examine any UI query it will have a tree form. That is the nature of EQL. It
is also the nature of UI&#8217;s. For any such query, you can imagine it as a graph walk:</p>
</div>
<div class="paragraph">
<p>Take this query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">:a</span> {<span class="symbol">:join1</span> [<span class="symbol">:b</span> {<span class="symbol">:join2</span> [<span class="symbol">:c</span> <span class="symbol">:d</span>]}]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you think about how this looks in the server: each join walks from one table (or entity) to another through
some kind of (forward or reverse) reference.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">   QUERY PART                            IMPLIED DATABASE graph
[<span class="symbol">:a</span> {<span class="symbol">:join1</span>                           { <span class="symbol">:a</span> <span class="integer">6</span> <span class="symbol">:join1</span> [<span class="symbol">:tableX</span> id1] }
                                                      \
                                                       \
                                                        \
        [<span class="symbol">:b</span> {<span class="symbol">:join2</span>                       <span class="symbol">:tableX</span> { id1 { <span class="symbol">:id</span> id1 <span class="symbol">:join2</span> [<span class="symbol">:tableY</span> id2]
                                                                            <span class="keyword">/</span>
                                                                           <span class="keyword">/</span>
                                                                         <span class="keyword">/</span>
              [<span class="symbol">:c</span> <span class="symbol">:d</span>]}]}]                <span class="symbol">:tableY</span> { id2 { <span class="symbol">:id</span> id2 <span class="symbol">:c</span> <span class="integer">4</span> <span class="symbol">:d</span> <span class="integer">5</span> }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One idea that works pretty well for us is based on this realization: There is a starting point of this walk (e.g. I
want to load a person), and the top-level detail <strong>must</strong> be specified (or implied at least) by the incoming query
(load person 5, load all persons in my account, etc.).</p>
</div>
<div class="paragraph">
<p>A tradition logic check always needs to be run on
this object to see if it is OK for the user to <strong>start</strong> reading the database there.</p>
</div>
<div class="paragraph">
<p>The problem that remains is that there is a graph query that could conceivably walk to things in the database that
should not be readable. So, to ensure security we need to verify that the user:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>is allowed to read the specific <strong>data</strong> at the node of the graph (e.g. :a, :c, and :d)</p>
</li>
<li>
<p>is allowed to <strong>walk</strong> across a given <strong>reference</strong> at that node of the graph.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>However, since both of those cases are essentially the same in practice (can the user read the given property), one
possible algorithm simplifies to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a whitelist of keywords that are allowed to be read by the query in question. This can be a one-time
declarative configuration, or something dynamic based on user rights.</p>
</li>
<li>
<p>Verify the user is allowed to read the "top" object. If not, disallow the query.</p>
</li>
<li>
<p>Recursively gather up all keywords from the query as a set</p>
</li>
<li>
<p>Find the set difference of the whitelist and the query keywords.</p>
</li>
<li>
<p>If the difference is not empty, refuse to run the query</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_the_server_hooks"><a class="anchor" href="#_the_server_hooks"></a><a class="link" href="#_the_server_hooks">28.5.1. The Server Hooks</a></h4>
<div class="paragraph">
<p>This is one of the few examples that would add extra code to the server itself (we&#8217;re still simulating it for this
book). This example&#8217;s auth mechanisms would be set up as components and a parser injection there. The relevant
code is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defrecord</span> <span class="class">Authentication</span> [handler]
  c/Lifecycle
  (start [this]
    (log/info <span class="string"><span class="delimiter">&quot;</span><span class="content">Hooking into pre-processing to add user info</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">let</span> [old-pre-hook (h/get-pre-hook handler)
          new-hook     (<span class="keyword">fn</span> [ring-handler] (<span class="keyword">fn</span> [req] ((old-pre-hook ring-handler) (<span class="keyword">assoc</span> req <span class="symbol">:user</span> {<span class="symbol">:username</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Tony</span><span class="delimiter">&quot;</span></span>}))))]
      (h/set-pre-hook! handler new-hook))
    this)
  (stop [this] this))

(<span class="keyword">defn</span> <span class="function">make-authentication</span> []
  (c/using (map-&gt;Authentication {}) [<span class="symbol">:handler</span>]))

(<span class="keyword">defprotocol</span> <span class="class">Auth</span>
  (can-access-entity? [this user <span class="keyword">key</span> entityid] <span class="string"><span class="delimiter">&quot;</span><span class="content">Check if the given user is allowed to access the entity designated by the given key and entity id</span><span class="delimiter">&quot;</span></span>)
  (authorized-query? [this user top-key query] <span class="string"><span class="delimiter">&quot;</span><span class="content">Check if the given user is allowed to access all of the data in the query that starts at the given join key</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">defrecord</span> <span class="class">Authorizer</span> []
  c/Lifecycle
  (start [this] this)
  (stop [this] this)
  Auth
  (can-access-entity? [this user <span class="keyword">key</span> entityid] (authorized-root-entity? user <span class="keyword">key</span> entityid))
  (authorized-query? [this user top-key query] (is-authorized-query? query top-key)))

(<span class="keyword">defn</span> <span class="function">make-authorizer</span> [] (map-&gt;Authorizer {}))

(<span class="keyword">defn</span> <span class="function">make-system</span> []
  (core/make-fulcro-server
    <span class="symbol">:config-path</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">config/demos.edn</span><span class="delimiter">&quot;</span></span>
    <span class="symbol">:parser</span> (comp/parser {<span class="symbol">:read</span> logging-query <span class="symbol">:mutate</span> logging-mutate})
    <span class="symbol">:parser-injections</span> #{<span class="symbol">:authentication</span>}
    <span class="symbol">:components</span> {
                 <span class="comment">; Server security demo: This puts itself into the Ring pipeline to add user info to the request</span>
                 <span class="symbol">:auth-hook</span>      (server-security/make-authentication)
                 <span class="comment">; This is here as a component so it can be injected into the parser env for processing security</span>
                 <span class="symbol">:authentication</span> (server-security/make-authorizer)}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This logic is basically hacked in to the live example to give you an idea of how
it looks.</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. <a id="QuerySecurity"></a><a href="#QuerySecurity">Query Security</a></div>
<div class="content">
<button class="inspector" onClick="book.main.focus('server-query-security')">Focus Inspector</button>
<div class="short narrow example" id="server-query-security"></div>
<br/>
<div class="listingblock source">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.server-query-security</span>
  (<span class="symbol">:require</span>
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]
    [com.fulcrologic.fulcro.mutations <span class="symbol">:refer</span> [defmutation]]
    [clojure.set <span class="symbol">:as</span> <span class="keyword">set</span>]
    [clojure.walk <span class="symbol">:as</span> walk]
    [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
    [fulcro.server <span class="symbol">:as</span> server]
    [com.stuartsierra.component <span class="symbol">:as</span> c]
    [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
    [fulcro.logging <span class="symbol">:as</span> log]
    [fulcro.client <span class="symbol">:as</span> fc]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="comment">; A map from &quot;entry-level&quot; concept/entity to a set of the allowed graph read/navigation keywords</span>
(<span class="keyword">def</span> <span class="function">whitelist</span> {<span class="symbol">:person</span> #{<span class="symbol">:name</span> <span class="symbol">:address</span> <span class="symbol">:mate</span>}})

(<span class="keyword">defn</span> <span class="function">keywords-in-query</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Returns all of the keywords in the given (arbitrarily nested) query.</span><span class="delimiter">&quot;</span></span>
  [query]
  (<span class="keyword">let</span> [result (<span class="keyword">atom</span> #{})
        _      (walk/prewalk
                 (<span class="keyword">fn</span> [k] (<span class="keyword">if</span> (<span class="keyword">keyword?</span> k) (<span class="keyword">swap!</span> result <span class="keyword">conj</span> k)))
                 query)]
    @result))

<span class="comment">; TODO: determine if the user is allowed to start at the given keyword for entity with given ID</span>
(<span class="keyword">defn</span> <span class="function">authorized-root-entity?</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Returns true if the given user is allowed to run a query rooted at the entity indicated by the combination of
  query keyword and entity ID.

  TODO: Implement some logic here.</span><span class="delimiter">&quot;</span></span>
  [user <span class="keyword">keyword</span> id] <span class="predefined-constant">true</span>)

(<span class="keyword">defn</span> <span class="function">is-authorized-query?</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Returns true if the given query is ok with respect to the top-level key of the API query (which should have already
  been authorized by `authorized-root-entity?`.</span><span class="delimiter">&quot;</span></span>
  [query top-key]
  (<span class="keyword">let</span> [keywords-allowed  (<span class="keyword">get</span> whitelist top-key #{})
        insecure-keywords (set/difference (keywords-in-query query) keywords-allowed)]
    (<span class="keyword">empty?</span> insecure-keywords)))

(<span class="keyword">defprotocol</span> <span class="class">Auth</span>
  (can-access-entity? [this user <span class="keyword">key</span> entityid] <span class="string"><span class="delimiter">&quot;</span><span class="content">Check if the given user is allowed to access the entity designated by the given key and entity id</span><span class="delimiter">&quot;</span></span>)
  (authorized-query? [this user top-key query] <span class="string"><span class="delimiter">&quot;</span><span class="content">Check if the given user is allowed to access all of the data in the query that starts at the given join key</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">defrecord</span> <span class="class">Authorizer</span> []
  c/Lifecycle
  (start [this] this)
  (stop [this] this)
  Auth
  (can-access-entity? [this user <span class="keyword">key</span> entityid] (authorized-root-entity? user <span class="keyword">key</span> entityid))
  (authorized-query? [this user top-key query] (is-authorized-query? query top-key)))

(<span class="keyword">defn</span> <span class="function">make-authorizer</span> [] (map-&gt;Authorizer {}))

(<span class="keyword">def</span> <span class="function">pretend-database</span> {<span class="symbol">:person</span> {<span class="symbol">:id</span> <span class="integer">42</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span> <span class="symbol">:address</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">111 Nowhere</span><span class="delimiter">&quot;</span></span> <span class="symbol">:cc-number</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">1234-4444-5555-2222</span><span class="delimiter">&quot;</span></span>}})

(server/defquery-root <span class="symbol">:person</span>
  (value [{<span class="symbol">:keys</span> [request query] <span class="symbol">:as</span> env} params]
    (<span class="keyword">let</span> [authorization (make-authorizer)
          user          (<span class="symbol">:user</span> request)]
      (log/info (<span class="keyword">str</span> authorization <span class="string"><span class="delimiter">&quot;</span><span class="content">w/user</span><span class="delimiter">&quot;</span></span> user))
      (<span class="keyword">or</span>
        (<span class="keyword">and</span>
          <span class="comment">;; of course, the params would be derived from the request/headers/etc.</span>
          (can-access-entity? authorization user <span class="symbol">:person</span> <span class="integer">42</span>)
          (authorized-query? authorization user <span class="symbol">:person</span> query))
        (<span class="keyword">throw</span> (ex-info <span class="string"><span class="delimiter">&quot;</span><span class="content">Unauthorized query!</span><span class="delimiter">&quot;</span></span> {<span class="symbol">:status</span> <span class="integer">401</span> <span class="symbol">:body</span> {<span class="symbol">:query</span> query}})))
      <span class="comment">;; Emulate a datomic pull kind of operation...</span>
      (<span class="keyword">select-keys</span> (<span class="keyword">get</span> pretend-database <span class="symbol">:person</span>) query))))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(<span class="keyword">def</span> <span class="function">initial-state</span> {<span class="symbol">:ui/react-key</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">abc</span><span class="delimiter">&quot;</span></span>})

(<span class="keyword">defonce</span> <span class="function">app</span> (<span class="keyword">atom</span> (fc/make-fulcro-client
                     {<span class="symbol">:initial-state</span>    initial-state
                      <span class="symbol">:started-callback</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [reconciler]}]
                                          <span class="comment">; TODO</span>
                                          )})))

(defsc Person [this {<span class="symbol">:keys</span> [<span class="keyword">name</span> address cc-number]}]
  {<span class="symbol">:query</span> [<span class="symbol">:ui/fetch-state</span> <span class="symbol">:name</span> <span class="symbol">:address</span> <span class="symbol">:cc-number</span>]}
  (dom/div
    (dom/ul
      (dom/li (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">name: </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))
      (dom/li (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">address: </span><span class="delimiter">&quot;</span></span> address))
      (dom/li (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">cc-number: </span><span class="delimiter">&quot;</span></span> cc-number)))))

(<span class="keyword">def</span> <span class="function">ui-person</span> (comp/factory Person))

(defmutation clear-error [params] (action [{<span class="symbol">:keys</span> [state]}] (<span class="keyword">swap!</span> state <span class="keyword">dissoc</span> <span class="symbol">:fulcro/server-error</span>)))

(defsc Root [this {<span class="symbol">:keys</span> [person fulcro/server-error] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span> [{<span class="symbol">:person</span> (comp/get-query Person)} <span class="symbol">:fulcro/server-error</span>]}
  (dom/div
    (<span class="keyword">when</span> server-error
      (dom/p (<span class="keyword">pr-str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">SERVER ERROR: </span><span class="delimiter">&quot;</span></span> server-error)))
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> []
                            (comp/transact! this `[(clear-error {})])
                            (df/load this <span class="symbol">:person</span> Person {<span class="symbol">:refresh</span> [<span class="symbol">:person</span>]}))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Query for person with credit card</span><span class="delimiter">&quot;</span></span>)
    (dom/button {<span class="symbol">:onClick</span> (<span class="keyword">fn</span> []
                            (comp/transact! this `[(clear-error {})])
                            (df/load this <span class="symbol">:person</span> Person {<span class="symbol">:refresh</span> [<span class="symbol">:person</span>] <span class="symbol">:without</span> #{<span class="symbol">:cc-number</span>}}))} <span class="string"><span class="delimiter">&quot;</span><span class="content">Query for person WITHOUT credit card</span><span class="delimiter">&quot;</span></span>)
    (df/lazily-loaded ui-person person)))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fulcro_with_sql"><a class="anchor" href="#_fulcro_with_sql"></a><a class="link" href="#_fulcro_with_sql">28.6. Fulcro with SQL</a></h3>
<div class="paragraph">
<p>The Fulcro SQL library is capable of running many Fulcro graph queries directly
against an SQL database. It also comes with testing utilities and a component for
setting up connection pooling (via <a href="http://brettwooldridge.github.io/HikariCP">HikariCP</a>)
and migrations (via <a href="https://flywaydb.org/">Flyway</a>).</p>
</div>
<div class="paragraph">
<p>Since our demos run in the browser only for this document, we cannot show you a live demo,
but here are some basics to whet your appetite.</p>
</div>
<div class="paragraph">
<p>Assume you have a PostgreSQL database. We could create a project with
migrations in <code>src/main/config/migrations/V1__account_schema.sql</code>. See
Flyway documentation for naming conventions. For our example here,
let&#8217;s say our initial schema is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">CREATE TABLE settings (
  id                 SERIAL PRIMARY KEY,
  auto_open          BOOLEAN NOT NULL DEFAULT FALSE,
  keyboard_shortcuts BOOLEAN NOT NULL DEFAULT TRUE
)<span class="comment">;</span>

CREATE TABLE account (
  id             SERIAL PRIMARY KEY,
  <span class="keyword">name</span>           TEXT,
  last_edited_by INTEGER,
  settings_id    INTEGER REFERENCES settings (id),
  created_on     TIMESTAMP NOT NULL DEFAULT now()
)<span class="comment">;</span>

CREATE TABLE member (
  id         SERIAL PRIMARY KEY,
  <span class="keyword">name</span>       TEXT,
  account_id INTEGER NOT NULL REFERENCES account (id)
)<span class="comment">;</span>
ALTER TABLE account
  ADD CONSTRAINT account_last_edit_by_fkey FOREIGN KEY (last_edited_by) REFERENCES member (id)<span class="comment">;</span>

-- Some seed data <span class="keyword">for</span> the demo
INSERT INTO settings (id, auto_open, keyboard_shortcuts) VALUES (<span class="integer">1</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>)<span class="comment">;</span>
INSERT INTO settings (id, auto_open, keyboard_shortcuts) VALUES (<span class="integer">2</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">false</span>)<span class="comment">;</span>
INSERT INTO account (id, <span class="keyword">name</span>, settings_id) values (<span class="integer">1</span>, 'Sally', <span class="integer">1</span>)<span class="comment">;</span>
INSERT INTO account (id, <span class="keyword">name</span>, settings_id) values (<span class="integer">2</span>, 'Bob', <span class="integer">2</span>)<span class="comment">;</span>
INSERT INTO member (id, <span class="keyword">name</span>, account_id) values (<span class="integer">1</span>, 'Billy', <span class="integer">1</span>)<span class="comment">;</span>
INSERT INTO member (id, <span class="keyword">name</span>, account_id) values (<span class="integer">2</span>, 'Tom', <span class="integer">1</span>)<span class="comment">;</span>
INSERT INTO member (id, <span class="keyword">name</span>, account_id) values (<span class="integer">3</span>, 'Tori', <span class="integer">1</span>)<span class="comment">;</span>
INSERT INTO member (id, <span class="keyword">name</span>, account_id) values (<span class="integer">4</span>, 'Cory', <span class="integer">2</span>)<span class="comment">;</span>
INSERT INTO member (id, <span class="keyword">name</span>, account_id) values (<span class="integer">5</span>, 'Kady', <span class="integer">2</span>)<span class="comment">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The connection pooling needs to be configured as well, and Fulcro SQL allows this to
also be on the classpath. Assume we have <code>src/main/config/accountpool.props</code> with
(see HikariCP documentation):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
dataSource.user=test
dataSource.password<span class="keyword">=</span>
dataSource.databaseName=accounts
dataSource.portNumber=5432
dataSource.serverName=localhost</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then with some simple UI components like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc Settings [this {<span class="symbol">:keys</span> [db/id settings/auto-open? settings/keyboard-shortcuts?]}]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:settings/auto-open?</span> <span class="symbol">:settings/keyboard-shortcuts?</span>]
  <span class="keyword">..</span><span class="keyword">.</span>

(defsc Member [this {<span class="symbol">:keys</span> [db/id member/name]}]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:member/name</span>]
  <span class="keyword">..</span><span class="keyword">.</span>

(defsc Account [this {<span class="symbol">:keys</span> [db/id account/name account/members account/settings]}]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:account/name</span> {<span class="symbol">:account/members</span> (comp/get-query Member)} {<span class="symbol">:account/settings</span> (comp/get-query Settings)}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>we might want to issue a load like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(df/load app <span class="symbol">:graph-demo/accounts</span> Account {<span class="symbol">:target</span> [<span class="symbol">:accounts</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we&#8217;ve been careful to align the UI with the schema of the database. All
Fulcro SQL needs is a bit of configuration to tell it how to map the UI graph to the
schema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">schema</span>
 {<span class="symbol">:fulcro-sql.core/graph-&gt;sql</span> {<span class="symbol">:settings/auto-open?</span>          <span class="symbol">:settings/auto_open</span>
                               <span class="symbol">:settings/keyboard-shortcuts?</span> <span class="symbol">:settings/keyboard_shortcuts</span>}
  <span class="symbol">:fulcro-sql.core/joins</span>      {<span class="symbol">:account/members</span>  (sql/to-many [<span class="symbol">:account/id</span> <span class="symbol">:member/account_id</span>])
                               <span class="symbol">:account/settings</span> (sql/to-one [<span class="symbol">:account/settings_id</span> <span class="symbol">:settings/id</span>])
                               <span class="symbol">:member/account</span>   (sql/to-one [<span class="symbol">:member/account_id</span> <span class="symbol">:account/id</span>])}
  <span class="symbol">:fulcro-sql.core/pks</span>        {}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The relations (defined with <code>to-one</code> and <code>to-many</code>) assume you&#8217;ve chosen keyword namespaces that match your table names,
and keyword names that match column names (e.g. keyword <code>:account/id</code> &#8594; SQL <code>ACCOUNT.ID</code>). The joins are
then simply defined in the direction desired (you can see <code>:account/members</code> and <code>:member/account</code>
trafersing the same SQL "edge"). If that isn&#8217;t try, then you can remap them in the <code>graph&#8594;sql</code> section.</p>
</div>
<div class="paragraph">
<p>The database configuration (in our config EDN file) is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:port</span>   <span class="integer">8081</span>
 <span class="symbol">:sqldbm</span> {<span class="symbol">:accounts</span> {<span class="symbol">:hikaricp-config</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">config/accountpool.props</span><span class="delimiter">&quot;</span></span>
                     <span class="symbol">:auto-migrate?</span>   <span class="predefined-constant">true</span>
                     <span class="symbol">:create-drop?</span>    <span class="predefined-constant">true</span>
                     <span class="symbol">:migrations</span>      [<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:config/migrations</span><span class="delimiter">&quot;</span></span>]}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and we inject the Fulcro SQL component into our parsing environment via:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(core/make-fulcro-server
  <span class="keyword">..</span><span class="keyword">.</span>
  <span class="symbol">:parser-injections</span> #{<span class="symbol">:sqldb</span>}
  <span class="symbol">:components</span> {<span class="symbol">:sqldb</span> (component/using (sql/build-db-manager {}) [<span class="symbol">:config</span>])})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The server code to handle the query is then quite small:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(server/defquery-root <span class="symbol">:graph-demo/accounts</span>
 (value [{<span class="symbol">:keys</span> [sqldb query]} params] <span class="comment">; get the injected database manager</span>
   (<span class="keyword">let</span> [db              (sql/get-dbspec sqldb <span class="symbol">:accounts</span>) <span class="comment">; get the database from the db manager</span>
         <span class="comment">; Find the IDs of the account(s) of interest (all accounts)</span>
         all-account-ids (jdbc/query db [<span class="string"><span class="delimiter">&quot;</span><span class="content">select id from account</span><span class="delimiter">&quot;</span></span>] {<span class="symbol">:row-fn</span> <span class="symbol">:id</span> <span class="symbol">:result-set-fn</span> <span class="keyword">set</span>})]
     (<span class="keyword">if</span> (<span class="keyword">seq</span> all-account-ids)
       (sql/run-query db schema <span class="symbol">:account/id</span> query all-account-ids) <span class="comment">; run the graph query</span>
       []))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The complete source for this demo is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">book.demos.server-SQL-graph-queries</span>
  (<span class="symbol">:require</span>
    <span class="error">#</span>?@(<span class="symbol">:clj</span> [[fulcro-sql.core <span class="symbol">:as</span> sql]
              [clojure.java.jdbc <span class="symbol">:as</span> jdbc]
              [taoensso.timbre <span class="symbol">:as</span> timbre]])
              [com.stuartsierra.component <span class="symbol">:as</span> component]
              [com.fulcrologic.fulcro.dom <span class="symbol">:as</span> dom]
              [fulcro.easy_server <span class="symbol">:refer</span> [make-fulcro-server]]
              [fulcro.server <span class="symbol">:as</span> server <span class="symbol">:refer</span> [defquery-root server-read server-mutate]]
              [com.fulcrologic.fulcro.data-fetch <span class="symbol">:as</span> df]
              [fulcro.logging <span class="symbol">:as</span> log]
              [fulcro.client <span class="symbol">:as</span> fc]
              [fulcro.ui.bootstrap3 <span class="symbol">:as</span> b]
              [com.fulcrologic.fulcro.components <span class="symbol">:as</span> <span class="keyword">comp</span> <span class="symbol">:refer</span> [defsc]]))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; SERVER:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="error">#</span>?(<span class="symbol">:clj</span>
   (<span class="keyword">def</span> <span class="function">schema</span>
     {<span class="symbol">:fulcro-sql.core/graph-&gt;sql</span> {<span class="symbol">:settings/auto-open?</span>          <span class="symbol">:settings/auto_open</span>
                                   <span class="symbol">:settings/keyboard-shortcuts?</span> <span class="symbol">:settings/keyboard_shortcuts</span>}
      <span class="symbol">:fulcro-sql.core/joins</span>      {<span class="symbol">:account/members</span>  (sql/to-many [<span class="symbol">:account/id</span> <span class="symbol">:member/account_id</span>])
                                   <span class="symbol">:account/settings</span> (sql/to-one [<span class="symbol">:account/settings_id</span> <span class="symbol">:settings/id</span>])
                                   <span class="symbol">:member/account</span>   (sql/to-one [<span class="symbol">:member/account_id</span> <span class="symbol">:account/id</span>])}
      <span class="symbol">:fulcro-sql.core/pks</span>        {}}))

<span class="comment">; This is the only thing we wrote for the server...just return some value so we can</span>
<span class="comment">; see it really talked to the server for this query.</span>
<span class="error">#</span>?(<span class="symbol">:clj</span>
   (server/defquery-root <span class="symbol">:graph-demo/accounts</span>
     (value [{<span class="symbol">:keys</span> [sqldb query]} params]
       (<span class="keyword">let</span> [db              (sql/get-dbspec sqldb <span class="symbol">:accounts</span>)
             all-account-ids (jdbc/query db [<span class="string"><span class="delimiter">&quot;</span><span class="content">select id from account</span><span class="delimiter">&quot;</span></span>] {<span class="symbol">:row-fn</span> <span class="symbol">:id</span> <span class="symbol">:result-set-fn</span> <span class="keyword">set</span>})]
         (timbre/info all-account-ids)
         (<span class="keyword">if</span> (<span class="keyword">seq</span> all-account-ids)
           (sql/run-query db schema <span class="symbol">:account/id</span> query all-account-ids)
           [])))))

(<span class="keyword">defn</span> <span class="function">make-system</span> []
  (<span class="keyword">let</span> [include-postgres? (<span class="keyword">boolean</span> (System/getProperty <span class="string"><span class="delimiter">&quot;</span><span class="content">postgres</span><span class="delimiter">&quot;</span></span>))]
    (make-fulcro-server
      <span class="symbol">:config-path</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">config/demos.edn</span><span class="delimiter">&quot;</span></span>
      <span class="symbol">:parser-injections</span> (cond-&gt; #{<span class="symbol">:authorization</span>}
                           include-postgres? (<span class="keyword">conj</span> <span class="symbol">:sqldb</span>))
      <span class="symbol">:components</span> {<span class="symbol">:sqldb</span> (component/using
                            (sql/build-db-manager {})
                            [<span class="symbol">:config</span>])})))

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comment">;; CLIENT:</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(defsc Settings [this {<span class="symbol">:keys</span> [db/id settings/auto-open? settings/keyboard-shortcuts?]}]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:settings/auto-open?</span> <span class="symbol">:settings/keyboard-shortcuts?</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:settings/id</span> <span class="symbol">:db/id</span>]}
  (dom/ul
    (dom/li (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Auto open? </span><span class="delimiter">&quot;</span></span> auto-open?))
    (dom/li (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Enable Keyboard Shortcuts? </span><span class="delimiter">&quot;</span></span> keyboard-shortcuts?))))

(<span class="keyword">def</span> <span class="function">ui-settings</span> (comp/factory Settings {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc Member [this {<span class="symbol">:keys</span> [db/id member/name]}]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:member/name</span>]
   <span class="symbol">:ident</span> [<span class="symbol">:member/id</span> <span class="symbol">:db/id</span>]}
  (dom/div
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Member: </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))

(<span class="keyword">def</span> <span class="function">ui-member</span> (comp/factory Member {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc Account [this {<span class="symbol">:keys</span> [db/id account/name account/members account/settings]}]
  {<span class="symbol">:query</span> [<span class="symbol">:db/id</span> <span class="symbol">:account/name</span> {<span class="symbol">:account/members</span> (comp/get-query Member)} {<span class="symbol">:account/settings</span> (comp/get-query Settings)}]
   <span class="symbol">:ident</span> [<span class="symbol">:account/id</span> <span class="symbol">:db/id</span>]}
  (dom/div
    (dom/h3 (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Account for </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))
    (dom/ul
      (<span class="keyword">when</span> (<span class="keyword">seq</span> settings)
        (dom/li
          (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Settings</span><span class="delimiter">&quot;</span></span>)
          (ui-settings settings)))
      (dom/li
        (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Members in the account</span><span class="delimiter">&quot;</span></span>)
        (<span class="keyword">map</span> ui-member members)))))

(<span class="keyword">def</span> <span class="function">ui-account</span> (comp/factory Account {<span class="symbol">:keyfn</span> <span class="symbol">:db/id</span>}))

(defsc Root [this {<span class="symbol">:keys</span> [ui/react-key accounts]}]
  {<span class="symbol">:query</span> [<span class="symbol">:ui/react-key</span> {<span class="symbol">:accounts</span> (comp/get-query Account)}]}
  (dom/div {<span class="symbol">:key</span> react-key}
    (dom/h3 <span class="string"><span class="delimiter">&quot;</span><span class="content">Accounts with settings and users</span><span class="delimiter">&quot;</span></span>)
    (<span class="keyword">map</span> ui-account accounts)))


<span class="error">#</span>?(<span class="symbol">:cljs</span> (<span class="keyword">defonce</span> <span class="function">app</span> (<span class="keyword">atom</span> (fc/make-fulcro-client
                              {<span class="symbol">:client-did-mount</span>
                               (<span class="keyword">fn</span> [app]
                                 (df/load app <span class="symbol">:graph-demo/accounts</span> Account {<span class="symbol">:target</span> [<span class="symbol">:accounts</span>]}))})))) `<span class="error">#</span>?(<span class="symbol">:cljs</span> (<span class="keyword">swap!</span> app fc/mount Root <span class="string"><span class="delimiter">&quot;</span><span class="content">app</span><span class="delimiter">&quot;</span></span>))</code></pre>
</div>
</div>
<style>
.com-rigsomelight-rendered-edn .keyval > .keyword {
 color: rgb(196,33,0);
 padding-right: 10px;
}

.com-rigsomelight-rendered-edn .collection {
  position: relative;
}

.com-rigsomelight-rendered-edn .vector,
.com-rigsomelight-rendered-edn .set,
.com-rigsomelight-rendered-edn .seq  {
  padding-left: 0.9em;
  padding-right: 0.9em;
}

.com-rigsomelight-rendered-edn .set {
  padding-left: 1.2em;
}


.com-rigsomelight-rendered-edn .collection.map {
  padding-left: 0.8em;
  display: inline-block;
  vertical-align: top;
}

.com-rigsomelight-rendered-edn .vector,
.com-rigsomelight-rendered-edn .set,
.com-rigsomelight-rendered-edn .seq {
  display: inline-block;
  vertical-align: top;
}

.com-rigsomelight-rendered-edn .vector > .contents {
  background-color: rgba(0,0,0,0.01);
}

.com-rigsomelight-rendered-edn .keyval {
  display: inline-block;
}

.com-rigsomelight-rendered-edn .collection.map > .contents > .separator  {
padding-right: 10px;
}

.com-rigsomelight-rendered-edn .collection .collection > .contents {
/*  background-color: rgba(0,0,0,0.02); */
}

.com-rigsomelight-rendered-edn .collection .contents > .collection:nth-child(even) {
background-color: rgba(0,0,0,0.04);
}

.com-rigsomelight-rendered-edn .contents {
  display: inline-block;
}

.com-rigsomelight-rendered-edn .opener,
.com-rigsomelight-rendered-edn .closer {
 color: #999;
}

.com-rigsomelight-rendered-edn .collection.map > .opener,
.com-rigsomelight-rendered-edn .collection.vector > .opener,
.com-rigsomelight-rendered-edn .collection.seq > .opener,
.com-rigsomelight-rendered-edn .collection.set > .opener {
 position: absolute;
 top: 0px;
 left: 3px;
}
.com-rigsomelight-rendered-edn .collection.map > .closer {
 bottom: 0px;
 right: 0px;
 display: block;
}

.com-rigsomelight-rendered-edn .collection.vector > .closer,
.com-rigsomelight-rendered-edn .collection.seq > .closer,
.com-rigsomelight-rendered-edn .collection.set > .closer {
 position: absolute;
 bottom: 0px;
 right: 0px;
 display: block;
}
</style>

<!-- The book demos -->
<script src="js/book/book.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107376541-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-107376541-3');
</script>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 36<br>
Last updated 2019-08-07 07:32:07 +0530
</div>
</div>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid currentColor;opacity:.35;padding:0 .5em 0 0}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</body>
</html>